
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AccommodationRating
 * 
 */
export type AccommodationRating = $Result.DefaultSelection<Prisma.$AccommodationRatingPayload>
/**
 * Model CareerOutcome
 * 
 */
export type CareerOutcome = $Result.DefaultSelection<Prisma.$CareerOutcomePayload>
/**
 * Model Faq
 * 
 */
export type Faq = $Result.DefaultSelection<Prisma.$FaqPayload>
/**
 * Model University
 * 
 */
export type University = $Result.DefaultSelection<Prisma.$UniversityPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model UniversityApplications
 * 
 */
export type UniversityApplications = $Result.DefaultSelection<Prisma.$UniversityApplicationsPayload>
/**
 * Model Accommodation
 * 
 */
export type Accommodation = $Result.DefaultSelection<Prisma.$AccommodationPayload>
/**
 * Model PricingPlan
 * 
 */
export type PricingPlan = $Result.DefaultSelection<Prisma.$PricingPlanPayload>
/**
 * Model AccommodationApplication
 * 
 */
export type AccommodationApplication = $Result.DefaultSelection<Prisma.$AccommodationApplicationPayload>
/**
 * Model AccommodationReview
 * 
 */
export type AccommodationReview = $Result.DefaultSelection<Prisma.$AccommodationReviewPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model Loan
 * 
 */
export type Loan = $Result.DefaultSelection<Prisma.$LoanPayload>
/**
 * Model LoanApplication
 * 
 */
export type LoanApplication = $Result.DefaultSelection<Prisma.$LoanApplicationPayload>
/**
 * Model Vote
 * 
 */
export type Vote = $Result.DefaultSelection<Prisma.$VotePayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model GroupMember
 * 
 */
export type GroupMember = $Result.DefaultSelection<Prisma.$GroupMemberPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventRegistration
 * 
 */
export type EventRegistration = $Result.DefaultSelection<Prisma.$EventRegistrationPayload>
/**
 * Model Forum
 * 
 */
export type Forum = $Result.DefaultSelection<Prisma.$ForumPayload>
/**
 * Model ForumTopic
 * 
 */
export type ForumTopic = $Result.DefaultSelection<Prisma.$ForumTopicPayload>
/**
 * Model ForumReply
 * 
 */
export type ForumReply = $Result.DefaultSelection<Prisma.$ForumReplyPayload>
/**
 * Model ForumPost
 * 
 */
export type ForumPost = $Result.DefaultSelection<Prisma.$ForumPostPayload>
/**
 * Model ForumReplyReaction
 * 
 */
export type ForumReplyReaction = $Result.DefaultSelection<Prisma.$ForumReplyReactionPayload>
/**
 * Model ForumPostReaction
 * 
 */
export type ForumPostReaction = $Result.DefaultSelection<Prisma.$ForumPostReactionPayload>
/**
 * Model Article
 * 
 */
export type Article = $Result.DefaultSelection<Prisma.$ArticlePayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model FavCourse
 * 
 */
export type FavCourse = $Result.DefaultSelection<Prisma.$FavCoursePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model QuizAnswer
 * 
 */
export type QuizAnswer = $Result.DefaultSelection<Prisma.$QuizAnswerPayload>
/**
 * Model LikedAccommodations
 * 
 */
export type LikedAccommodations = $Result.DefaultSelection<Prisma.$LikedAccommodationsPayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model OTP
 * 
 */
export type OTP = $Result.DefaultSelection<Prisma.$OTPPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Blog
 * 
 */
export type Blog = $Result.DefaultSelection<Prisma.$BlogPayload>
/**
 * Model ContentBlock
 * 
 */
export type ContentBlock = $Result.DefaultSelection<Prisma.$ContentBlockPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TokenType: {
  REFRESH: 'REFRESH',
  PASSWORD_RESET: 'PASSWORD_RESET',
  EMAIL_VERIFICATION: 'EMAIL_VERIFICATION'
};

export type TokenType = (typeof TokenType)[keyof typeof TokenType]


export const UniversityType: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE'
};

export type UniversityType = (typeof UniversityType)[keyof typeof UniversityType]


export const UserRole: {
  STUDENT: 'STUDENT',
  LANDLORD: 'LANDLORD',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AccommodationType: {
  PRIVATE_ROOM: 'PRIVATE_ROOM',
  SHARED_ROOM: 'SHARED_ROOM',
  STUDIO: 'STUDIO',
  APARTMENT: 'APARTMENT',
  HOUSE: 'HOUSE'
};

export type AccommodationType = (typeof AccommodationType)[keyof typeof AccommodationType]


export const FurnishingType: {
  FURNISHED: 'FURNISHED',
  UNFURNISHED: 'UNFURNISHED',
  PARTIAL: 'PARTIAL'
};

export type FurnishingType = (typeof FurnishingType)[keyof typeof FurnishingType]


export const ApplicationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  UNDER_REVIEW: 'UNDER_REVIEW'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const OTPType: {
  EMAIL: 'EMAIL',
  PHONE: 'PHONE'
};

export type OTPType = (typeof OTPType)[keyof typeof OTPType]


export const OTPPurpose: {
  SIGNUP_VERIFICATION: 'SIGNUP_VERIFICATION',
  LOGIN_VERIFICATION: 'LOGIN_VERIFICATION',
  PASSWORD_RESET: 'PASSWORD_RESET',
  EMAIL_CHANGE: 'EMAIL_CHANGE',
  PHONE_CHANGE: 'PHONE_CHANGE',
  PROFILE_UPDATE: 'PROFILE_UPDATE'
};

export type OTPPurpose = (typeof OTPPurpose)[keyof typeof OTPPurpose]


export const NotificationType: {
  OTP_SENT: 'OTP_SENT',
  OTP_VERIFIED: 'OTP_VERIFIED',
  OTP_EXPIRED: 'OTP_EXPIRED',
  OTP_INVALID: 'OTP_INVALID',
  ACCOUNT_VERIFIED: 'ACCOUNT_VERIFIED',
  LOGIN_ALERT: 'LOGIN_ALERT',
  PASSWORD_CHANGED: 'PASSWORD_CHANGED',
  EMAIL_CHANGED: 'EMAIL_CHANGED',
  PHONE_CHANGED: 'PHONE_CHANGED',
  PROFILE_UPDATED: 'PROFILE_UPDATED',
  SECURITY_ALERT: 'SECURITY_ALERT',
  LENDERS: 'LENDERS'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const ArticleType: {
  COMMUNITY: 'COMMUNITY',
  LENDERS: 'LENDERS'
};

export type ArticleType = (typeof ArticleType)[keyof typeof ArticleType]


export const ArticleStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type ArticleStatus = (typeof ArticleStatus)[keyof typeof ArticleStatus]


export const VoteType: {
  UP_VOTE: 'UP_VOTE',
  DOWN_VOTE: 'DOWN_VOTE'
};

export type VoteType = (typeof VoteType)[keyof typeof VoteType]


export const GroupPrivacy: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE',
  RESTRICTED: 'RESTRICTED'
};

export type GroupPrivacy = (typeof GroupPrivacy)[keyof typeof GroupPrivacy]


export const GroupMemberRole: {
  MEMBER: 'MEMBER',
  MODERATOR: 'MODERATOR',
  ADMIN: 'ADMIN',
  OWNER: 'OWNER'
};

export type GroupMemberRole = (typeof GroupMemberRole)[keyof typeof GroupMemberRole]


export const EventType: {
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE',
  HYBRID: 'HYBRID'
};

export type EventType = (typeof EventType)[keyof typeof EventType]


export const RegistrationType: {
  FREE: 'FREE',
  PAID: 'PAID',
  INVITE_ONLY: 'INVITE_ONLY'
};

export type RegistrationType = (typeof RegistrationType)[keyof typeof RegistrationType]


export const EventStatus: {
  UPCOMING: 'UPCOMING',
  ONGOING: 'ONGOING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type EventStatus = (typeof EventStatus)[keyof typeof EventStatus]


export const EventRegistrationStatus: {
  CONFIRMED: 'CONFIRMED',
  WAITLISTED: 'WAITLISTED',
  CANCELLED: 'CANCELLED'
};

export type EventRegistrationStatus = (typeof EventRegistrationStatus)[keyof typeof EventRegistrationStatus]


export const ForumType: {
  DISCUSSION: 'DISCUSSION',
  Q_AND_A: 'Q_AND_A',
  SUPPORT: 'SUPPORT'
};

export type ForumType = (typeof ForumType)[keyof typeof ForumType]


export const ForumPrivacy: {
  GROUP: 'GROUP',
  MEMBERS_ONLY: 'MEMBERS_ONLY',
  PRIVATE: 'PRIVATE',
  PUBLIC: 'PUBLIC'
};

export type ForumPrivacy = (typeof ForumPrivacy)[keyof typeof ForumPrivacy]


export const TopicType: {
  DISCUSSION: 'DISCUSSION',
  ANNOUNCEMENT: 'ANNOUNCEMENT',
  POLL: 'POLL'
};

export type TopicType = (typeof TopicType)[keyof typeof TopicType]


export const TopicStatus: {
  ACTIVE: 'ACTIVE',
  LOCKED: 'LOCKED',
  ARCHIVED: 'ARCHIVED'
};

export type TopicStatus = (typeof TopicStatus)[keyof typeof TopicStatus]


export const ReactionType: {
  LIKE: 'LIKE',
  LOVE: 'LOVE',
  HAHA: 'HAHA',
  WOW: 'WOW',
  SAD: 'SAD',
  ANGRY: 'ANGRY'
};

export type ReactionType = (typeof ReactionType)[keyof typeof ReactionType]


export const PricingPlanType: {
  BASIC: 'BASIC',
  PREMIUM: 'PREMIUM',
  ENTERPRISE: 'ENTERPRISE'
};

export type PricingPlanType = (typeof PricingPlanType)[keyof typeof PricingPlanType]

}

export type TokenType = $Enums.TokenType

export const TokenType: typeof $Enums.TokenType

export type UniversityType = $Enums.UniversityType

export const UniversityType: typeof $Enums.UniversityType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AccommodationType = $Enums.AccommodationType

export const AccommodationType: typeof $Enums.AccommodationType

export type FurnishingType = $Enums.FurnishingType

export const FurnishingType: typeof $Enums.FurnishingType

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type OTPType = $Enums.OTPType

export const OTPType: typeof $Enums.OTPType

export type OTPPurpose = $Enums.OTPPurpose

export const OTPPurpose: typeof $Enums.OTPPurpose

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type ArticleType = $Enums.ArticleType

export const ArticleType: typeof $Enums.ArticleType

export type ArticleStatus = $Enums.ArticleStatus

export const ArticleStatus: typeof $Enums.ArticleStatus

export type VoteType = $Enums.VoteType

export const VoteType: typeof $Enums.VoteType

export type GroupPrivacy = $Enums.GroupPrivacy

export const GroupPrivacy: typeof $Enums.GroupPrivacy

export type GroupMemberRole = $Enums.GroupMemberRole

export const GroupMemberRole: typeof $Enums.GroupMemberRole

export type EventType = $Enums.EventType

export const EventType: typeof $Enums.EventType

export type RegistrationType = $Enums.RegistrationType

export const RegistrationType: typeof $Enums.RegistrationType

export type EventStatus = $Enums.EventStatus

export const EventStatus: typeof $Enums.EventStatus

export type EventRegistrationStatus = $Enums.EventRegistrationStatus

export const EventRegistrationStatus: typeof $Enums.EventRegistrationStatus

export type ForumType = $Enums.ForumType

export const ForumType: typeof $Enums.ForumType

export type ForumPrivacy = $Enums.ForumPrivacy

export const ForumPrivacy: typeof $Enums.ForumPrivacy

export type TopicType = $Enums.TopicType

export const TopicType: typeof $Enums.TopicType

export type TopicStatus = $Enums.TopicStatus

export const TopicStatus: typeof $Enums.TopicStatus

export type ReactionType = $Enums.ReactionType

export const ReactionType: typeof $Enums.ReactionType

export type PricingPlanType = $Enums.PricingPlanType

export const PricingPlanType: typeof $Enums.PricingPlanType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AccommodationRatings
 * const accommodationRatings = await prisma.accommodationRating.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AccommodationRatings
   * const accommodationRatings = await prisma.accommodationRating.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.accommodationRating`: Exposes CRUD operations for the **AccommodationRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccommodationRatings
    * const accommodationRatings = await prisma.accommodationRating.findMany()
    * ```
    */
  get accommodationRating(): Prisma.AccommodationRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.careerOutcome`: Exposes CRUD operations for the **CareerOutcome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CareerOutcomes
    * const careerOutcomes = await prisma.careerOutcome.findMany()
    * ```
    */
  get careerOutcome(): Prisma.CareerOutcomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faq`: Exposes CRUD operations for the **Faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faqs
    * const faqs = await prisma.faq.findMany()
    * ```
    */
  get faq(): Prisma.FaqDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.university`: Exposes CRUD operations for the **University** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Universities
    * const universities = await prisma.university.findMany()
    * ```
    */
  get university(): Prisma.UniversityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.universityApplications`: Exposes CRUD operations for the **UniversityApplications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UniversityApplications
    * const universityApplications = await prisma.universityApplications.findMany()
    * ```
    */
  get universityApplications(): Prisma.UniversityApplicationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accommodation`: Exposes CRUD operations for the **Accommodation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accommodations
    * const accommodations = await prisma.accommodation.findMany()
    * ```
    */
  get accommodation(): Prisma.AccommodationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pricingPlan`: Exposes CRUD operations for the **PricingPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PricingPlans
    * const pricingPlans = await prisma.pricingPlan.findMany()
    * ```
    */
  get pricingPlan(): Prisma.PricingPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accommodationApplication`: Exposes CRUD operations for the **AccommodationApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccommodationApplications
    * const accommodationApplications = await prisma.accommodationApplication.findMany()
    * ```
    */
  get accommodationApplication(): Prisma.AccommodationApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accommodationReview`: Exposes CRUD operations for the **AccommodationReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccommodationReviews
    * const accommodationReviews = await prisma.accommodationReview.findMany()
    * ```
    */
  get accommodationReview(): Prisma.AccommodationReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loan`: Exposes CRUD operations for the **Loan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loans
    * const loans = await prisma.loan.findMany()
    * ```
    */
  get loan(): Prisma.LoanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loanApplication`: Exposes CRUD operations for the **LoanApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoanApplications
    * const loanApplications = await prisma.loanApplication.findMany()
    * ```
    */
  get loanApplication(): Prisma.LoanApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vote`: Exposes CRUD operations for the **Vote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.vote.findMany()
    * ```
    */
  get vote(): Prisma.VoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMember`: Exposes CRUD operations for the **GroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMembers
    * const groupMembers = await prisma.groupMember.findMany()
    * ```
    */
  get groupMember(): Prisma.GroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventRegistration`: Exposes CRUD operations for the **EventRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventRegistrations
    * const eventRegistrations = await prisma.eventRegistration.findMany()
    * ```
    */
  get eventRegistration(): Prisma.EventRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forum`: Exposes CRUD operations for the **Forum** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forums
    * const forums = await prisma.forum.findMany()
    * ```
    */
  get forum(): Prisma.ForumDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumTopic`: Exposes CRUD operations for the **ForumTopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumTopics
    * const forumTopics = await prisma.forumTopic.findMany()
    * ```
    */
  get forumTopic(): Prisma.ForumTopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumReply`: Exposes CRUD operations for the **ForumReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumReplies
    * const forumReplies = await prisma.forumReply.findMany()
    * ```
    */
  get forumReply(): Prisma.ForumReplyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumPost`: Exposes CRUD operations for the **ForumPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumPosts
    * const forumPosts = await prisma.forumPost.findMany()
    * ```
    */
  get forumPost(): Prisma.ForumPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumReplyReaction`: Exposes CRUD operations for the **ForumReplyReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumReplyReactions
    * const forumReplyReactions = await prisma.forumReplyReaction.findMany()
    * ```
    */
  get forumReplyReaction(): Prisma.ForumReplyReactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumPostReaction`: Exposes CRUD operations for the **ForumPostReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumPostReactions
    * const forumPostReactions = await prisma.forumPostReaction.findMany()
    * ```
    */
  get forumPostReaction(): Prisma.ForumPostReactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.article`: Exposes CRUD operations for the **Article** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.article.findMany()
    * ```
    */
  get article(): Prisma.ArticleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favCourse`: Exposes CRUD operations for the **FavCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FavCourses
    * const favCourses = await prisma.favCourse.findMany()
    * ```
    */
  get favCourse(): Prisma.FavCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizAnswer`: Exposes CRUD operations for the **QuizAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAnswers
    * const quizAnswers = await prisma.quizAnswer.findMany()
    * ```
    */
  get quizAnswer(): Prisma.QuizAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.likedAccommodations`: Exposes CRUD operations for the **LikedAccommodations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LikedAccommodations
    * const likedAccommodations = await prisma.likedAccommodations.findMany()
    * ```
    */
  get likedAccommodations(): Prisma.LikedAccommodationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oTP`: Exposes CRUD operations for the **OTP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OTPS
    * const oTPS = await prisma.oTP.findMany()
    * ```
    */
  get oTP(): Prisma.OTPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog`: Exposes CRUD operations for the **Blog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blog.findMany()
    * ```
    */
  get blog(): Prisma.BlogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentBlock`: Exposes CRUD operations for the **ContentBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentBlocks
    * const contentBlocks = await prisma.contentBlock.findMany()
    * ```
    */
  get contentBlock(): Prisma.ContentBlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AccommodationRating: 'AccommodationRating',
    CareerOutcome: 'CareerOutcome',
    Faq: 'Faq',
    University: 'University',
    Course: 'Course',
    UniversityApplications: 'UniversityApplications',
    Accommodation: 'Accommodation',
    PricingPlan: 'PricingPlan',
    AccommodationApplication: 'AccommodationApplication',
    AccommodationReview: 'AccommodationReview',
    Message: 'Message',
    Follow: 'Follow',
    Loan: 'Loan',
    LoanApplication: 'LoanApplication',
    Vote: 'Vote',
    Group: 'Group',
    GroupMember: 'GroupMember',
    Event: 'Event',
    EventRegistration: 'EventRegistration',
    Forum: 'Forum',
    ForumTopic: 'ForumTopic',
    ForumReply: 'ForumReply',
    ForumPost: 'ForumPost',
    ForumReplyReaction: 'ForumReplyReaction',
    ForumPostReaction: 'ForumPostReaction',
    Article: 'Article',
    Account: 'Account',
    Session: 'Session',
    Notification: 'Notification',
    FavCourse: 'FavCourse',
    User: 'User',
    QuizAnswer: 'QuizAnswer',
    LikedAccommodations: 'LikedAccommodations',
    Token: 'Token',
    OTP: 'OTP',
    VerificationToken: 'VerificationToken',
    Blog: 'Blog',
    ContentBlock: 'ContentBlock',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "accommodationRating" | "careerOutcome" | "faq" | "university" | "course" | "universityApplications" | "accommodation" | "pricingPlan" | "accommodationApplication" | "accommodationReview" | "message" | "follow" | "loan" | "loanApplication" | "vote" | "group" | "groupMember" | "event" | "eventRegistration" | "forum" | "forumTopic" | "forumReply" | "forumPost" | "forumReplyReaction" | "forumPostReaction" | "article" | "account" | "session" | "notification" | "favCourse" | "user" | "quizAnswer" | "likedAccommodations" | "token" | "oTP" | "verificationToken" | "blog" | "contentBlock" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AccommodationRating: {
        payload: Prisma.$AccommodationRatingPayload<ExtArgs>
        fields: Prisma.AccommodationRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccommodationRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccommodationRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationRatingPayload>
          }
          findFirst: {
            args: Prisma.AccommodationRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccommodationRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationRatingPayload>
          }
          findMany: {
            args: Prisma.AccommodationRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationRatingPayload>[]
          }
          create: {
            args: Prisma.AccommodationRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationRatingPayload>
          }
          createMany: {
            args: Prisma.AccommodationRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccommodationRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationRatingPayload>[]
          }
          delete: {
            args: Prisma.AccommodationRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationRatingPayload>
          }
          update: {
            args: Prisma.AccommodationRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationRatingPayload>
          }
          deleteMany: {
            args: Prisma.AccommodationRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccommodationRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccommodationRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationRatingPayload>[]
          }
          upsert: {
            args: Prisma.AccommodationRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationRatingPayload>
          }
          aggregate: {
            args: Prisma.AccommodationRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccommodationRating>
          }
          groupBy: {
            args: Prisma.AccommodationRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccommodationRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccommodationRatingCountArgs<ExtArgs>
            result: $Utils.Optional<AccommodationRatingCountAggregateOutputType> | number
          }
        }
      }
      CareerOutcome: {
        payload: Prisma.$CareerOutcomePayload<ExtArgs>
        fields: Prisma.CareerOutcomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CareerOutcomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerOutcomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CareerOutcomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerOutcomePayload>
          }
          findFirst: {
            args: Prisma.CareerOutcomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerOutcomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CareerOutcomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerOutcomePayload>
          }
          findMany: {
            args: Prisma.CareerOutcomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerOutcomePayload>[]
          }
          create: {
            args: Prisma.CareerOutcomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerOutcomePayload>
          }
          createMany: {
            args: Prisma.CareerOutcomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CareerOutcomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerOutcomePayload>[]
          }
          delete: {
            args: Prisma.CareerOutcomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerOutcomePayload>
          }
          update: {
            args: Prisma.CareerOutcomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerOutcomePayload>
          }
          deleteMany: {
            args: Prisma.CareerOutcomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CareerOutcomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CareerOutcomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerOutcomePayload>[]
          }
          upsert: {
            args: Prisma.CareerOutcomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerOutcomePayload>
          }
          aggregate: {
            args: Prisma.CareerOutcomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCareerOutcome>
          }
          groupBy: {
            args: Prisma.CareerOutcomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CareerOutcomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CareerOutcomeCountArgs<ExtArgs>
            result: $Utils.Optional<CareerOutcomeCountAggregateOutputType> | number
          }
        }
      }
      Faq: {
        payload: Prisma.$FaqPayload<ExtArgs>
        fields: Prisma.FaqFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FaqFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FaqFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>
          }
          findFirst: {
            args: Prisma.FaqFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FaqFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>
          }
          findMany: {
            args: Prisma.FaqFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>[]
          }
          create: {
            args: Prisma.FaqCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>
          }
          createMany: {
            args: Prisma.FaqCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FaqCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>[]
          }
          delete: {
            args: Prisma.FaqDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>
          }
          update: {
            args: Prisma.FaqUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>
          }
          deleteMany: {
            args: Prisma.FaqDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FaqUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FaqUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>[]
          }
          upsert: {
            args: Prisma.FaqUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqPayload>
          }
          aggregate: {
            args: Prisma.FaqAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaq>
          }
          groupBy: {
            args: Prisma.FaqGroupByArgs<ExtArgs>
            result: $Utils.Optional<FaqGroupByOutputType>[]
          }
          count: {
            args: Prisma.FaqCountArgs<ExtArgs>
            result: $Utils.Optional<FaqCountAggregateOutputType> | number
          }
        }
      }
      University: {
        payload: Prisma.$UniversityPayload<ExtArgs>
        fields: Prisma.UniversityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UniversityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UniversityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityPayload>
          }
          findFirst: {
            args: Prisma.UniversityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UniversityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityPayload>
          }
          findMany: {
            args: Prisma.UniversityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityPayload>[]
          }
          create: {
            args: Prisma.UniversityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityPayload>
          }
          createMany: {
            args: Prisma.UniversityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UniversityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityPayload>[]
          }
          delete: {
            args: Prisma.UniversityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityPayload>
          }
          update: {
            args: Prisma.UniversityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityPayload>
          }
          deleteMany: {
            args: Prisma.UniversityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UniversityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UniversityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityPayload>[]
          }
          upsert: {
            args: Prisma.UniversityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityPayload>
          }
          aggregate: {
            args: Prisma.UniversityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUniversity>
          }
          groupBy: {
            args: Prisma.UniversityGroupByArgs<ExtArgs>
            result: $Utils.Optional<UniversityGroupByOutputType>[]
          }
          count: {
            args: Prisma.UniversityCountArgs<ExtArgs>
            result: $Utils.Optional<UniversityCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      UniversityApplications: {
        payload: Prisma.$UniversityApplicationsPayload<ExtArgs>
        fields: Prisma.UniversityApplicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UniversityApplicationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityApplicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UniversityApplicationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityApplicationsPayload>
          }
          findFirst: {
            args: Prisma.UniversityApplicationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityApplicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UniversityApplicationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityApplicationsPayload>
          }
          findMany: {
            args: Prisma.UniversityApplicationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityApplicationsPayload>[]
          }
          create: {
            args: Prisma.UniversityApplicationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityApplicationsPayload>
          }
          createMany: {
            args: Prisma.UniversityApplicationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UniversityApplicationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityApplicationsPayload>[]
          }
          delete: {
            args: Prisma.UniversityApplicationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityApplicationsPayload>
          }
          update: {
            args: Prisma.UniversityApplicationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityApplicationsPayload>
          }
          deleteMany: {
            args: Prisma.UniversityApplicationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UniversityApplicationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UniversityApplicationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityApplicationsPayload>[]
          }
          upsert: {
            args: Prisma.UniversityApplicationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UniversityApplicationsPayload>
          }
          aggregate: {
            args: Prisma.UniversityApplicationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUniversityApplications>
          }
          groupBy: {
            args: Prisma.UniversityApplicationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UniversityApplicationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UniversityApplicationsCountArgs<ExtArgs>
            result: $Utils.Optional<UniversityApplicationsCountAggregateOutputType> | number
          }
        }
      }
      Accommodation: {
        payload: Prisma.$AccommodationPayload<ExtArgs>
        fields: Prisma.AccommodationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccommodationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccommodationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationPayload>
          }
          findFirst: {
            args: Prisma.AccommodationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccommodationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationPayload>
          }
          findMany: {
            args: Prisma.AccommodationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationPayload>[]
          }
          create: {
            args: Prisma.AccommodationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationPayload>
          }
          createMany: {
            args: Prisma.AccommodationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccommodationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationPayload>[]
          }
          delete: {
            args: Prisma.AccommodationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationPayload>
          }
          update: {
            args: Prisma.AccommodationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationPayload>
          }
          deleteMany: {
            args: Prisma.AccommodationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccommodationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccommodationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationPayload>[]
          }
          upsert: {
            args: Prisma.AccommodationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationPayload>
          }
          aggregate: {
            args: Prisma.AccommodationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccommodation>
          }
          groupBy: {
            args: Prisma.AccommodationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccommodationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccommodationCountArgs<ExtArgs>
            result: $Utils.Optional<AccommodationCountAggregateOutputType> | number
          }
        }
      }
      PricingPlan: {
        payload: Prisma.$PricingPlanPayload<ExtArgs>
        fields: Prisma.PricingPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PricingPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PricingPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          findFirst: {
            args: Prisma.PricingPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PricingPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          findMany: {
            args: Prisma.PricingPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>[]
          }
          create: {
            args: Prisma.PricingPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          createMany: {
            args: Prisma.PricingPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PricingPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>[]
          }
          delete: {
            args: Prisma.PricingPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          update: {
            args: Prisma.PricingPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          deleteMany: {
            args: Prisma.PricingPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PricingPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PricingPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>[]
          }
          upsert: {
            args: Prisma.PricingPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPlanPayload>
          }
          aggregate: {
            args: Prisma.PricingPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricingPlan>
          }
          groupBy: {
            args: Prisma.PricingPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricingPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PricingPlanCountArgs<ExtArgs>
            result: $Utils.Optional<PricingPlanCountAggregateOutputType> | number
          }
        }
      }
      AccommodationApplication: {
        payload: Prisma.$AccommodationApplicationPayload<ExtArgs>
        fields: Prisma.AccommodationApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccommodationApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccommodationApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationApplicationPayload>
          }
          findFirst: {
            args: Prisma.AccommodationApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccommodationApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationApplicationPayload>
          }
          findMany: {
            args: Prisma.AccommodationApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationApplicationPayload>[]
          }
          create: {
            args: Prisma.AccommodationApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationApplicationPayload>
          }
          createMany: {
            args: Prisma.AccommodationApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccommodationApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationApplicationPayload>[]
          }
          delete: {
            args: Prisma.AccommodationApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationApplicationPayload>
          }
          update: {
            args: Prisma.AccommodationApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationApplicationPayload>
          }
          deleteMany: {
            args: Prisma.AccommodationApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccommodationApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccommodationApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationApplicationPayload>[]
          }
          upsert: {
            args: Prisma.AccommodationApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationApplicationPayload>
          }
          aggregate: {
            args: Prisma.AccommodationApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccommodationApplication>
          }
          groupBy: {
            args: Prisma.AccommodationApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccommodationApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccommodationApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<AccommodationApplicationCountAggregateOutputType> | number
          }
        }
      }
      AccommodationReview: {
        payload: Prisma.$AccommodationReviewPayload<ExtArgs>
        fields: Prisma.AccommodationReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccommodationReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccommodationReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationReviewPayload>
          }
          findFirst: {
            args: Prisma.AccommodationReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccommodationReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationReviewPayload>
          }
          findMany: {
            args: Prisma.AccommodationReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationReviewPayload>[]
          }
          create: {
            args: Prisma.AccommodationReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationReviewPayload>
          }
          createMany: {
            args: Prisma.AccommodationReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccommodationReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationReviewPayload>[]
          }
          delete: {
            args: Prisma.AccommodationReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationReviewPayload>
          }
          update: {
            args: Prisma.AccommodationReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationReviewPayload>
          }
          deleteMany: {
            args: Prisma.AccommodationReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccommodationReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccommodationReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationReviewPayload>[]
          }
          upsert: {
            args: Prisma.AccommodationReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccommodationReviewPayload>
          }
          aggregate: {
            args: Prisma.AccommodationReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccommodationReview>
          }
          groupBy: {
            args: Prisma.AccommodationReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccommodationReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccommodationReviewCountArgs<ExtArgs>
            result: $Utils.Optional<AccommodationReviewCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      Loan: {
        payload: Prisma.$LoanPayload<ExtArgs>
        fields: Prisma.LoanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          findFirst: {
            args: Prisma.LoanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          findMany: {
            args: Prisma.LoanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>[]
          }
          create: {
            args: Prisma.LoanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          createMany: {
            args: Prisma.LoanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>[]
          }
          delete: {
            args: Prisma.LoanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          update: {
            args: Prisma.LoanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          deleteMany: {
            args: Prisma.LoanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>[]
          }
          upsert: {
            args: Prisma.LoanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanPayload>
          }
          aggregate: {
            args: Prisma.LoanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoan>
          }
          groupBy: {
            args: Prisma.LoanGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanCountArgs<ExtArgs>
            result: $Utils.Optional<LoanCountAggregateOutputType> | number
          }
        }
      }
      LoanApplication: {
        payload: Prisma.$LoanApplicationPayload<ExtArgs>
        fields: Prisma.LoanApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoanApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoanApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>
          }
          findFirst: {
            args: Prisma.LoanApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoanApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>
          }
          findMany: {
            args: Prisma.LoanApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>[]
          }
          create: {
            args: Prisma.LoanApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>
          }
          createMany: {
            args: Prisma.LoanApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoanApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>[]
          }
          delete: {
            args: Prisma.LoanApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>
          }
          update: {
            args: Prisma.LoanApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>
          }
          deleteMany: {
            args: Prisma.LoanApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoanApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoanApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>[]
          }
          upsert: {
            args: Prisma.LoanApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoanApplicationPayload>
          }
          aggregate: {
            args: Prisma.LoanApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoanApplication>
          }
          groupBy: {
            args: Prisma.LoanApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoanApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoanApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<LoanApplicationCountAggregateOutputType> | number
          }
        }
      }
      Vote: {
        payload: Prisma.$VotePayload<ExtArgs>
        fields: Prisma.VoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findFirst: {
            args: Prisma.VoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findMany: {
            args: Prisma.VoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          create: {
            args: Prisma.VoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          createMany: {
            args: Prisma.VoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          delete: {
            args: Prisma.VoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          update: {
            args: Prisma.VoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          deleteMany: {
            args: Prisma.VoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          upsert: {
            args: Prisma.VoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          aggregate: {
            args: Prisma.VoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVote>
          }
          groupBy: {
            args: Prisma.VoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoteCountArgs<ExtArgs>
            result: $Utils.Optional<VoteCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      GroupMember: {
        payload: Prisma.$GroupMemberPayload<ExtArgs>
        fields: Prisma.GroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findFirst: {
            args: Prisma.GroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findMany: {
            args: Prisma.GroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          create: {
            args: Prisma.GroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          createMany: {
            args: Prisma.GroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          delete: {
            args: Prisma.GroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          update: {
            args: Prisma.GroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.GroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.GroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          aggregate: {
            args: Prisma.GroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMember>
          }
          groupBy: {
            args: Prisma.GroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventRegistration: {
        payload: Prisma.$EventRegistrationPayload<ExtArgs>
        fields: Prisma.EventRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          findFirst: {
            args: Prisma.EventRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          findMany: {
            args: Prisma.EventRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
          }
          create: {
            args: Prisma.EventRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          createMany: {
            args: Prisma.EventRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventRegistrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
          }
          delete: {
            args: Prisma.EventRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          update: {
            args: Prisma.EventRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.EventRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventRegistrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
          }
          upsert: {
            args: Prisma.EventRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          aggregate: {
            args: Prisma.EventRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventRegistration>
          }
          groupBy: {
            args: Prisma.EventRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<EventRegistrationCountAggregateOutputType> | number
          }
        }
      }
      Forum: {
        payload: Prisma.$ForumPayload<ExtArgs>
        fields: Prisma.ForumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPayload>
          }
          findFirst: {
            args: Prisma.ForumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPayload>
          }
          findMany: {
            args: Prisma.ForumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPayload>[]
          }
          create: {
            args: Prisma.ForumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPayload>
          }
          createMany: {
            args: Prisma.ForumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPayload>[]
          }
          delete: {
            args: Prisma.ForumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPayload>
          }
          update: {
            args: Prisma.ForumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPayload>
          }
          deleteMany: {
            args: Prisma.ForumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ForumUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPayload>[]
          }
          upsert: {
            args: Prisma.ForumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPayload>
          }
          aggregate: {
            args: Prisma.ForumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForum>
          }
          groupBy: {
            args: Prisma.ForumGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumCountArgs<ExtArgs>
            result: $Utils.Optional<ForumCountAggregateOutputType> | number
          }
        }
      }
      ForumTopic: {
        payload: Prisma.$ForumTopicPayload<ExtArgs>
        fields: Prisma.ForumTopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumTopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumTopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          findFirst: {
            args: Prisma.ForumTopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumTopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          findMany: {
            args: Prisma.ForumTopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>[]
          }
          create: {
            args: Prisma.ForumTopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          createMany: {
            args: Prisma.ForumTopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumTopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>[]
          }
          delete: {
            args: Prisma.ForumTopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          update: {
            args: Prisma.ForumTopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          deleteMany: {
            args: Prisma.ForumTopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumTopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ForumTopicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>[]
          }
          upsert: {
            args: Prisma.ForumTopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          aggregate: {
            args: Prisma.ForumTopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumTopic>
          }
          groupBy: {
            args: Prisma.ForumTopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumTopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumTopicCountArgs<ExtArgs>
            result: $Utils.Optional<ForumTopicCountAggregateOutputType> | number
          }
        }
      }
      ForumReply: {
        payload: Prisma.$ForumReplyPayload<ExtArgs>
        fields: Prisma.ForumReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>
          }
          findFirst: {
            args: Prisma.ForumReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>
          }
          findMany: {
            args: Prisma.ForumReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>[]
          }
          create: {
            args: Prisma.ForumReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>
          }
          createMany: {
            args: Prisma.ForumReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumReplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>[]
          }
          delete: {
            args: Prisma.ForumReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>
          }
          update: {
            args: Prisma.ForumReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>
          }
          deleteMany: {
            args: Prisma.ForumReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ForumReplyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>[]
          }
          upsert: {
            args: Prisma.ForumReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyPayload>
          }
          aggregate: {
            args: Prisma.ForumReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumReply>
          }
          groupBy: {
            args: Prisma.ForumReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumReplyCountArgs<ExtArgs>
            result: $Utils.Optional<ForumReplyCountAggregateOutputType> | number
          }
        }
      }
      ForumPost: {
        payload: Prisma.$ForumPostPayload<ExtArgs>
        fields: Prisma.ForumPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          findFirst: {
            args: Prisma.ForumPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          findMany: {
            args: Prisma.ForumPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
          }
          create: {
            args: Prisma.ForumPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          createMany: {
            args: Prisma.ForumPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
          }
          delete: {
            args: Prisma.ForumPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          update: {
            args: Prisma.ForumPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          deleteMany: {
            args: Prisma.ForumPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ForumPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
          }
          upsert: {
            args: Prisma.ForumPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          aggregate: {
            args: Prisma.ForumPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumPost>
          }
          groupBy: {
            args: Prisma.ForumPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumPostCountArgs<ExtArgs>
            result: $Utils.Optional<ForumPostCountAggregateOutputType> | number
          }
        }
      }
      ForumReplyReaction: {
        payload: Prisma.$ForumReplyReactionPayload<ExtArgs>
        fields: Prisma.ForumReplyReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumReplyReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumReplyReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyReactionPayload>
          }
          findFirst: {
            args: Prisma.ForumReplyReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumReplyReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyReactionPayload>
          }
          findMany: {
            args: Prisma.ForumReplyReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyReactionPayload>[]
          }
          create: {
            args: Prisma.ForumReplyReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyReactionPayload>
          }
          createMany: {
            args: Prisma.ForumReplyReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumReplyReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyReactionPayload>[]
          }
          delete: {
            args: Prisma.ForumReplyReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyReactionPayload>
          }
          update: {
            args: Prisma.ForumReplyReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyReactionPayload>
          }
          deleteMany: {
            args: Prisma.ForumReplyReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumReplyReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ForumReplyReactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyReactionPayload>[]
          }
          upsert: {
            args: Prisma.ForumReplyReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumReplyReactionPayload>
          }
          aggregate: {
            args: Prisma.ForumReplyReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumReplyReaction>
          }
          groupBy: {
            args: Prisma.ForumReplyReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumReplyReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumReplyReactionCountArgs<ExtArgs>
            result: $Utils.Optional<ForumReplyReactionCountAggregateOutputType> | number
          }
        }
      }
      ForumPostReaction: {
        payload: Prisma.$ForumPostReactionPayload<ExtArgs>
        fields: Prisma.ForumPostReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumPostReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumPostReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostReactionPayload>
          }
          findFirst: {
            args: Prisma.ForumPostReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumPostReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostReactionPayload>
          }
          findMany: {
            args: Prisma.ForumPostReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostReactionPayload>[]
          }
          create: {
            args: Prisma.ForumPostReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostReactionPayload>
          }
          createMany: {
            args: Prisma.ForumPostReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumPostReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostReactionPayload>[]
          }
          delete: {
            args: Prisma.ForumPostReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostReactionPayload>
          }
          update: {
            args: Prisma.ForumPostReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostReactionPayload>
          }
          deleteMany: {
            args: Prisma.ForumPostReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumPostReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ForumPostReactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostReactionPayload>[]
          }
          upsert: {
            args: Prisma.ForumPostReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostReactionPayload>
          }
          aggregate: {
            args: Prisma.ForumPostReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumPostReaction>
          }
          groupBy: {
            args: Prisma.ForumPostReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumPostReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumPostReactionCountArgs<ExtArgs>
            result: $Utils.Optional<ForumPostReactionCountAggregateOutputType> | number
          }
        }
      }
      Article: {
        payload: Prisma.$ArticlePayload<ExtArgs>
        fields: Prisma.ArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findFirst: {
            args: Prisma.ArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findMany: {
            args: Prisma.ArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          create: {
            args: Prisma.ArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          createMany: {
            args: Prisma.ArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          delete: {
            args: Prisma.ArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          update: {
            args: Prisma.ArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          deleteMany: {
            args: Prisma.ArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArticleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          upsert: {
            args: Prisma.ArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          aggregate: {
            args: Prisma.ArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticle>
          }
          groupBy: {
            args: Prisma.ArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      FavCourse: {
        payload: Prisma.$FavCoursePayload<ExtArgs>
        fields: Prisma.FavCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavCoursePayload>
          }
          findFirst: {
            args: Prisma.FavCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavCoursePayload>
          }
          findMany: {
            args: Prisma.FavCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavCoursePayload>[]
          }
          create: {
            args: Prisma.FavCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavCoursePayload>
          }
          createMany: {
            args: Prisma.FavCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavCourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavCoursePayload>[]
          }
          delete: {
            args: Prisma.FavCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavCoursePayload>
          }
          update: {
            args: Prisma.FavCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavCoursePayload>
          }
          deleteMany: {
            args: Prisma.FavCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavCourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavCoursePayload>[]
          }
          upsert: {
            args: Prisma.FavCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavCoursePayload>
          }
          aggregate: {
            args: Prisma.FavCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavCourse>
          }
          groupBy: {
            args: Prisma.FavCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavCourseCountArgs<ExtArgs>
            result: $Utils.Optional<FavCourseCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      QuizAnswer: {
        payload: Prisma.$QuizAnswerPayload<ExtArgs>
        fields: Prisma.QuizAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          findFirst: {
            args: Prisma.QuizAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          findMany: {
            args: Prisma.QuizAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
          }
          create: {
            args: Prisma.QuizAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          createMany: {
            args: Prisma.QuizAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
          }
          delete: {
            args: Prisma.QuizAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          update: {
            args: Prisma.QuizAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          deleteMany: {
            args: Prisma.QuizAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
          }
          upsert: {
            args: Prisma.QuizAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          aggregate: {
            args: Prisma.QuizAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizAnswer>
          }
          groupBy: {
            args: Prisma.QuizAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<QuizAnswerCountAggregateOutputType> | number
          }
        }
      }
      LikedAccommodations: {
        payload: Prisma.$LikedAccommodationsPayload<ExtArgs>
        fields: Prisma.LikedAccommodationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikedAccommodationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedAccommodationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikedAccommodationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedAccommodationsPayload>
          }
          findFirst: {
            args: Prisma.LikedAccommodationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedAccommodationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikedAccommodationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedAccommodationsPayload>
          }
          findMany: {
            args: Prisma.LikedAccommodationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedAccommodationsPayload>[]
          }
          create: {
            args: Prisma.LikedAccommodationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedAccommodationsPayload>
          }
          createMany: {
            args: Prisma.LikedAccommodationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikedAccommodationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedAccommodationsPayload>[]
          }
          delete: {
            args: Prisma.LikedAccommodationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedAccommodationsPayload>
          }
          update: {
            args: Prisma.LikedAccommodationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedAccommodationsPayload>
          }
          deleteMany: {
            args: Prisma.LikedAccommodationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikedAccommodationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LikedAccommodationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedAccommodationsPayload>[]
          }
          upsert: {
            args: Prisma.LikedAccommodationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikedAccommodationsPayload>
          }
          aggregate: {
            args: Prisma.LikedAccommodationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLikedAccommodations>
          }
          groupBy: {
            args: Prisma.LikedAccommodationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikedAccommodationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikedAccommodationsCountArgs<ExtArgs>
            result: $Utils.Optional<LikedAccommodationsCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      OTP: {
        payload: Prisma.$OTPPayload<ExtArgs>
        fields: Prisma.OTPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OTPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OTPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          findFirst: {
            args: Prisma.OTPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OTPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          findMany: {
            args: Prisma.OTPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          create: {
            args: Prisma.OTPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          createMany: {
            args: Prisma.OTPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OTPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          delete: {
            args: Prisma.OTPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          update: {
            args: Prisma.OTPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          deleteMany: {
            args: Prisma.OTPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OTPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OTPUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>[]
          }
          upsert: {
            args: Prisma.OTPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPPayload>
          }
          aggregate: {
            args: Prisma.OTPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOTP>
          }
          groupBy: {
            args: Prisma.OTPGroupByArgs<ExtArgs>
            result: $Utils.Optional<OTPGroupByOutputType>[]
          }
          count: {
            args: Prisma.OTPCountArgs<ExtArgs>
            result: $Utils.Optional<OTPCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Blog: {
        payload: Prisma.$BlogPayload<ExtArgs>
        fields: Prisma.BlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findFirst: {
            args: Prisma.BlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findMany: {
            args: Prisma.BlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          create: {
            args: Prisma.BlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          createMany: {
            args: Prisma.BlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          delete: {
            args: Prisma.BlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          update: {
            args: Prisma.BlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          deleteMany: {
            args: Prisma.BlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          upsert: {
            args: Prisma.BlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          aggregate: {
            args: Prisma.BlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog>
          }
          groupBy: {
            args: Prisma.BlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCountAggregateOutputType> | number
          }
        }
      }
      ContentBlock: {
        payload: Prisma.$ContentBlockPayload<ExtArgs>
        fields: Prisma.ContentBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>
          }
          findFirst: {
            args: Prisma.ContentBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>
          }
          findMany: {
            args: Prisma.ContentBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>[]
          }
          create: {
            args: Prisma.ContentBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>
          }
          createMany: {
            args: Prisma.ContentBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentBlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>[]
          }
          delete: {
            args: Prisma.ContentBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>
          }
          update: {
            args: Prisma.ContentBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>
          }
          deleteMany: {
            args: Prisma.ContentBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentBlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>[]
          }
          upsert: {
            args: Prisma.ContentBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>
          }
          aggregate: {
            args: Prisma.ContentBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentBlock>
          }
          groupBy: {
            args: Prisma.ContentBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentBlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentBlockCountArgs<ExtArgs>
            result: $Utils.Optional<ContentBlockCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    accommodationRating?: AccommodationRatingOmit
    careerOutcome?: CareerOutcomeOmit
    faq?: FaqOmit
    university?: UniversityOmit
    course?: CourseOmit
    universityApplications?: UniversityApplicationsOmit
    accommodation?: AccommodationOmit
    pricingPlan?: PricingPlanOmit
    accommodationApplication?: AccommodationApplicationOmit
    accommodationReview?: AccommodationReviewOmit
    message?: MessageOmit
    follow?: FollowOmit
    loan?: LoanOmit
    loanApplication?: LoanApplicationOmit
    vote?: VoteOmit
    group?: GroupOmit
    groupMember?: GroupMemberOmit
    event?: EventOmit
    eventRegistration?: EventRegistrationOmit
    forum?: ForumOmit
    forumTopic?: ForumTopicOmit
    forumReply?: ForumReplyOmit
    forumPost?: ForumPostOmit
    forumReplyReaction?: ForumReplyReactionOmit
    forumPostReaction?: ForumPostReactionOmit
    article?: ArticleOmit
    account?: AccountOmit
    session?: SessionOmit
    notification?: NotificationOmit
    favCourse?: FavCourseOmit
    user?: UserOmit
    quizAnswer?: QuizAnswerOmit
    likedAccommodations?: LikedAccommodationsOmit
    token?: TokenOmit
    oTP?: OTPOmit
    verificationToken?: VerificationTokenOmit
    blog?: BlogOmit
    contentBlock?: ContentBlockOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UniversityCountOutputType
   */

  export type UniversityCountOutputType = {
    careerOutcomes: number
    faqs: number
    applications: number
    loans: number
    users: number
    courses: number
  }

  export type UniversityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerOutcomes?: boolean | UniversityCountOutputTypeCountCareerOutcomesArgs
    faqs?: boolean | UniversityCountOutputTypeCountFaqsArgs
    applications?: boolean | UniversityCountOutputTypeCountApplicationsArgs
    loans?: boolean | UniversityCountOutputTypeCountLoansArgs
    users?: boolean | UniversityCountOutputTypeCountUsersArgs
    courses?: boolean | UniversityCountOutputTypeCountCoursesArgs
  }

  // Custom InputTypes
  /**
   * UniversityCountOutputType without action
   */
  export type UniversityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityCountOutputType
     */
    select?: UniversityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UniversityCountOutputType without action
   */
  export type UniversityCountOutputTypeCountCareerOutcomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerOutcomeWhereInput
  }

  /**
   * UniversityCountOutputType without action
   */
  export type UniversityCountOutputTypeCountFaqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FaqWhereInput
  }

  /**
   * UniversityCountOutputType without action
   */
  export type UniversityCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UniversityApplicationsWhereInput
  }

  /**
   * UniversityCountOutputType without action
   */
  export type UniversityCountOutputTypeCountLoansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanWhereInput
  }

  /**
   * UniversityCountOutputType without action
   */
  export type UniversityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UniversityCountOutputType without action
   */
  export type UniversityCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    applications: number
    favByUsers: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | CourseCountOutputTypeCountApplicationsArgs
    favByUsers?: boolean | CourseCountOutputTypeCountFavByUsersArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UniversityApplicationsWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountFavByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavCourseWhereInput
  }


  /**
   * Count Type AccommodationCountOutputType
   */

  export type AccommodationCountOutputType = {
    reviews: number
    ratings: number
    likedBy: number
    pricingPlans: number
  }

  export type AccommodationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | AccommodationCountOutputTypeCountReviewsArgs
    ratings?: boolean | AccommodationCountOutputTypeCountRatingsArgs
    likedBy?: boolean | AccommodationCountOutputTypeCountLikedByArgs
    pricingPlans?: boolean | AccommodationCountOutputTypeCountPricingPlansArgs
  }

  // Custom InputTypes
  /**
   * AccommodationCountOutputType without action
   */
  export type AccommodationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationCountOutputType
     */
    select?: AccommodationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccommodationCountOutputType without action
   */
  export type AccommodationCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccommodationReviewWhereInput
  }

  /**
   * AccommodationCountOutputType without action
   */
  export type AccommodationCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccommodationRatingWhereInput
  }

  /**
   * AccommodationCountOutputType without action
   */
  export type AccommodationCountOutputTypeCountLikedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikedAccommodationsWhereInput
  }

  /**
   * AccommodationCountOutputType without action
   */
  export type AccommodationCountOutputTypeCountPricingPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingPlanWhereInput
  }


  /**
   * Count Type LoanCountOutputType
   */

  export type LoanCountOutputType = {
    applications: number
  }

  export type LoanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | LoanCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * LoanCountOutputType without action
   */
  export type LoanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanCountOutputType
     */
    select?: LoanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoanCountOutputType without action
   */
  export type LoanCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanApplicationWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    events: number
    articles: number
    forums: number
    members: number
    moderators: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | GroupCountOutputTypeCountEventsArgs
    articles?: boolean | GroupCountOutputTypeCountArticlesArgs
    forums?: boolean | GroupCountOutputTypeCountForumsArgs
    members?: boolean | GroupCountOutputTypeCountMembersArgs
    moderators?: boolean | GroupCountOutputTypeCountModeratorsArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountForumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountModeratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    registrations: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registrations?: boolean | EventCountOutputTypeCountRegistrationsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
  }


  /**
   * Count Type ForumCountOutputType
   */

  export type ForumCountOutputType = {
    topics: number
    forumReplies: number
  }

  export type ForumCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | ForumCountOutputTypeCountTopicsArgs
    forumReplies?: boolean | ForumCountOutputTypeCountForumRepliesArgs
  }

  // Custom InputTypes
  /**
   * ForumCountOutputType without action
   */
  export type ForumCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCountOutputType
     */
    select?: ForumCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumCountOutputType without action
   */
  export type ForumCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumTopicWhereInput
  }

  /**
   * ForumCountOutputType without action
   */
  export type ForumCountOutputTypeCountForumRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumReplyWhereInput
  }


  /**
   * Count Type ForumTopicCountOutputType
   */

  export type ForumTopicCountOutputType = {
    posts: number
    replies: number
  }

  export type ForumTopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | ForumTopicCountOutputTypeCountPostsArgs
    replies?: boolean | ForumTopicCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * ForumTopicCountOutputType without action
   */
  export type ForumTopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicCountOutputType
     */
    select?: ForumTopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumTopicCountOutputType without action
   */
  export type ForumTopicCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
  }

  /**
   * ForumTopicCountOutputType without action
   */
  export type ForumTopicCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumReplyWhereInput
  }


  /**
   * Count Type ForumReplyCountOutputType
   */

  export type ForumReplyCountOutputType = {
    reactions: number
    childReplies: number
  }

  export type ForumReplyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reactions?: boolean | ForumReplyCountOutputTypeCountReactionsArgs
    childReplies?: boolean | ForumReplyCountOutputTypeCountChildRepliesArgs
  }

  // Custom InputTypes
  /**
   * ForumReplyCountOutputType without action
   */
  export type ForumReplyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyCountOutputType
     */
    select?: ForumReplyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumReplyCountOutputType without action
   */
  export type ForumReplyCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumReplyReactionWhereInput
  }

  /**
   * ForumReplyCountOutputType without action
   */
  export type ForumReplyCountOutputTypeCountChildRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumReplyWhereInput
  }


  /**
   * Count Type ForumPostCountOutputType
   */

  export type ForumPostCountOutputType = {
    reactions: number
    replies: number
  }

  export type ForumPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reactions?: boolean | ForumPostCountOutputTypeCountReactionsArgs
    replies?: boolean | ForumPostCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * ForumPostCountOutputType without action
   */
  export type ForumPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostCountOutputType
     */
    select?: ForumPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumPostCountOutputType without action
   */
  export type ForumPostCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostReactionWhereInput
  }

  /**
   * ForumPostCountOutputType without action
   */
  export type ForumPostCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
  }


  /**
   * Count Type ArticleCountOutputType
   */

  export type ArticleCountOutputType = {
    votes: number
  }

  export type ArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | ArticleCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCountOutputType
     */
    select?: ArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    favCourses: number
    quizAnswers: number
    createdForums: number
    createdForumTopics: number
    forumReplies: number
    forumPosts: number
    forumReplyReactions: number
    forumPostReactions: number
    loanApplications: number
    accommodationRatings: number
    applications: number
    tokens: number
    accommodations: number
    accounts: number
    sessions: number
    otps: number
    notifications: number
    followers: number
    following: number
    sentMessages: number
    receivedMessages: number
    createdGroups: number
    adminOf: number
    groupMemberships: number
    hostedEvents: number
    articles: number
    accommodationReviews: number
    likedAccommodations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    favCourses?: boolean | UserCountOutputTypeCountFavCoursesArgs
    quizAnswers?: boolean | UserCountOutputTypeCountQuizAnswersArgs
    createdForums?: boolean | UserCountOutputTypeCountCreatedForumsArgs
    createdForumTopics?: boolean | UserCountOutputTypeCountCreatedForumTopicsArgs
    forumReplies?: boolean | UserCountOutputTypeCountForumRepliesArgs
    forumPosts?: boolean | UserCountOutputTypeCountForumPostsArgs
    forumReplyReactions?: boolean | UserCountOutputTypeCountForumReplyReactionsArgs
    forumPostReactions?: boolean | UserCountOutputTypeCountForumPostReactionsArgs
    loanApplications?: boolean | UserCountOutputTypeCountLoanApplicationsArgs
    accommodationRatings?: boolean | UserCountOutputTypeCountAccommodationRatingsArgs
    applications?: boolean | UserCountOutputTypeCountApplicationsArgs
    tokens?: boolean | UserCountOutputTypeCountTokensArgs
    accommodations?: boolean | UserCountOutputTypeCountAccommodationsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    otps?: boolean | UserCountOutputTypeCountOtpsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    createdGroups?: boolean | UserCountOutputTypeCountCreatedGroupsArgs
    adminOf?: boolean | UserCountOutputTypeCountAdminOfArgs
    groupMemberships?: boolean | UserCountOutputTypeCountGroupMembershipsArgs
    hostedEvents?: boolean | UserCountOutputTypeCountHostedEventsArgs
    articles?: boolean | UserCountOutputTypeCountArticlesArgs
    accommodationReviews?: boolean | UserCountOutputTypeCountAccommodationReviewsArgs
    likedAccommodations?: boolean | UserCountOutputTypeCountLikedAccommodationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavCourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuizAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAnswerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedForumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedForumTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumTopicWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForumRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumReplyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForumPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForumReplyReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumReplyReactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForumPostReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostReactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLoanApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccommodationRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccommodationRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UniversityApplicationsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccommodationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccommodationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTPWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHostedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccommodationReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccommodationReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikedAccommodationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikedAccommodationsWhereInput
  }


  /**
   * Count Type BlogCountOutputType
   */

  export type BlogCountOutputType = {
    contentBlocks: number
  }

  export type BlogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentBlocks?: boolean | BlogCountOutputTypeCountContentBlocksArgs
  }

  // Custom InputTypes
  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCountOutputType
     */
    select?: BlogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeCountContentBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentBlockWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AccommodationRating
   */

  export type AggregateAccommodationRating = {
    _count: AccommodationRatingCountAggregateOutputType | null
    _avg: AccommodationRatingAvgAggregateOutputType | null
    _sum: AccommodationRatingSumAggregateOutputType | null
    _min: AccommodationRatingMinAggregateOutputType | null
    _max: AccommodationRatingMaxAggregateOutputType | null
  }

  export type AccommodationRatingAvgAggregateOutputType = {
    rating: number | null
  }

  export type AccommodationRatingSumAggregateOutputType = {
    rating: number | null
  }

  export type AccommodationRatingMinAggregateOutputType = {
    id: string | null
    rating: number | null
    review: string | null
    userId: string | null
    accommodationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccommodationRatingMaxAggregateOutputType = {
    id: string | null
    rating: number | null
    review: string | null
    userId: string | null
    accommodationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccommodationRatingCountAggregateOutputType = {
    id: number
    rating: number
    review: number
    userId: number
    accommodationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccommodationRatingAvgAggregateInputType = {
    rating?: true
  }

  export type AccommodationRatingSumAggregateInputType = {
    rating?: true
  }

  export type AccommodationRatingMinAggregateInputType = {
    id?: true
    rating?: true
    review?: true
    userId?: true
    accommodationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccommodationRatingMaxAggregateInputType = {
    id?: true
    rating?: true
    review?: true
    userId?: true
    accommodationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccommodationRatingCountAggregateInputType = {
    id?: true
    rating?: true
    review?: true
    userId?: true
    accommodationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccommodationRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccommodationRating to aggregate.
     */
    where?: AccommodationRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationRatings to fetch.
     */
    orderBy?: AccommodationRatingOrderByWithRelationInput | AccommodationRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccommodationRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccommodationRatings
    **/
    _count?: true | AccommodationRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccommodationRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccommodationRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccommodationRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccommodationRatingMaxAggregateInputType
  }

  export type GetAccommodationRatingAggregateType<T extends AccommodationRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateAccommodationRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccommodationRating[P]>
      : GetScalarType<T[P], AggregateAccommodationRating[P]>
  }




  export type AccommodationRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccommodationRatingWhereInput
    orderBy?: AccommodationRatingOrderByWithAggregationInput | AccommodationRatingOrderByWithAggregationInput[]
    by: AccommodationRatingScalarFieldEnum[] | AccommodationRatingScalarFieldEnum
    having?: AccommodationRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccommodationRatingCountAggregateInputType | true
    _avg?: AccommodationRatingAvgAggregateInputType
    _sum?: AccommodationRatingSumAggregateInputType
    _min?: AccommodationRatingMinAggregateInputType
    _max?: AccommodationRatingMaxAggregateInputType
  }

  export type AccommodationRatingGroupByOutputType = {
    id: string
    rating: number
    review: string | null
    userId: string
    accommodationId: string
    createdAt: Date
    updatedAt: Date
    _count: AccommodationRatingCountAggregateOutputType | null
    _avg: AccommodationRatingAvgAggregateOutputType | null
    _sum: AccommodationRatingSumAggregateOutputType | null
    _min: AccommodationRatingMinAggregateOutputType | null
    _max: AccommodationRatingMaxAggregateOutputType | null
  }

  type GetAccommodationRatingGroupByPayload<T extends AccommodationRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccommodationRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccommodationRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccommodationRatingGroupByOutputType[P]>
            : GetScalarType<T[P], AccommodationRatingGroupByOutputType[P]>
        }
      >
    >


  export type AccommodationRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    review?: boolean
    userId?: boolean
    accommodationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accommodationRating"]>

  export type AccommodationRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    review?: boolean
    userId?: boolean
    accommodationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accommodationRating"]>

  export type AccommodationRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    review?: boolean
    userId?: boolean
    accommodationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accommodationRating"]>

  export type AccommodationRatingSelectScalar = {
    id?: boolean
    rating?: boolean
    review?: boolean
    userId?: boolean
    accommodationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccommodationRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rating" | "review" | "userId" | "accommodationId" | "createdAt" | "updatedAt", ExtArgs["result"]["accommodationRating"]>
  export type AccommodationRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }
  export type AccommodationRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }
  export type AccommodationRatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }

  export type $AccommodationRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccommodationRating"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      accommodation: Prisma.$AccommodationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rating: number
      review: string | null
      userId: string
      accommodationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accommodationRating"]>
    composites: {}
  }

  type AccommodationRatingGetPayload<S extends boolean | null | undefined | AccommodationRatingDefaultArgs> = $Result.GetResult<Prisma.$AccommodationRatingPayload, S>

  type AccommodationRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccommodationRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccommodationRatingCountAggregateInputType | true
    }

  export interface AccommodationRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccommodationRating'], meta: { name: 'AccommodationRating' } }
    /**
     * Find zero or one AccommodationRating that matches the filter.
     * @param {AccommodationRatingFindUniqueArgs} args - Arguments to find a AccommodationRating
     * @example
     * // Get one AccommodationRating
     * const accommodationRating = await prisma.accommodationRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccommodationRatingFindUniqueArgs>(args: SelectSubset<T, AccommodationRatingFindUniqueArgs<ExtArgs>>): Prisma__AccommodationRatingClient<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccommodationRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccommodationRatingFindUniqueOrThrowArgs} args - Arguments to find a AccommodationRating
     * @example
     * // Get one AccommodationRating
     * const accommodationRating = await prisma.accommodationRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccommodationRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, AccommodationRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccommodationRatingClient<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccommodationRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationRatingFindFirstArgs} args - Arguments to find a AccommodationRating
     * @example
     * // Get one AccommodationRating
     * const accommodationRating = await prisma.accommodationRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccommodationRatingFindFirstArgs>(args?: SelectSubset<T, AccommodationRatingFindFirstArgs<ExtArgs>>): Prisma__AccommodationRatingClient<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccommodationRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationRatingFindFirstOrThrowArgs} args - Arguments to find a AccommodationRating
     * @example
     * // Get one AccommodationRating
     * const accommodationRating = await prisma.accommodationRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccommodationRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, AccommodationRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccommodationRatingClient<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccommodationRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccommodationRatings
     * const accommodationRatings = await prisma.accommodationRating.findMany()
     * 
     * // Get first 10 AccommodationRatings
     * const accommodationRatings = await prisma.accommodationRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accommodationRatingWithIdOnly = await prisma.accommodationRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccommodationRatingFindManyArgs>(args?: SelectSubset<T, AccommodationRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccommodationRating.
     * @param {AccommodationRatingCreateArgs} args - Arguments to create a AccommodationRating.
     * @example
     * // Create one AccommodationRating
     * const AccommodationRating = await prisma.accommodationRating.create({
     *   data: {
     *     // ... data to create a AccommodationRating
     *   }
     * })
     * 
     */
    create<T extends AccommodationRatingCreateArgs>(args: SelectSubset<T, AccommodationRatingCreateArgs<ExtArgs>>): Prisma__AccommodationRatingClient<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccommodationRatings.
     * @param {AccommodationRatingCreateManyArgs} args - Arguments to create many AccommodationRatings.
     * @example
     * // Create many AccommodationRatings
     * const accommodationRating = await prisma.accommodationRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccommodationRatingCreateManyArgs>(args?: SelectSubset<T, AccommodationRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccommodationRatings and returns the data saved in the database.
     * @param {AccommodationRatingCreateManyAndReturnArgs} args - Arguments to create many AccommodationRatings.
     * @example
     * // Create many AccommodationRatings
     * const accommodationRating = await prisma.accommodationRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccommodationRatings and only return the `id`
     * const accommodationRatingWithIdOnly = await prisma.accommodationRating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccommodationRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, AccommodationRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccommodationRating.
     * @param {AccommodationRatingDeleteArgs} args - Arguments to delete one AccommodationRating.
     * @example
     * // Delete one AccommodationRating
     * const AccommodationRating = await prisma.accommodationRating.delete({
     *   where: {
     *     // ... filter to delete one AccommodationRating
     *   }
     * })
     * 
     */
    delete<T extends AccommodationRatingDeleteArgs>(args: SelectSubset<T, AccommodationRatingDeleteArgs<ExtArgs>>): Prisma__AccommodationRatingClient<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccommodationRating.
     * @param {AccommodationRatingUpdateArgs} args - Arguments to update one AccommodationRating.
     * @example
     * // Update one AccommodationRating
     * const accommodationRating = await prisma.accommodationRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccommodationRatingUpdateArgs>(args: SelectSubset<T, AccommodationRatingUpdateArgs<ExtArgs>>): Prisma__AccommodationRatingClient<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccommodationRatings.
     * @param {AccommodationRatingDeleteManyArgs} args - Arguments to filter AccommodationRatings to delete.
     * @example
     * // Delete a few AccommodationRatings
     * const { count } = await prisma.accommodationRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccommodationRatingDeleteManyArgs>(args?: SelectSubset<T, AccommodationRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccommodationRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccommodationRatings
     * const accommodationRating = await prisma.accommodationRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccommodationRatingUpdateManyArgs>(args: SelectSubset<T, AccommodationRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccommodationRatings and returns the data updated in the database.
     * @param {AccommodationRatingUpdateManyAndReturnArgs} args - Arguments to update many AccommodationRatings.
     * @example
     * // Update many AccommodationRatings
     * const accommodationRating = await prisma.accommodationRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccommodationRatings and only return the `id`
     * const accommodationRatingWithIdOnly = await prisma.accommodationRating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccommodationRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, AccommodationRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccommodationRating.
     * @param {AccommodationRatingUpsertArgs} args - Arguments to update or create a AccommodationRating.
     * @example
     * // Update or create a AccommodationRating
     * const accommodationRating = await prisma.accommodationRating.upsert({
     *   create: {
     *     // ... data to create a AccommodationRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccommodationRating we want to update
     *   }
     * })
     */
    upsert<T extends AccommodationRatingUpsertArgs>(args: SelectSubset<T, AccommodationRatingUpsertArgs<ExtArgs>>): Prisma__AccommodationRatingClient<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccommodationRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationRatingCountArgs} args - Arguments to filter AccommodationRatings to count.
     * @example
     * // Count the number of AccommodationRatings
     * const count = await prisma.accommodationRating.count({
     *   where: {
     *     // ... the filter for the AccommodationRatings we want to count
     *   }
     * })
    **/
    count<T extends AccommodationRatingCountArgs>(
      args?: Subset<T, AccommodationRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccommodationRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccommodationRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccommodationRatingAggregateArgs>(args: Subset<T, AccommodationRatingAggregateArgs>): Prisma.PrismaPromise<GetAccommodationRatingAggregateType<T>>

    /**
     * Group by AccommodationRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccommodationRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccommodationRatingGroupByArgs['orderBy'] }
        : { orderBy?: AccommodationRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccommodationRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccommodationRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccommodationRating model
   */
  readonly fields: AccommodationRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccommodationRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccommodationRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    accommodation<T extends AccommodationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccommodationDefaultArgs<ExtArgs>>): Prisma__AccommodationClient<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccommodationRating model
   */
  interface AccommodationRatingFieldRefs {
    readonly id: FieldRef<"AccommodationRating", 'String'>
    readonly rating: FieldRef<"AccommodationRating", 'Float'>
    readonly review: FieldRef<"AccommodationRating", 'String'>
    readonly userId: FieldRef<"AccommodationRating", 'String'>
    readonly accommodationId: FieldRef<"AccommodationRating", 'String'>
    readonly createdAt: FieldRef<"AccommodationRating", 'DateTime'>
    readonly updatedAt: FieldRef<"AccommodationRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccommodationRating findUnique
   */
  export type AccommodationRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationRating to fetch.
     */
    where: AccommodationRatingWhereUniqueInput
  }

  /**
   * AccommodationRating findUniqueOrThrow
   */
  export type AccommodationRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationRating to fetch.
     */
    where: AccommodationRatingWhereUniqueInput
  }

  /**
   * AccommodationRating findFirst
   */
  export type AccommodationRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationRating to fetch.
     */
    where?: AccommodationRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationRatings to fetch.
     */
    orderBy?: AccommodationRatingOrderByWithRelationInput | AccommodationRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccommodationRatings.
     */
    cursor?: AccommodationRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccommodationRatings.
     */
    distinct?: AccommodationRatingScalarFieldEnum | AccommodationRatingScalarFieldEnum[]
  }

  /**
   * AccommodationRating findFirstOrThrow
   */
  export type AccommodationRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationRating to fetch.
     */
    where?: AccommodationRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationRatings to fetch.
     */
    orderBy?: AccommodationRatingOrderByWithRelationInput | AccommodationRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccommodationRatings.
     */
    cursor?: AccommodationRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccommodationRatings.
     */
    distinct?: AccommodationRatingScalarFieldEnum | AccommodationRatingScalarFieldEnum[]
  }

  /**
   * AccommodationRating findMany
   */
  export type AccommodationRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationRatings to fetch.
     */
    where?: AccommodationRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationRatings to fetch.
     */
    orderBy?: AccommodationRatingOrderByWithRelationInput | AccommodationRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccommodationRatings.
     */
    cursor?: AccommodationRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationRatings.
     */
    skip?: number
    distinct?: AccommodationRatingScalarFieldEnum | AccommodationRatingScalarFieldEnum[]
  }

  /**
   * AccommodationRating create
   */
  export type AccommodationRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a AccommodationRating.
     */
    data: XOR<AccommodationRatingCreateInput, AccommodationRatingUncheckedCreateInput>
  }

  /**
   * AccommodationRating createMany
   */
  export type AccommodationRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccommodationRatings.
     */
    data: AccommodationRatingCreateManyInput | AccommodationRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccommodationRating createManyAndReturn
   */
  export type AccommodationRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * The data used to create many AccommodationRatings.
     */
    data: AccommodationRatingCreateManyInput | AccommodationRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccommodationRating update
   */
  export type AccommodationRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a AccommodationRating.
     */
    data: XOR<AccommodationRatingUpdateInput, AccommodationRatingUncheckedUpdateInput>
    /**
     * Choose, which AccommodationRating to update.
     */
    where: AccommodationRatingWhereUniqueInput
  }

  /**
   * AccommodationRating updateMany
   */
  export type AccommodationRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccommodationRatings.
     */
    data: XOR<AccommodationRatingUpdateManyMutationInput, AccommodationRatingUncheckedUpdateManyInput>
    /**
     * Filter which AccommodationRatings to update
     */
    where?: AccommodationRatingWhereInput
    /**
     * Limit how many AccommodationRatings to update.
     */
    limit?: number
  }

  /**
   * AccommodationRating updateManyAndReturn
   */
  export type AccommodationRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * The data used to update AccommodationRatings.
     */
    data: XOR<AccommodationRatingUpdateManyMutationInput, AccommodationRatingUncheckedUpdateManyInput>
    /**
     * Filter which AccommodationRatings to update
     */
    where?: AccommodationRatingWhereInput
    /**
     * Limit how many AccommodationRatings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccommodationRating upsert
   */
  export type AccommodationRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the AccommodationRating to update in case it exists.
     */
    where: AccommodationRatingWhereUniqueInput
    /**
     * In case the AccommodationRating found by the `where` argument doesn't exist, create a new AccommodationRating with this data.
     */
    create: XOR<AccommodationRatingCreateInput, AccommodationRatingUncheckedCreateInput>
    /**
     * In case the AccommodationRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccommodationRatingUpdateInput, AccommodationRatingUncheckedUpdateInput>
  }

  /**
   * AccommodationRating delete
   */
  export type AccommodationRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingInclude<ExtArgs> | null
    /**
     * Filter which AccommodationRating to delete.
     */
    where: AccommodationRatingWhereUniqueInput
  }

  /**
   * AccommodationRating deleteMany
   */
  export type AccommodationRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccommodationRatings to delete
     */
    where?: AccommodationRatingWhereInput
    /**
     * Limit how many AccommodationRatings to delete.
     */
    limit?: number
  }

  /**
   * AccommodationRating without action
   */
  export type AccommodationRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingInclude<ExtArgs> | null
  }


  /**
   * Model CareerOutcome
   */

  export type AggregateCareerOutcome = {
    _count: CareerOutcomeCountAggregateOutputType | null
    _min: CareerOutcomeMinAggregateOutputType | null
    _max: CareerOutcomeMaxAggregateOutputType | null
  }

  export type CareerOutcomeMinAggregateOutputType = {
    id: string | null
    iconName: string | null
    iconImage: string | null
    title: string | null
    value: string | null
    description: string | null
    details: string | null
    color: string | null
    bgColor: string | null
    universityId: string | null
  }

  export type CareerOutcomeMaxAggregateOutputType = {
    id: string | null
    iconName: string | null
    iconImage: string | null
    title: string | null
    value: string | null
    description: string | null
    details: string | null
    color: string | null
    bgColor: string | null
    universityId: string | null
  }

  export type CareerOutcomeCountAggregateOutputType = {
    id: number
    iconName: number
    iconImage: number
    title: number
    value: number
    description: number
    details: number
    color: number
    bgColor: number
    universityId: number
    _all: number
  }


  export type CareerOutcomeMinAggregateInputType = {
    id?: true
    iconName?: true
    iconImage?: true
    title?: true
    value?: true
    description?: true
    details?: true
    color?: true
    bgColor?: true
    universityId?: true
  }

  export type CareerOutcomeMaxAggregateInputType = {
    id?: true
    iconName?: true
    iconImage?: true
    title?: true
    value?: true
    description?: true
    details?: true
    color?: true
    bgColor?: true
    universityId?: true
  }

  export type CareerOutcomeCountAggregateInputType = {
    id?: true
    iconName?: true
    iconImage?: true
    title?: true
    value?: true
    description?: true
    details?: true
    color?: true
    bgColor?: true
    universityId?: true
    _all?: true
  }

  export type CareerOutcomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CareerOutcome to aggregate.
     */
    where?: CareerOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerOutcomes to fetch.
     */
    orderBy?: CareerOutcomeOrderByWithRelationInput | CareerOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CareerOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CareerOutcomes
    **/
    _count?: true | CareerOutcomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareerOutcomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareerOutcomeMaxAggregateInputType
  }

  export type GetCareerOutcomeAggregateType<T extends CareerOutcomeAggregateArgs> = {
        [P in keyof T & keyof AggregateCareerOutcome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareerOutcome[P]>
      : GetScalarType<T[P], AggregateCareerOutcome[P]>
  }




  export type CareerOutcomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerOutcomeWhereInput
    orderBy?: CareerOutcomeOrderByWithAggregationInput | CareerOutcomeOrderByWithAggregationInput[]
    by: CareerOutcomeScalarFieldEnum[] | CareerOutcomeScalarFieldEnum
    having?: CareerOutcomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareerOutcomeCountAggregateInputType | true
    _min?: CareerOutcomeMinAggregateInputType
    _max?: CareerOutcomeMaxAggregateInputType
  }

  export type CareerOutcomeGroupByOutputType = {
    id: string
    iconName: string
    iconImage: string
    title: string
    value: string
    description: string
    details: string
    color: string
    bgColor: string
    universityId: string
    _count: CareerOutcomeCountAggregateOutputType | null
    _min: CareerOutcomeMinAggregateOutputType | null
    _max: CareerOutcomeMaxAggregateOutputType | null
  }

  type GetCareerOutcomeGroupByPayload<T extends CareerOutcomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CareerOutcomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareerOutcomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareerOutcomeGroupByOutputType[P]>
            : GetScalarType<T[P], CareerOutcomeGroupByOutputType[P]>
        }
      >
    >


  export type CareerOutcomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    iconName?: boolean
    iconImage?: boolean
    title?: boolean
    value?: boolean
    description?: boolean
    details?: boolean
    color?: boolean
    bgColor?: boolean
    universityId?: boolean
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerOutcome"]>

  export type CareerOutcomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    iconName?: boolean
    iconImage?: boolean
    title?: boolean
    value?: boolean
    description?: boolean
    details?: boolean
    color?: boolean
    bgColor?: boolean
    universityId?: boolean
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerOutcome"]>

  export type CareerOutcomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    iconName?: boolean
    iconImage?: boolean
    title?: boolean
    value?: boolean
    description?: boolean
    details?: boolean
    color?: boolean
    bgColor?: boolean
    universityId?: boolean
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerOutcome"]>

  export type CareerOutcomeSelectScalar = {
    id?: boolean
    iconName?: boolean
    iconImage?: boolean
    title?: boolean
    value?: boolean
    description?: boolean
    details?: boolean
    color?: boolean
    bgColor?: boolean
    universityId?: boolean
  }

  export type CareerOutcomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "iconName" | "iconImage" | "title" | "value" | "description" | "details" | "color" | "bgColor" | "universityId", ExtArgs["result"]["careerOutcome"]>
  export type CareerOutcomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }
  export type CareerOutcomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }
  export type CareerOutcomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }

  export type $CareerOutcomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CareerOutcome"
    objects: {
      university: Prisma.$UniversityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      iconName: string
      iconImage: string
      title: string
      value: string
      description: string
      details: string
      color: string
      bgColor: string
      universityId: string
    }, ExtArgs["result"]["careerOutcome"]>
    composites: {}
  }

  type CareerOutcomeGetPayload<S extends boolean | null | undefined | CareerOutcomeDefaultArgs> = $Result.GetResult<Prisma.$CareerOutcomePayload, S>

  type CareerOutcomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CareerOutcomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CareerOutcomeCountAggregateInputType | true
    }

  export interface CareerOutcomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CareerOutcome'], meta: { name: 'CareerOutcome' } }
    /**
     * Find zero or one CareerOutcome that matches the filter.
     * @param {CareerOutcomeFindUniqueArgs} args - Arguments to find a CareerOutcome
     * @example
     * // Get one CareerOutcome
     * const careerOutcome = await prisma.careerOutcome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CareerOutcomeFindUniqueArgs>(args: SelectSubset<T, CareerOutcomeFindUniqueArgs<ExtArgs>>): Prisma__CareerOutcomeClient<$Result.GetResult<Prisma.$CareerOutcomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CareerOutcome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CareerOutcomeFindUniqueOrThrowArgs} args - Arguments to find a CareerOutcome
     * @example
     * // Get one CareerOutcome
     * const careerOutcome = await prisma.careerOutcome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CareerOutcomeFindUniqueOrThrowArgs>(args: SelectSubset<T, CareerOutcomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CareerOutcomeClient<$Result.GetResult<Prisma.$CareerOutcomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CareerOutcome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerOutcomeFindFirstArgs} args - Arguments to find a CareerOutcome
     * @example
     * // Get one CareerOutcome
     * const careerOutcome = await prisma.careerOutcome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CareerOutcomeFindFirstArgs>(args?: SelectSubset<T, CareerOutcomeFindFirstArgs<ExtArgs>>): Prisma__CareerOutcomeClient<$Result.GetResult<Prisma.$CareerOutcomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CareerOutcome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerOutcomeFindFirstOrThrowArgs} args - Arguments to find a CareerOutcome
     * @example
     * // Get one CareerOutcome
     * const careerOutcome = await prisma.careerOutcome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CareerOutcomeFindFirstOrThrowArgs>(args?: SelectSubset<T, CareerOutcomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CareerOutcomeClient<$Result.GetResult<Prisma.$CareerOutcomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CareerOutcomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerOutcomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CareerOutcomes
     * const careerOutcomes = await prisma.careerOutcome.findMany()
     * 
     * // Get first 10 CareerOutcomes
     * const careerOutcomes = await prisma.careerOutcome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const careerOutcomeWithIdOnly = await prisma.careerOutcome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CareerOutcomeFindManyArgs>(args?: SelectSubset<T, CareerOutcomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerOutcomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CareerOutcome.
     * @param {CareerOutcomeCreateArgs} args - Arguments to create a CareerOutcome.
     * @example
     * // Create one CareerOutcome
     * const CareerOutcome = await prisma.careerOutcome.create({
     *   data: {
     *     // ... data to create a CareerOutcome
     *   }
     * })
     * 
     */
    create<T extends CareerOutcomeCreateArgs>(args: SelectSubset<T, CareerOutcomeCreateArgs<ExtArgs>>): Prisma__CareerOutcomeClient<$Result.GetResult<Prisma.$CareerOutcomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CareerOutcomes.
     * @param {CareerOutcomeCreateManyArgs} args - Arguments to create many CareerOutcomes.
     * @example
     * // Create many CareerOutcomes
     * const careerOutcome = await prisma.careerOutcome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CareerOutcomeCreateManyArgs>(args?: SelectSubset<T, CareerOutcomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CareerOutcomes and returns the data saved in the database.
     * @param {CareerOutcomeCreateManyAndReturnArgs} args - Arguments to create many CareerOutcomes.
     * @example
     * // Create many CareerOutcomes
     * const careerOutcome = await prisma.careerOutcome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CareerOutcomes and only return the `id`
     * const careerOutcomeWithIdOnly = await prisma.careerOutcome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CareerOutcomeCreateManyAndReturnArgs>(args?: SelectSubset<T, CareerOutcomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerOutcomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CareerOutcome.
     * @param {CareerOutcomeDeleteArgs} args - Arguments to delete one CareerOutcome.
     * @example
     * // Delete one CareerOutcome
     * const CareerOutcome = await prisma.careerOutcome.delete({
     *   where: {
     *     // ... filter to delete one CareerOutcome
     *   }
     * })
     * 
     */
    delete<T extends CareerOutcomeDeleteArgs>(args: SelectSubset<T, CareerOutcomeDeleteArgs<ExtArgs>>): Prisma__CareerOutcomeClient<$Result.GetResult<Prisma.$CareerOutcomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CareerOutcome.
     * @param {CareerOutcomeUpdateArgs} args - Arguments to update one CareerOutcome.
     * @example
     * // Update one CareerOutcome
     * const careerOutcome = await prisma.careerOutcome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CareerOutcomeUpdateArgs>(args: SelectSubset<T, CareerOutcomeUpdateArgs<ExtArgs>>): Prisma__CareerOutcomeClient<$Result.GetResult<Prisma.$CareerOutcomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CareerOutcomes.
     * @param {CareerOutcomeDeleteManyArgs} args - Arguments to filter CareerOutcomes to delete.
     * @example
     * // Delete a few CareerOutcomes
     * const { count } = await prisma.careerOutcome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CareerOutcomeDeleteManyArgs>(args?: SelectSubset<T, CareerOutcomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CareerOutcomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerOutcomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CareerOutcomes
     * const careerOutcome = await prisma.careerOutcome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CareerOutcomeUpdateManyArgs>(args: SelectSubset<T, CareerOutcomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CareerOutcomes and returns the data updated in the database.
     * @param {CareerOutcomeUpdateManyAndReturnArgs} args - Arguments to update many CareerOutcomes.
     * @example
     * // Update many CareerOutcomes
     * const careerOutcome = await prisma.careerOutcome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CareerOutcomes and only return the `id`
     * const careerOutcomeWithIdOnly = await prisma.careerOutcome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CareerOutcomeUpdateManyAndReturnArgs>(args: SelectSubset<T, CareerOutcomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerOutcomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CareerOutcome.
     * @param {CareerOutcomeUpsertArgs} args - Arguments to update or create a CareerOutcome.
     * @example
     * // Update or create a CareerOutcome
     * const careerOutcome = await prisma.careerOutcome.upsert({
     *   create: {
     *     // ... data to create a CareerOutcome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CareerOutcome we want to update
     *   }
     * })
     */
    upsert<T extends CareerOutcomeUpsertArgs>(args: SelectSubset<T, CareerOutcomeUpsertArgs<ExtArgs>>): Prisma__CareerOutcomeClient<$Result.GetResult<Prisma.$CareerOutcomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CareerOutcomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerOutcomeCountArgs} args - Arguments to filter CareerOutcomes to count.
     * @example
     * // Count the number of CareerOutcomes
     * const count = await prisma.careerOutcome.count({
     *   where: {
     *     // ... the filter for the CareerOutcomes we want to count
     *   }
     * })
    **/
    count<T extends CareerOutcomeCountArgs>(
      args?: Subset<T, CareerOutcomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareerOutcomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CareerOutcome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerOutcomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareerOutcomeAggregateArgs>(args: Subset<T, CareerOutcomeAggregateArgs>): Prisma.PrismaPromise<GetCareerOutcomeAggregateType<T>>

    /**
     * Group by CareerOutcome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerOutcomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CareerOutcomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CareerOutcomeGroupByArgs['orderBy'] }
        : { orderBy?: CareerOutcomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CareerOutcomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareerOutcomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CareerOutcome model
   */
  readonly fields: CareerOutcomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CareerOutcome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CareerOutcomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    university<T extends UniversityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniversityDefaultArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CareerOutcome model
   */
  interface CareerOutcomeFieldRefs {
    readonly id: FieldRef<"CareerOutcome", 'String'>
    readonly iconName: FieldRef<"CareerOutcome", 'String'>
    readonly iconImage: FieldRef<"CareerOutcome", 'String'>
    readonly title: FieldRef<"CareerOutcome", 'String'>
    readonly value: FieldRef<"CareerOutcome", 'String'>
    readonly description: FieldRef<"CareerOutcome", 'String'>
    readonly details: FieldRef<"CareerOutcome", 'String'>
    readonly color: FieldRef<"CareerOutcome", 'String'>
    readonly bgColor: FieldRef<"CareerOutcome", 'String'>
    readonly universityId: FieldRef<"CareerOutcome", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CareerOutcome findUnique
   */
  export type CareerOutcomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which CareerOutcome to fetch.
     */
    where: CareerOutcomeWhereUniqueInput
  }

  /**
   * CareerOutcome findUniqueOrThrow
   */
  export type CareerOutcomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which CareerOutcome to fetch.
     */
    where: CareerOutcomeWhereUniqueInput
  }

  /**
   * CareerOutcome findFirst
   */
  export type CareerOutcomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which CareerOutcome to fetch.
     */
    where?: CareerOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerOutcomes to fetch.
     */
    orderBy?: CareerOutcomeOrderByWithRelationInput | CareerOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CareerOutcomes.
     */
    cursor?: CareerOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CareerOutcomes.
     */
    distinct?: CareerOutcomeScalarFieldEnum | CareerOutcomeScalarFieldEnum[]
  }

  /**
   * CareerOutcome findFirstOrThrow
   */
  export type CareerOutcomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which CareerOutcome to fetch.
     */
    where?: CareerOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerOutcomes to fetch.
     */
    orderBy?: CareerOutcomeOrderByWithRelationInput | CareerOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CareerOutcomes.
     */
    cursor?: CareerOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CareerOutcomes.
     */
    distinct?: CareerOutcomeScalarFieldEnum | CareerOutcomeScalarFieldEnum[]
  }

  /**
   * CareerOutcome findMany
   */
  export type CareerOutcomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which CareerOutcomes to fetch.
     */
    where?: CareerOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerOutcomes to fetch.
     */
    orderBy?: CareerOutcomeOrderByWithRelationInput | CareerOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CareerOutcomes.
     */
    cursor?: CareerOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerOutcomes.
     */
    skip?: number
    distinct?: CareerOutcomeScalarFieldEnum | CareerOutcomeScalarFieldEnum[]
  }

  /**
   * CareerOutcome create
   */
  export type CareerOutcomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeInclude<ExtArgs> | null
    /**
     * The data needed to create a CareerOutcome.
     */
    data: XOR<CareerOutcomeCreateInput, CareerOutcomeUncheckedCreateInput>
  }

  /**
   * CareerOutcome createMany
   */
  export type CareerOutcomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CareerOutcomes.
     */
    data: CareerOutcomeCreateManyInput | CareerOutcomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CareerOutcome createManyAndReturn
   */
  export type CareerOutcomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * The data used to create many CareerOutcomes.
     */
    data: CareerOutcomeCreateManyInput | CareerOutcomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CareerOutcome update
   */
  export type CareerOutcomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeInclude<ExtArgs> | null
    /**
     * The data needed to update a CareerOutcome.
     */
    data: XOR<CareerOutcomeUpdateInput, CareerOutcomeUncheckedUpdateInput>
    /**
     * Choose, which CareerOutcome to update.
     */
    where: CareerOutcomeWhereUniqueInput
  }

  /**
   * CareerOutcome updateMany
   */
  export type CareerOutcomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CareerOutcomes.
     */
    data: XOR<CareerOutcomeUpdateManyMutationInput, CareerOutcomeUncheckedUpdateManyInput>
    /**
     * Filter which CareerOutcomes to update
     */
    where?: CareerOutcomeWhereInput
    /**
     * Limit how many CareerOutcomes to update.
     */
    limit?: number
  }

  /**
   * CareerOutcome updateManyAndReturn
   */
  export type CareerOutcomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * The data used to update CareerOutcomes.
     */
    data: XOR<CareerOutcomeUpdateManyMutationInput, CareerOutcomeUncheckedUpdateManyInput>
    /**
     * Filter which CareerOutcomes to update
     */
    where?: CareerOutcomeWhereInput
    /**
     * Limit how many CareerOutcomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CareerOutcome upsert
   */
  export type CareerOutcomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeInclude<ExtArgs> | null
    /**
     * The filter to search for the CareerOutcome to update in case it exists.
     */
    where: CareerOutcomeWhereUniqueInput
    /**
     * In case the CareerOutcome found by the `where` argument doesn't exist, create a new CareerOutcome with this data.
     */
    create: XOR<CareerOutcomeCreateInput, CareerOutcomeUncheckedCreateInput>
    /**
     * In case the CareerOutcome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CareerOutcomeUpdateInput, CareerOutcomeUncheckedUpdateInput>
  }

  /**
   * CareerOutcome delete
   */
  export type CareerOutcomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeInclude<ExtArgs> | null
    /**
     * Filter which CareerOutcome to delete.
     */
    where: CareerOutcomeWhereUniqueInput
  }

  /**
   * CareerOutcome deleteMany
   */
  export type CareerOutcomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CareerOutcomes to delete
     */
    where?: CareerOutcomeWhereInput
    /**
     * Limit how many CareerOutcomes to delete.
     */
    limit?: number
  }

  /**
   * CareerOutcome without action
   */
  export type CareerOutcomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeInclude<ExtArgs> | null
  }


  /**
   * Model Faq
   */

  export type AggregateFaq = {
    _count: FaqCountAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  export type FaqMinAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    universityId: string | null
  }

  export type FaqMaxAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    universityId: string | null
  }

  export type FaqCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    universityId: number
    _all: number
  }


  export type FaqMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    universityId?: true
  }

  export type FaqMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    universityId?: true
  }

  export type FaqCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    universityId?: true
    _all?: true
  }

  export type FaqAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faq to aggregate.
     */
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     */
    orderBy?: FaqOrderByWithRelationInput | FaqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faqs
    **/
    _count?: true | FaqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaqMaxAggregateInputType
  }

  export type GetFaqAggregateType<T extends FaqAggregateArgs> = {
        [P in keyof T & keyof AggregateFaq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaq[P]>
      : GetScalarType<T[P], AggregateFaq[P]>
  }




  export type FaqGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FaqWhereInput
    orderBy?: FaqOrderByWithAggregationInput | FaqOrderByWithAggregationInput[]
    by: FaqScalarFieldEnum[] | FaqScalarFieldEnum
    having?: FaqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaqCountAggregateInputType | true
    _min?: FaqMinAggregateInputType
    _max?: FaqMaxAggregateInputType
  }

  export type FaqGroupByOutputType = {
    id: string
    question: string
    answer: string
    universityId: string
    _count: FaqCountAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  type GetFaqGroupByPayload<T extends FaqGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FaqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaqGroupByOutputType[P]>
            : GetScalarType<T[P], FaqGroupByOutputType[P]>
        }
      >
    >


  export type FaqSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    universityId?: boolean
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faq"]>

  export type FaqSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    universityId?: boolean
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faq"]>

  export type FaqSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    universityId?: boolean
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faq"]>

  export type FaqSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    universityId?: boolean
  }

  export type FaqOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer" | "universityId", ExtArgs["result"]["faq"]>
  export type FaqInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }
  export type FaqIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }
  export type FaqIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }

  export type $FaqPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Faq"
    objects: {
      university: Prisma.$UniversityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      answer: string
      universityId: string
    }, ExtArgs["result"]["faq"]>
    composites: {}
  }

  type FaqGetPayload<S extends boolean | null | undefined | FaqDefaultArgs> = $Result.GetResult<Prisma.$FaqPayload, S>

  type FaqCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FaqFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FaqCountAggregateInputType | true
    }

  export interface FaqDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Faq'], meta: { name: 'Faq' } }
    /**
     * Find zero or one Faq that matches the filter.
     * @param {FaqFindUniqueArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FaqFindUniqueArgs>(args: SelectSubset<T, FaqFindUniqueArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faq that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FaqFindUniqueOrThrowArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FaqFindUniqueOrThrowArgs>(args: SelectSubset<T, FaqFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindFirstArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FaqFindFirstArgs>(args?: SelectSubset<T, FaqFindFirstArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faq that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindFirstOrThrowArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FaqFindFirstOrThrowArgs>(args?: SelectSubset<T, FaqFindFirstOrThrowArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faqs
     * const faqs = await prisma.faq.findMany()
     * 
     * // Get first 10 Faqs
     * const faqs = await prisma.faq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const faqWithIdOnly = await prisma.faq.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FaqFindManyArgs>(args?: SelectSubset<T, FaqFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faq.
     * @param {FaqCreateArgs} args - Arguments to create a Faq.
     * @example
     * // Create one Faq
     * const Faq = await prisma.faq.create({
     *   data: {
     *     // ... data to create a Faq
     *   }
     * })
     * 
     */
    create<T extends FaqCreateArgs>(args: SelectSubset<T, FaqCreateArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faqs.
     * @param {FaqCreateManyArgs} args - Arguments to create many Faqs.
     * @example
     * // Create many Faqs
     * const faq = await prisma.faq.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FaqCreateManyArgs>(args?: SelectSubset<T, FaqCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Faqs and returns the data saved in the database.
     * @param {FaqCreateManyAndReturnArgs} args - Arguments to create many Faqs.
     * @example
     * // Create many Faqs
     * const faq = await prisma.faq.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Faqs and only return the `id`
     * const faqWithIdOnly = await prisma.faq.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FaqCreateManyAndReturnArgs>(args?: SelectSubset<T, FaqCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Faq.
     * @param {FaqDeleteArgs} args - Arguments to delete one Faq.
     * @example
     * // Delete one Faq
     * const Faq = await prisma.faq.delete({
     *   where: {
     *     // ... filter to delete one Faq
     *   }
     * })
     * 
     */
    delete<T extends FaqDeleteArgs>(args: SelectSubset<T, FaqDeleteArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faq.
     * @param {FaqUpdateArgs} args - Arguments to update one Faq.
     * @example
     * // Update one Faq
     * const faq = await prisma.faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FaqUpdateArgs>(args: SelectSubset<T, FaqUpdateArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faqs.
     * @param {FaqDeleteManyArgs} args - Arguments to filter Faqs to delete.
     * @example
     * // Delete a few Faqs
     * const { count } = await prisma.faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FaqDeleteManyArgs>(args?: SelectSubset<T, FaqDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faqs
     * const faq = await prisma.faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FaqUpdateManyArgs>(args: SelectSubset<T, FaqUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs and returns the data updated in the database.
     * @param {FaqUpdateManyAndReturnArgs} args - Arguments to update many Faqs.
     * @example
     * // Update many Faqs
     * const faq = await prisma.faq.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Faqs and only return the `id`
     * const faqWithIdOnly = await prisma.faq.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FaqUpdateManyAndReturnArgs>(args: SelectSubset<T, FaqUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Faq.
     * @param {FaqUpsertArgs} args - Arguments to update or create a Faq.
     * @example
     * // Update or create a Faq
     * const faq = await prisma.faq.upsert({
     *   create: {
     *     // ... data to create a Faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faq we want to update
     *   }
     * })
     */
    upsert<T extends FaqUpsertArgs>(args: SelectSubset<T, FaqUpsertArgs<ExtArgs>>): Prisma__FaqClient<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqCountArgs} args - Arguments to filter Faqs to count.
     * @example
     * // Count the number of Faqs
     * const count = await prisma.faq.count({
     *   where: {
     *     // ... the filter for the Faqs we want to count
     *   }
     * })
    **/
    count<T extends FaqCountArgs>(
      args?: Subset<T, FaqCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaqAggregateArgs>(args: Subset<T, FaqAggregateArgs>): Prisma.PrismaPromise<GetFaqAggregateType<T>>

    /**
     * Group by Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FaqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FaqGroupByArgs['orderBy'] }
        : { orderBy?: FaqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FaqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaqGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Faq model
   */
  readonly fields: FaqFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FaqClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    university<T extends UniversityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniversityDefaultArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Faq model
   */
  interface FaqFieldRefs {
    readonly id: FieldRef<"Faq", 'String'>
    readonly question: FieldRef<"Faq", 'String'>
    readonly answer: FieldRef<"Faq", 'String'>
    readonly universityId: FieldRef<"Faq", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Faq findUnique
   */
  export type FaqFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * Filter, which Faq to fetch.
     */
    where: FaqWhereUniqueInput
  }

  /**
   * Faq findUniqueOrThrow
   */
  export type FaqFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * Filter, which Faq to fetch.
     */
    where: FaqWhereUniqueInput
  }

  /**
   * Faq findFirst
   */
  export type FaqFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * Filter, which Faq to fetch.
     */
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     */
    orderBy?: FaqOrderByWithRelationInput | FaqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faqs.
     */
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faqs.
     */
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * Faq findFirstOrThrow
   */
  export type FaqFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * Filter, which Faq to fetch.
     */
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     */
    orderBy?: FaqOrderByWithRelationInput | FaqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faqs.
     */
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faqs.
     */
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * Faq findMany
   */
  export type FaqFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * Filter, which Faqs to fetch.
     */
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     */
    orderBy?: FaqOrderByWithRelationInput | FaqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faqs.
     */
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     */
    skip?: number
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * Faq create
   */
  export type FaqCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * The data needed to create a Faq.
     */
    data: XOR<FaqCreateInput, FaqUncheckedCreateInput>
  }

  /**
   * Faq createMany
   */
  export type FaqCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Faqs.
     */
    data: FaqCreateManyInput | FaqCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Faq createManyAndReturn
   */
  export type FaqCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * The data used to create many Faqs.
     */
    data: FaqCreateManyInput | FaqCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Faq update
   */
  export type FaqUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * The data needed to update a Faq.
     */
    data: XOR<FaqUpdateInput, FaqUncheckedUpdateInput>
    /**
     * Choose, which Faq to update.
     */
    where: FaqWhereUniqueInput
  }

  /**
   * Faq updateMany
   */
  export type FaqUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Faqs.
     */
    data: XOR<FaqUpdateManyMutationInput, FaqUncheckedUpdateManyInput>
    /**
     * Filter which Faqs to update
     */
    where?: FaqWhereInput
    /**
     * Limit how many Faqs to update.
     */
    limit?: number
  }

  /**
   * Faq updateManyAndReturn
   */
  export type FaqUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * The data used to update Faqs.
     */
    data: XOR<FaqUpdateManyMutationInput, FaqUncheckedUpdateManyInput>
    /**
     * Filter which Faqs to update
     */
    where?: FaqWhereInput
    /**
     * Limit how many Faqs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Faq upsert
   */
  export type FaqUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * The filter to search for the Faq to update in case it exists.
     */
    where: FaqWhereUniqueInput
    /**
     * In case the Faq found by the `where` argument doesn't exist, create a new Faq with this data.
     */
    create: XOR<FaqCreateInput, FaqUncheckedCreateInput>
    /**
     * In case the Faq was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FaqUpdateInput, FaqUncheckedUpdateInput>
  }

  /**
   * Faq delete
   */
  export type FaqDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    /**
     * Filter which Faq to delete.
     */
    where: FaqWhereUniqueInput
  }

  /**
   * Faq deleteMany
   */
  export type FaqDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faqs to delete
     */
    where?: FaqWhereInput
    /**
     * Limit how many Faqs to delete.
     */
    limit?: number
  }

  /**
   * Faq without action
   */
  export type FaqDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
  }


  /**
   * Model University
   */

  export type AggregateUniversity = {
    _count: UniversityCountAggregateOutputType | null
    _min: UniversityMinAggregateOutputType | null
    _max: UniversityMaxAggregateOutputType | null
  }

  export type UniversityMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    location: string | null
    country: string | null
    website: string | null
    established: Date | null
    banner: string | null
    logoUrl: string | null
    youtubeLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UniversityMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    location: string | null
    country: string | null
    website: string | null
    established: Date | null
    banner: string | null
    logoUrl: string | null
    youtubeLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UniversityCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    description: number
    location: number
    country: number
    website: number
    established: number
    banner: number
    logoUrl: number
    youtubeLink: number
    imageUrls: number
    facilities: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UniversityMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    location?: true
    country?: true
    website?: true
    established?: true
    banner?: true
    logoUrl?: true
    youtubeLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UniversityMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    location?: true
    country?: true
    website?: true
    established?: true
    banner?: true
    logoUrl?: true
    youtubeLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UniversityCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    location?: true
    country?: true
    website?: true
    established?: true
    banner?: true
    logoUrl?: true
    youtubeLink?: true
    imageUrls?: true
    facilities?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UniversityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which University to aggregate.
     */
    where?: UniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Universities to fetch.
     */
    orderBy?: UniversityOrderByWithRelationInput | UniversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Universities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Universities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Universities
    **/
    _count?: true | UniversityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UniversityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UniversityMaxAggregateInputType
  }

  export type GetUniversityAggregateType<T extends UniversityAggregateArgs> = {
        [P in keyof T & keyof AggregateUniversity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniversity[P]>
      : GetScalarType<T[P], AggregateUniversity[P]>
  }




  export type UniversityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UniversityWhereInput
    orderBy?: UniversityOrderByWithAggregationInput | UniversityOrderByWithAggregationInput[]
    by: UniversityScalarFieldEnum[] | UniversityScalarFieldEnum
    having?: UniversityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UniversityCountAggregateInputType | true
    _min?: UniversityMinAggregateInputType
    _max?: UniversityMaxAggregateInputType
  }

  export type UniversityGroupByOutputType = {
    id: string
    slug: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date
    banner: string
    logoUrl: string | null
    youtubeLink: string | null
    imageUrls: string[]
    facilities: string[]
    createdAt: Date
    updatedAt: Date
    _count: UniversityCountAggregateOutputType | null
    _min: UniversityMinAggregateOutputType | null
    _max: UniversityMaxAggregateOutputType | null
  }

  type GetUniversityGroupByPayload<T extends UniversityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UniversityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UniversityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UniversityGroupByOutputType[P]>
            : GetScalarType<T[P], UniversityGroupByOutputType[P]>
        }
      >
    >


  export type UniversitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    country?: boolean
    website?: boolean
    established?: boolean
    banner?: boolean
    logoUrl?: boolean
    youtubeLink?: boolean
    imageUrls?: boolean
    facilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    careerOutcomes?: boolean | University$careerOutcomesArgs<ExtArgs>
    faqs?: boolean | University$faqsArgs<ExtArgs>
    applications?: boolean | University$applicationsArgs<ExtArgs>
    loans?: boolean | University$loansArgs<ExtArgs>
    users?: boolean | University$usersArgs<ExtArgs>
    courses?: boolean | University$coursesArgs<ExtArgs>
    _count?: boolean | UniversityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["university"]>

  export type UniversitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    country?: boolean
    website?: boolean
    established?: boolean
    banner?: boolean
    logoUrl?: boolean
    youtubeLink?: boolean
    imageUrls?: boolean
    facilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["university"]>

  export type UniversitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    country?: boolean
    website?: boolean
    established?: boolean
    banner?: boolean
    logoUrl?: boolean
    youtubeLink?: boolean
    imageUrls?: boolean
    facilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["university"]>

  export type UniversitySelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    country?: boolean
    website?: boolean
    established?: boolean
    banner?: boolean
    logoUrl?: boolean
    youtubeLink?: boolean
    imageUrls?: boolean
    facilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UniversityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "description" | "location" | "country" | "website" | "established" | "banner" | "logoUrl" | "youtubeLink" | "imageUrls" | "facilities" | "createdAt" | "updatedAt", ExtArgs["result"]["university"]>
  export type UniversityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerOutcomes?: boolean | University$careerOutcomesArgs<ExtArgs>
    faqs?: boolean | University$faqsArgs<ExtArgs>
    applications?: boolean | University$applicationsArgs<ExtArgs>
    loans?: boolean | University$loansArgs<ExtArgs>
    users?: boolean | University$usersArgs<ExtArgs>
    courses?: boolean | University$coursesArgs<ExtArgs>
    _count?: boolean | UniversityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UniversityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UniversityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UniversityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "University"
    objects: {
      careerOutcomes: Prisma.$CareerOutcomePayload<ExtArgs>[]
      faqs: Prisma.$FaqPayload<ExtArgs>[]
      applications: Prisma.$UniversityApplicationsPayload<ExtArgs>[]
      loans: Prisma.$LoanPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      courses: Prisma.$CoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string | null
      name: string
      description: string
      location: string
      country: string
      website: string
      established: Date
      banner: string
      logoUrl: string | null
      youtubeLink: string | null
      imageUrls: string[]
      facilities: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["university"]>
    composites: {}
  }

  type UniversityGetPayload<S extends boolean | null | undefined | UniversityDefaultArgs> = $Result.GetResult<Prisma.$UniversityPayload, S>

  type UniversityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UniversityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UniversityCountAggregateInputType | true
    }

  export interface UniversityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['University'], meta: { name: 'University' } }
    /**
     * Find zero or one University that matches the filter.
     * @param {UniversityFindUniqueArgs} args - Arguments to find a University
     * @example
     * // Get one University
     * const university = await prisma.university.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UniversityFindUniqueArgs>(args: SelectSubset<T, UniversityFindUniqueArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one University that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UniversityFindUniqueOrThrowArgs} args - Arguments to find a University
     * @example
     * // Get one University
     * const university = await prisma.university.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UniversityFindUniqueOrThrowArgs>(args: SelectSubset<T, UniversityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first University that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityFindFirstArgs} args - Arguments to find a University
     * @example
     * // Get one University
     * const university = await prisma.university.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UniversityFindFirstArgs>(args?: SelectSubset<T, UniversityFindFirstArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first University that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityFindFirstOrThrowArgs} args - Arguments to find a University
     * @example
     * // Get one University
     * const university = await prisma.university.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UniversityFindFirstOrThrowArgs>(args?: SelectSubset<T, UniversityFindFirstOrThrowArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Universities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Universities
     * const universities = await prisma.university.findMany()
     * 
     * // Get first 10 Universities
     * const universities = await prisma.university.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const universityWithIdOnly = await prisma.university.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UniversityFindManyArgs>(args?: SelectSubset<T, UniversityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a University.
     * @param {UniversityCreateArgs} args - Arguments to create a University.
     * @example
     * // Create one University
     * const University = await prisma.university.create({
     *   data: {
     *     // ... data to create a University
     *   }
     * })
     * 
     */
    create<T extends UniversityCreateArgs>(args: SelectSubset<T, UniversityCreateArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Universities.
     * @param {UniversityCreateManyArgs} args - Arguments to create many Universities.
     * @example
     * // Create many Universities
     * const university = await prisma.university.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UniversityCreateManyArgs>(args?: SelectSubset<T, UniversityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Universities and returns the data saved in the database.
     * @param {UniversityCreateManyAndReturnArgs} args - Arguments to create many Universities.
     * @example
     * // Create many Universities
     * const university = await prisma.university.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Universities and only return the `id`
     * const universityWithIdOnly = await prisma.university.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UniversityCreateManyAndReturnArgs>(args?: SelectSubset<T, UniversityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a University.
     * @param {UniversityDeleteArgs} args - Arguments to delete one University.
     * @example
     * // Delete one University
     * const University = await prisma.university.delete({
     *   where: {
     *     // ... filter to delete one University
     *   }
     * })
     * 
     */
    delete<T extends UniversityDeleteArgs>(args: SelectSubset<T, UniversityDeleteArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one University.
     * @param {UniversityUpdateArgs} args - Arguments to update one University.
     * @example
     * // Update one University
     * const university = await prisma.university.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UniversityUpdateArgs>(args: SelectSubset<T, UniversityUpdateArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Universities.
     * @param {UniversityDeleteManyArgs} args - Arguments to filter Universities to delete.
     * @example
     * // Delete a few Universities
     * const { count } = await prisma.university.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UniversityDeleteManyArgs>(args?: SelectSubset<T, UniversityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Universities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Universities
     * const university = await prisma.university.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UniversityUpdateManyArgs>(args: SelectSubset<T, UniversityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Universities and returns the data updated in the database.
     * @param {UniversityUpdateManyAndReturnArgs} args - Arguments to update many Universities.
     * @example
     * // Update many Universities
     * const university = await prisma.university.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Universities and only return the `id`
     * const universityWithIdOnly = await prisma.university.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UniversityUpdateManyAndReturnArgs>(args: SelectSubset<T, UniversityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one University.
     * @param {UniversityUpsertArgs} args - Arguments to update or create a University.
     * @example
     * // Update or create a University
     * const university = await prisma.university.upsert({
     *   create: {
     *     // ... data to create a University
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the University we want to update
     *   }
     * })
     */
    upsert<T extends UniversityUpsertArgs>(args: SelectSubset<T, UniversityUpsertArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Universities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityCountArgs} args - Arguments to filter Universities to count.
     * @example
     * // Count the number of Universities
     * const count = await prisma.university.count({
     *   where: {
     *     // ... the filter for the Universities we want to count
     *   }
     * })
    **/
    count<T extends UniversityCountArgs>(
      args?: Subset<T, UniversityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UniversityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a University.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UniversityAggregateArgs>(args: Subset<T, UniversityAggregateArgs>): Prisma.PrismaPromise<GetUniversityAggregateType<T>>

    /**
     * Group by University.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UniversityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UniversityGroupByArgs['orderBy'] }
        : { orderBy?: UniversityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UniversityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniversityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the University model
   */
  readonly fields: UniversityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for University.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UniversityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    careerOutcomes<T extends University$careerOutcomesArgs<ExtArgs> = {}>(args?: Subset<T, University$careerOutcomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerOutcomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    faqs<T extends University$faqsArgs<ExtArgs> = {}>(args?: Subset<T, University$faqsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FaqPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applications<T extends University$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, University$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    loans<T extends University$loansArgs<ExtArgs> = {}>(args?: Subset<T, University$loansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends University$usersArgs<ExtArgs> = {}>(args?: Subset<T, University$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courses<T extends University$coursesArgs<ExtArgs> = {}>(args?: Subset<T, University$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the University model
   */
  interface UniversityFieldRefs {
    readonly id: FieldRef<"University", 'String'>
    readonly slug: FieldRef<"University", 'String'>
    readonly name: FieldRef<"University", 'String'>
    readonly description: FieldRef<"University", 'String'>
    readonly location: FieldRef<"University", 'String'>
    readonly country: FieldRef<"University", 'String'>
    readonly website: FieldRef<"University", 'String'>
    readonly established: FieldRef<"University", 'DateTime'>
    readonly banner: FieldRef<"University", 'String'>
    readonly logoUrl: FieldRef<"University", 'String'>
    readonly youtubeLink: FieldRef<"University", 'String'>
    readonly imageUrls: FieldRef<"University", 'String[]'>
    readonly facilities: FieldRef<"University", 'String[]'>
    readonly createdAt: FieldRef<"University", 'DateTime'>
    readonly updatedAt: FieldRef<"University", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * University findUnique
   */
  export type UniversityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInclude<ExtArgs> | null
    /**
     * Filter, which University to fetch.
     */
    where: UniversityWhereUniqueInput
  }

  /**
   * University findUniqueOrThrow
   */
  export type UniversityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInclude<ExtArgs> | null
    /**
     * Filter, which University to fetch.
     */
    where: UniversityWhereUniqueInput
  }

  /**
   * University findFirst
   */
  export type UniversityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInclude<ExtArgs> | null
    /**
     * Filter, which University to fetch.
     */
    where?: UniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Universities to fetch.
     */
    orderBy?: UniversityOrderByWithRelationInput | UniversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Universities.
     */
    cursor?: UniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Universities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Universities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Universities.
     */
    distinct?: UniversityScalarFieldEnum | UniversityScalarFieldEnum[]
  }

  /**
   * University findFirstOrThrow
   */
  export type UniversityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInclude<ExtArgs> | null
    /**
     * Filter, which University to fetch.
     */
    where?: UniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Universities to fetch.
     */
    orderBy?: UniversityOrderByWithRelationInput | UniversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Universities.
     */
    cursor?: UniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Universities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Universities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Universities.
     */
    distinct?: UniversityScalarFieldEnum | UniversityScalarFieldEnum[]
  }

  /**
   * University findMany
   */
  export type UniversityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInclude<ExtArgs> | null
    /**
     * Filter, which Universities to fetch.
     */
    where?: UniversityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Universities to fetch.
     */
    orderBy?: UniversityOrderByWithRelationInput | UniversityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Universities.
     */
    cursor?: UniversityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Universities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Universities.
     */
    skip?: number
    distinct?: UniversityScalarFieldEnum | UniversityScalarFieldEnum[]
  }

  /**
   * University create
   */
  export type UniversityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInclude<ExtArgs> | null
    /**
     * The data needed to create a University.
     */
    data: XOR<UniversityCreateInput, UniversityUncheckedCreateInput>
  }

  /**
   * University createMany
   */
  export type UniversityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Universities.
     */
    data: UniversityCreateManyInput | UniversityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * University createManyAndReturn
   */
  export type UniversityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * The data used to create many Universities.
     */
    data: UniversityCreateManyInput | UniversityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * University update
   */
  export type UniversityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInclude<ExtArgs> | null
    /**
     * The data needed to update a University.
     */
    data: XOR<UniversityUpdateInput, UniversityUncheckedUpdateInput>
    /**
     * Choose, which University to update.
     */
    where: UniversityWhereUniqueInput
  }

  /**
   * University updateMany
   */
  export type UniversityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Universities.
     */
    data: XOR<UniversityUpdateManyMutationInput, UniversityUncheckedUpdateManyInput>
    /**
     * Filter which Universities to update
     */
    where?: UniversityWhereInput
    /**
     * Limit how many Universities to update.
     */
    limit?: number
  }

  /**
   * University updateManyAndReturn
   */
  export type UniversityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * The data used to update Universities.
     */
    data: XOR<UniversityUpdateManyMutationInput, UniversityUncheckedUpdateManyInput>
    /**
     * Filter which Universities to update
     */
    where?: UniversityWhereInput
    /**
     * Limit how many Universities to update.
     */
    limit?: number
  }

  /**
   * University upsert
   */
  export type UniversityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInclude<ExtArgs> | null
    /**
     * The filter to search for the University to update in case it exists.
     */
    where: UniversityWhereUniqueInput
    /**
     * In case the University found by the `where` argument doesn't exist, create a new University with this data.
     */
    create: XOR<UniversityCreateInput, UniversityUncheckedCreateInput>
    /**
     * In case the University was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UniversityUpdateInput, UniversityUncheckedUpdateInput>
  }

  /**
   * University delete
   */
  export type UniversityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInclude<ExtArgs> | null
    /**
     * Filter which University to delete.
     */
    where: UniversityWhereUniqueInput
  }

  /**
   * University deleteMany
   */
  export type UniversityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Universities to delete
     */
    where?: UniversityWhereInput
    /**
     * Limit how many Universities to delete.
     */
    limit?: number
  }

  /**
   * University.careerOutcomes
   */
  export type University$careerOutcomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerOutcome
     */
    select?: CareerOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerOutcome
     */
    omit?: CareerOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerOutcomeInclude<ExtArgs> | null
    where?: CareerOutcomeWhereInput
    orderBy?: CareerOutcomeOrderByWithRelationInput | CareerOutcomeOrderByWithRelationInput[]
    cursor?: CareerOutcomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CareerOutcomeScalarFieldEnum | CareerOutcomeScalarFieldEnum[]
  }

  /**
   * University.faqs
   */
  export type University$faqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faq
     */
    select?: FaqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faq
     */
    omit?: FaqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaqInclude<ExtArgs> | null
    where?: FaqWhereInput
    orderBy?: FaqOrderByWithRelationInput | FaqOrderByWithRelationInput[]
    cursor?: FaqWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FaqScalarFieldEnum | FaqScalarFieldEnum[]
  }

  /**
   * University.applications
   */
  export type University$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
    where?: UniversityApplicationsWhereInput
    orderBy?: UniversityApplicationsOrderByWithRelationInput | UniversityApplicationsOrderByWithRelationInput[]
    cursor?: UniversityApplicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UniversityApplicationsScalarFieldEnum | UniversityApplicationsScalarFieldEnum[]
  }

  /**
   * University.loans
   */
  export type University$loansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    where?: LoanWhereInput
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    cursor?: LoanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoanScalarFieldEnum | LoanScalarFieldEnum[]
  }

  /**
   * University.users
   */
  export type University$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * University.courses
   */
  export type University$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * University without action
   */
  export type UniversityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    fees: string | null
    duration: string | null
    degreeType: string | null
    ieltsScore: string | null
    ranking: string | null
    websiteLink: string | null
    universityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    fees: string | null
    duration: string | null
    degreeType: string | null
    ieltsScore: string | null
    ranking: string | null
    websiteLink: string | null
    universityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    name: number
    description: number
    image: number
    fees: number
    duration: number
    degreeType: number
    ieltsScore: number
    ranking: number
    intake: number
    websiteLink: number
    universityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    fees?: true
    duration?: true
    degreeType?: true
    ieltsScore?: true
    ranking?: true
    websiteLink?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    fees?: true
    duration?: true
    degreeType?: true
    ieltsScore?: true
    ranking?: true
    websiteLink?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    fees?: true
    duration?: true
    degreeType?: true
    ieltsScore?: true
    ranking?: true
    intake?: true
    websiteLink?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    name: string
    description: string | null
    image: string | null
    fees: string | null
    duration: string | null
    degreeType: string | null
    ieltsScore: string | null
    ranking: string | null
    intake: string[]
    websiteLink: string | null
    universityId: string
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    fees?: boolean
    duration?: boolean
    degreeType?: boolean
    ieltsScore?: boolean
    ranking?: boolean
    intake?: boolean
    websiteLink?: boolean
    universityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applications?: boolean | Course$applicationsArgs<ExtArgs>
    favByUsers?: boolean | Course$favByUsersArgs<ExtArgs>
    university?: boolean | UniversityDefaultArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    fees?: boolean
    duration?: boolean
    degreeType?: boolean
    ieltsScore?: boolean
    ranking?: boolean
    intake?: boolean
    websiteLink?: boolean
    universityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    fees?: boolean
    duration?: boolean
    degreeType?: boolean
    ieltsScore?: boolean
    ranking?: boolean
    intake?: boolean
    websiteLink?: boolean
    universityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    fees?: boolean
    duration?: boolean
    degreeType?: boolean
    ieltsScore?: boolean
    ranking?: boolean
    intake?: boolean
    websiteLink?: boolean
    universityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "image" | "fees" | "duration" | "degreeType" | "ieltsScore" | "ranking" | "intake" | "websiteLink" | "universityId" | "createdAt" | "updatedAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | Course$applicationsArgs<ExtArgs>
    favByUsers?: boolean | Course$favByUsersArgs<ExtArgs>
    university?: boolean | UniversityDefaultArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | UniversityDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      applications: Prisma.$UniversityApplicationsPayload<ExtArgs>[]
      favByUsers: Prisma.$FavCoursePayload<ExtArgs>[]
      university: Prisma.$UniversityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      image: string | null
      fees: string | null
      duration: string | null
      degreeType: string | null
      ieltsScore: string | null
      ranking: string | null
      intake: string[]
      websiteLink: string | null
      universityId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applications<T extends Course$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Course$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favByUsers<T extends Course$favByUsersArgs<ExtArgs> = {}>(args?: Subset<T, Course$favByUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    university<T extends UniversityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniversityDefaultArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly name: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly image: FieldRef<"Course", 'String'>
    readonly fees: FieldRef<"Course", 'String'>
    readonly duration: FieldRef<"Course", 'String'>
    readonly degreeType: FieldRef<"Course", 'String'>
    readonly ieltsScore: FieldRef<"Course", 'String'>
    readonly ranking: FieldRef<"Course", 'String'>
    readonly intake: FieldRef<"Course", 'String[]'>
    readonly websiteLink: FieldRef<"Course", 'String'>
    readonly universityId: FieldRef<"Course", 'String'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.applications
   */
  export type Course$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
    where?: UniversityApplicationsWhereInput
    orderBy?: UniversityApplicationsOrderByWithRelationInput | UniversityApplicationsOrderByWithRelationInput[]
    cursor?: UniversityApplicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UniversityApplicationsScalarFieldEnum | UniversityApplicationsScalarFieldEnum[]
  }

  /**
   * Course.favByUsers
   */
  export type Course$favByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseInclude<ExtArgs> | null
    where?: FavCourseWhereInput
    orderBy?: FavCourseOrderByWithRelationInput | FavCourseOrderByWithRelationInput[]
    cursor?: FavCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavCourseScalarFieldEnum | FavCourseScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model UniversityApplications
   */

  export type AggregateUniversityApplications = {
    _count: UniversityApplicationsCountAggregateOutputType | null
    _min: UniversityApplicationsMinAggregateOutputType | null
    _max: UniversityApplicationsMaxAggregateOutputType | null
  }

  export type UniversityApplicationsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    universityId: string | null
    courseId: string | null
    status: $Enums.ApplicationStatus | null
    appliedAt: Date | null
    loanRequired: boolean | null
    additionalNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UniversityApplicationsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    universityId: string | null
    courseId: string | null
    status: $Enums.ApplicationStatus | null
    appliedAt: Date | null
    loanRequired: boolean | null
    additionalNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UniversityApplicationsCountAggregateOutputType = {
    id: number
    userId: number
    universityId: number
    courseId: number
    status: number
    appliedAt: number
    loanRequired: number
    documents: number
    additionalNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UniversityApplicationsMinAggregateInputType = {
    id?: true
    userId?: true
    universityId?: true
    courseId?: true
    status?: true
    appliedAt?: true
    loanRequired?: true
    additionalNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UniversityApplicationsMaxAggregateInputType = {
    id?: true
    userId?: true
    universityId?: true
    courseId?: true
    status?: true
    appliedAt?: true
    loanRequired?: true
    additionalNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UniversityApplicationsCountAggregateInputType = {
    id?: true
    userId?: true
    universityId?: true
    courseId?: true
    status?: true
    appliedAt?: true
    loanRequired?: true
    documents?: true
    additionalNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UniversityApplicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UniversityApplications to aggregate.
     */
    where?: UniversityApplicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityApplications to fetch.
     */
    orderBy?: UniversityApplicationsOrderByWithRelationInput | UniversityApplicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UniversityApplicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UniversityApplications
    **/
    _count?: true | UniversityApplicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UniversityApplicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UniversityApplicationsMaxAggregateInputType
  }

  export type GetUniversityApplicationsAggregateType<T extends UniversityApplicationsAggregateArgs> = {
        [P in keyof T & keyof AggregateUniversityApplications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUniversityApplications[P]>
      : GetScalarType<T[P], AggregateUniversityApplications[P]>
  }




  export type UniversityApplicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UniversityApplicationsWhereInput
    orderBy?: UniversityApplicationsOrderByWithAggregationInput | UniversityApplicationsOrderByWithAggregationInput[]
    by: UniversityApplicationsScalarFieldEnum[] | UniversityApplicationsScalarFieldEnum
    having?: UniversityApplicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UniversityApplicationsCountAggregateInputType | true
    _min?: UniversityApplicationsMinAggregateInputType
    _max?: UniversityApplicationsMaxAggregateInputType
  }

  export type UniversityApplicationsGroupByOutputType = {
    id: string
    userId: string
    universityId: string
    courseId: string
    status: $Enums.ApplicationStatus
    appliedAt: Date
    loanRequired: boolean
    documents: string[]
    additionalNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: UniversityApplicationsCountAggregateOutputType | null
    _min: UniversityApplicationsMinAggregateOutputType | null
    _max: UniversityApplicationsMaxAggregateOutputType | null
  }

  type GetUniversityApplicationsGroupByPayload<T extends UniversityApplicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UniversityApplicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UniversityApplicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UniversityApplicationsGroupByOutputType[P]>
            : GetScalarType<T[P], UniversityApplicationsGroupByOutputType[P]>
        }
      >
    >


  export type UniversityApplicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    universityId?: boolean
    courseId?: boolean
    status?: boolean
    appliedAt?: boolean
    loanRequired?: boolean
    documents?: boolean
    additionalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    university?: boolean | UniversityDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["universityApplications"]>

  export type UniversityApplicationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    universityId?: boolean
    courseId?: boolean
    status?: boolean
    appliedAt?: boolean
    loanRequired?: boolean
    documents?: boolean
    additionalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    university?: boolean | UniversityDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["universityApplications"]>

  export type UniversityApplicationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    universityId?: boolean
    courseId?: boolean
    status?: boolean
    appliedAt?: boolean
    loanRequired?: boolean
    documents?: boolean
    additionalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    university?: boolean | UniversityDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["universityApplications"]>

  export type UniversityApplicationsSelectScalar = {
    id?: boolean
    userId?: boolean
    universityId?: boolean
    courseId?: boolean
    status?: boolean
    appliedAt?: boolean
    loanRequired?: boolean
    documents?: boolean
    additionalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UniversityApplicationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "universityId" | "courseId" | "status" | "appliedAt" | "loanRequired" | "documents" | "additionalNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["universityApplications"]>
  export type UniversityApplicationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    university?: boolean | UniversityDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type UniversityApplicationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    university?: boolean | UniversityDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type UniversityApplicationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    university?: boolean | UniversityDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $UniversityApplicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UniversityApplications"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      university: Prisma.$UniversityPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      universityId: string
      courseId: string
      status: $Enums.ApplicationStatus
      appliedAt: Date
      loanRequired: boolean
      documents: string[]
      additionalNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["universityApplications"]>
    composites: {}
  }

  type UniversityApplicationsGetPayload<S extends boolean | null | undefined | UniversityApplicationsDefaultArgs> = $Result.GetResult<Prisma.$UniversityApplicationsPayload, S>

  type UniversityApplicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UniversityApplicationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UniversityApplicationsCountAggregateInputType | true
    }

  export interface UniversityApplicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UniversityApplications'], meta: { name: 'UniversityApplications' } }
    /**
     * Find zero or one UniversityApplications that matches the filter.
     * @param {UniversityApplicationsFindUniqueArgs} args - Arguments to find a UniversityApplications
     * @example
     * // Get one UniversityApplications
     * const universityApplications = await prisma.universityApplications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UniversityApplicationsFindUniqueArgs>(args: SelectSubset<T, UniversityApplicationsFindUniqueArgs<ExtArgs>>): Prisma__UniversityApplicationsClient<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UniversityApplications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UniversityApplicationsFindUniqueOrThrowArgs} args - Arguments to find a UniversityApplications
     * @example
     * // Get one UniversityApplications
     * const universityApplications = await prisma.universityApplications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UniversityApplicationsFindUniqueOrThrowArgs>(args: SelectSubset<T, UniversityApplicationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UniversityApplicationsClient<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UniversityApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityApplicationsFindFirstArgs} args - Arguments to find a UniversityApplications
     * @example
     * // Get one UniversityApplications
     * const universityApplications = await prisma.universityApplications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UniversityApplicationsFindFirstArgs>(args?: SelectSubset<T, UniversityApplicationsFindFirstArgs<ExtArgs>>): Prisma__UniversityApplicationsClient<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UniversityApplications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityApplicationsFindFirstOrThrowArgs} args - Arguments to find a UniversityApplications
     * @example
     * // Get one UniversityApplications
     * const universityApplications = await prisma.universityApplications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UniversityApplicationsFindFirstOrThrowArgs>(args?: SelectSubset<T, UniversityApplicationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UniversityApplicationsClient<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UniversityApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityApplicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UniversityApplications
     * const universityApplications = await prisma.universityApplications.findMany()
     * 
     * // Get first 10 UniversityApplications
     * const universityApplications = await prisma.universityApplications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const universityApplicationsWithIdOnly = await prisma.universityApplications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UniversityApplicationsFindManyArgs>(args?: SelectSubset<T, UniversityApplicationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UniversityApplications.
     * @param {UniversityApplicationsCreateArgs} args - Arguments to create a UniversityApplications.
     * @example
     * // Create one UniversityApplications
     * const UniversityApplications = await prisma.universityApplications.create({
     *   data: {
     *     // ... data to create a UniversityApplications
     *   }
     * })
     * 
     */
    create<T extends UniversityApplicationsCreateArgs>(args: SelectSubset<T, UniversityApplicationsCreateArgs<ExtArgs>>): Prisma__UniversityApplicationsClient<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UniversityApplications.
     * @param {UniversityApplicationsCreateManyArgs} args - Arguments to create many UniversityApplications.
     * @example
     * // Create many UniversityApplications
     * const universityApplications = await prisma.universityApplications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UniversityApplicationsCreateManyArgs>(args?: SelectSubset<T, UniversityApplicationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UniversityApplications and returns the data saved in the database.
     * @param {UniversityApplicationsCreateManyAndReturnArgs} args - Arguments to create many UniversityApplications.
     * @example
     * // Create many UniversityApplications
     * const universityApplications = await prisma.universityApplications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UniversityApplications and only return the `id`
     * const universityApplicationsWithIdOnly = await prisma.universityApplications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UniversityApplicationsCreateManyAndReturnArgs>(args?: SelectSubset<T, UniversityApplicationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UniversityApplications.
     * @param {UniversityApplicationsDeleteArgs} args - Arguments to delete one UniversityApplications.
     * @example
     * // Delete one UniversityApplications
     * const UniversityApplications = await prisma.universityApplications.delete({
     *   where: {
     *     // ... filter to delete one UniversityApplications
     *   }
     * })
     * 
     */
    delete<T extends UniversityApplicationsDeleteArgs>(args: SelectSubset<T, UniversityApplicationsDeleteArgs<ExtArgs>>): Prisma__UniversityApplicationsClient<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UniversityApplications.
     * @param {UniversityApplicationsUpdateArgs} args - Arguments to update one UniversityApplications.
     * @example
     * // Update one UniversityApplications
     * const universityApplications = await prisma.universityApplications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UniversityApplicationsUpdateArgs>(args: SelectSubset<T, UniversityApplicationsUpdateArgs<ExtArgs>>): Prisma__UniversityApplicationsClient<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UniversityApplications.
     * @param {UniversityApplicationsDeleteManyArgs} args - Arguments to filter UniversityApplications to delete.
     * @example
     * // Delete a few UniversityApplications
     * const { count } = await prisma.universityApplications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UniversityApplicationsDeleteManyArgs>(args?: SelectSubset<T, UniversityApplicationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UniversityApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityApplicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UniversityApplications
     * const universityApplications = await prisma.universityApplications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UniversityApplicationsUpdateManyArgs>(args: SelectSubset<T, UniversityApplicationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UniversityApplications and returns the data updated in the database.
     * @param {UniversityApplicationsUpdateManyAndReturnArgs} args - Arguments to update many UniversityApplications.
     * @example
     * // Update many UniversityApplications
     * const universityApplications = await prisma.universityApplications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UniversityApplications and only return the `id`
     * const universityApplicationsWithIdOnly = await prisma.universityApplications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UniversityApplicationsUpdateManyAndReturnArgs>(args: SelectSubset<T, UniversityApplicationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UniversityApplications.
     * @param {UniversityApplicationsUpsertArgs} args - Arguments to update or create a UniversityApplications.
     * @example
     * // Update or create a UniversityApplications
     * const universityApplications = await prisma.universityApplications.upsert({
     *   create: {
     *     // ... data to create a UniversityApplications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UniversityApplications we want to update
     *   }
     * })
     */
    upsert<T extends UniversityApplicationsUpsertArgs>(args: SelectSubset<T, UniversityApplicationsUpsertArgs<ExtArgs>>): Prisma__UniversityApplicationsClient<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UniversityApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityApplicationsCountArgs} args - Arguments to filter UniversityApplications to count.
     * @example
     * // Count the number of UniversityApplications
     * const count = await prisma.universityApplications.count({
     *   where: {
     *     // ... the filter for the UniversityApplications we want to count
     *   }
     * })
    **/
    count<T extends UniversityApplicationsCountArgs>(
      args?: Subset<T, UniversityApplicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UniversityApplicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UniversityApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityApplicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UniversityApplicationsAggregateArgs>(args: Subset<T, UniversityApplicationsAggregateArgs>): Prisma.PrismaPromise<GetUniversityApplicationsAggregateType<T>>

    /**
     * Group by UniversityApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UniversityApplicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UniversityApplicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UniversityApplicationsGroupByArgs['orderBy'] }
        : { orderBy?: UniversityApplicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UniversityApplicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUniversityApplicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UniversityApplications model
   */
  readonly fields: UniversityApplicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UniversityApplications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UniversityApplicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    university<T extends UniversityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UniversityDefaultArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UniversityApplications model
   */
  interface UniversityApplicationsFieldRefs {
    readonly id: FieldRef<"UniversityApplications", 'String'>
    readonly userId: FieldRef<"UniversityApplications", 'String'>
    readonly universityId: FieldRef<"UniversityApplications", 'String'>
    readonly courseId: FieldRef<"UniversityApplications", 'String'>
    readonly status: FieldRef<"UniversityApplications", 'ApplicationStatus'>
    readonly appliedAt: FieldRef<"UniversityApplications", 'DateTime'>
    readonly loanRequired: FieldRef<"UniversityApplications", 'Boolean'>
    readonly documents: FieldRef<"UniversityApplications", 'String[]'>
    readonly additionalNotes: FieldRef<"UniversityApplications", 'String'>
    readonly createdAt: FieldRef<"UniversityApplications", 'DateTime'>
    readonly updatedAt: FieldRef<"UniversityApplications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UniversityApplications findUnique
   */
  export type UniversityApplicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
    /**
     * Filter, which UniversityApplications to fetch.
     */
    where: UniversityApplicationsWhereUniqueInput
  }

  /**
   * UniversityApplications findUniqueOrThrow
   */
  export type UniversityApplicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
    /**
     * Filter, which UniversityApplications to fetch.
     */
    where: UniversityApplicationsWhereUniqueInput
  }

  /**
   * UniversityApplications findFirst
   */
  export type UniversityApplicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
    /**
     * Filter, which UniversityApplications to fetch.
     */
    where?: UniversityApplicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityApplications to fetch.
     */
    orderBy?: UniversityApplicationsOrderByWithRelationInput | UniversityApplicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UniversityApplications.
     */
    cursor?: UniversityApplicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UniversityApplications.
     */
    distinct?: UniversityApplicationsScalarFieldEnum | UniversityApplicationsScalarFieldEnum[]
  }

  /**
   * UniversityApplications findFirstOrThrow
   */
  export type UniversityApplicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
    /**
     * Filter, which UniversityApplications to fetch.
     */
    where?: UniversityApplicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityApplications to fetch.
     */
    orderBy?: UniversityApplicationsOrderByWithRelationInput | UniversityApplicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UniversityApplications.
     */
    cursor?: UniversityApplicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UniversityApplications.
     */
    distinct?: UniversityApplicationsScalarFieldEnum | UniversityApplicationsScalarFieldEnum[]
  }

  /**
   * UniversityApplications findMany
   */
  export type UniversityApplicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
    /**
     * Filter, which UniversityApplications to fetch.
     */
    where?: UniversityApplicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UniversityApplications to fetch.
     */
    orderBy?: UniversityApplicationsOrderByWithRelationInput | UniversityApplicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UniversityApplications.
     */
    cursor?: UniversityApplicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UniversityApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UniversityApplications.
     */
    skip?: number
    distinct?: UniversityApplicationsScalarFieldEnum | UniversityApplicationsScalarFieldEnum[]
  }

  /**
   * UniversityApplications create
   */
  export type UniversityApplicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
    /**
     * The data needed to create a UniversityApplications.
     */
    data: XOR<UniversityApplicationsCreateInput, UniversityApplicationsUncheckedCreateInput>
  }

  /**
   * UniversityApplications createMany
   */
  export type UniversityApplicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UniversityApplications.
     */
    data: UniversityApplicationsCreateManyInput | UniversityApplicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UniversityApplications createManyAndReturn
   */
  export type UniversityApplicationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * The data used to create many UniversityApplications.
     */
    data: UniversityApplicationsCreateManyInput | UniversityApplicationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UniversityApplications update
   */
  export type UniversityApplicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
    /**
     * The data needed to update a UniversityApplications.
     */
    data: XOR<UniversityApplicationsUpdateInput, UniversityApplicationsUncheckedUpdateInput>
    /**
     * Choose, which UniversityApplications to update.
     */
    where: UniversityApplicationsWhereUniqueInput
  }

  /**
   * UniversityApplications updateMany
   */
  export type UniversityApplicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UniversityApplications.
     */
    data: XOR<UniversityApplicationsUpdateManyMutationInput, UniversityApplicationsUncheckedUpdateManyInput>
    /**
     * Filter which UniversityApplications to update
     */
    where?: UniversityApplicationsWhereInput
    /**
     * Limit how many UniversityApplications to update.
     */
    limit?: number
  }

  /**
   * UniversityApplications updateManyAndReturn
   */
  export type UniversityApplicationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * The data used to update UniversityApplications.
     */
    data: XOR<UniversityApplicationsUpdateManyMutationInput, UniversityApplicationsUncheckedUpdateManyInput>
    /**
     * Filter which UniversityApplications to update
     */
    where?: UniversityApplicationsWhereInput
    /**
     * Limit how many UniversityApplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UniversityApplications upsert
   */
  export type UniversityApplicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
    /**
     * The filter to search for the UniversityApplications to update in case it exists.
     */
    where: UniversityApplicationsWhereUniqueInput
    /**
     * In case the UniversityApplications found by the `where` argument doesn't exist, create a new UniversityApplications with this data.
     */
    create: XOR<UniversityApplicationsCreateInput, UniversityApplicationsUncheckedCreateInput>
    /**
     * In case the UniversityApplications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UniversityApplicationsUpdateInput, UniversityApplicationsUncheckedUpdateInput>
  }

  /**
   * UniversityApplications delete
   */
  export type UniversityApplicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
    /**
     * Filter which UniversityApplications to delete.
     */
    where: UniversityApplicationsWhereUniqueInput
  }

  /**
   * UniversityApplications deleteMany
   */
  export type UniversityApplicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UniversityApplications to delete
     */
    where?: UniversityApplicationsWhereInput
    /**
     * Limit how many UniversityApplications to delete.
     */
    limit?: number
  }

  /**
   * UniversityApplications without action
   */
  export type UniversityApplicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
  }


  /**
   * Model Accommodation
   */

  export type AggregateAccommodation = {
    _count: AccommodationCountAggregateOutputType | null
    _avg: AccommodationAvgAggregateOutputType | null
    _sum: AccommodationSumAggregateOutputType | null
    _min: AccommodationMinAggregateOutputType | null
    _max: AccommodationMaxAggregateOutputType | null
  }

  export type AccommodationAvgAggregateOutputType = {
    deposit: number | null
    bathrooms: number | null
    bedrooms: number | null
    size: number | null
    minTerm: number | null
    maxTerm: number | null
    averageRating: number | null
    totalRatings: number | null
  }

  export type AccommodationSumAggregateOutputType = {
    deposit: number | null
    bathrooms: number | null
    bedrooms: number | null
    size: number | null
    minTerm: number | null
    maxTerm: number | null
    averageRating: number | null
    totalRatings: number | null
  }

  export type AccommodationMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.AccommodationType | null
    address: string | null
    city: string | null
    country: string | null
    banner: string | null
    includeBills: boolean | null
    deposit: number | null
    furnishing: $Enums.FurnishingType | null
    bathrooms: number | null
    bedrooms: number | null
    size: number | null
    availableFrom: Date | null
    minTerm: number | null
    maxTerm: number | null
    isAvailable: boolean | null
    landlordId: string | null
    averageRating: number | null
    totalRatings: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccommodationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.AccommodationType | null
    address: string | null
    city: string | null
    country: string | null
    banner: string | null
    includeBills: boolean | null
    deposit: number | null
    furnishing: $Enums.FurnishingType | null
    bathrooms: number | null
    bedrooms: number | null
    size: number | null
    availableFrom: Date | null
    minTerm: number | null
    maxTerm: number | null
    isAvailable: boolean | null
    landlordId: string | null
    averageRating: number | null
    totalRatings: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccommodationCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    address: number
    city: number
    country: number
    banner: number
    includeBills: number
    deposit: number
    furnishing: number
    bathrooms: number
    bedrooms: number
    size: number
    amenities: number
    rules: number
    images: number
    availableFrom: number
    minTerm: number
    maxTerm: number
    isAvailable: number
    landlordId: number
    averageRating: number
    totalRatings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccommodationAvgAggregateInputType = {
    deposit?: true
    bathrooms?: true
    bedrooms?: true
    size?: true
    minTerm?: true
    maxTerm?: true
    averageRating?: true
    totalRatings?: true
  }

  export type AccommodationSumAggregateInputType = {
    deposit?: true
    bathrooms?: true
    bedrooms?: true
    size?: true
    minTerm?: true
    maxTerm?: true
    averageRating?: true
    totalRatings?: true
  }

  export type AccommodationMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    address?: true
    city?: true
    country?: true
    banner?: true
    includeBills?: true
    deposit?: true
    furnishing?: true
    bathrooms?: true
    bedrooms?: true
    size?: true
    availableFrom?: true
    minTerm?: true
    maxTerm?: true
    isAvailable?: true
    landlordId?: true
    averageRating?: true
    totalRatings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccommodationMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    address?: true
    city?: true
    country?: true
    banner?: true
    includeBills?: true
    deposit?: true
    furnishing?: true
    bathrooms?: true
    bedrooms?: true
    size?: true
    availableFrom?: true
    minTerm?: true
    maxTerm?: true
    isAvailable?: true
    landlordId?: true
    averageRating?: true
    totalRatings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccommodationCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    address?: true
    city?: true
    country?: true
    banner?: true
    includeBills?: true
    deposit?: true
    furnishing?: true
    bathrooms?: true
    bedrooms?: true
    size?: true
    amenities?: true
    rules?: true
    images?: true
    availableFrom?: true
    minTerm?: true
    maxTerm?: true
    isAvailable?: true
    landlordId?: true
    averageRating?: true
    totalRatings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccommodationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accommodation to aggregate.
     */
    where?: AccommodationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accommodations to fetch.
     */
    orderBy?: AccommodationOrderByWithRelationInput | AccommodationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccommodationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accommodations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accommodations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accommodations
    **/
    _count?: true | AccommodationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccommodationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccommodationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccommodationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccommodationMaxAggregateInputType
  }

  export type GetAccommodationAggregateType<T extends AccommodationAggregateArgs> = {
        [P in keyof T & keyof AggregateAccommodation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccommodation[P]>
      : GetScalarType<T[P], AggregateAccommodation[P]>
  }




  export type AccommodationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccommodationWhereInput
    orderBy?: AccommodationOrderByWithAggregationInput | AccommodationOrderByWithAggregationInput[]
    by: AccommodationScalarFieldEnum[] | AccommodationScalarFieldEnum
    having?: AccommodationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccommodationCountAggregateInputType | true
    _avg?: AccommodationAvgAggregateInputType
    _sum?: AccommodationSumAggregateInputType
    _min?: AccommodationMinAggregateInputType
    _max?: AccommodationMaxAggregateInputType
  }

  export type AccommodationGroupByOutputType = {
    id: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills: boolean | null
    deposit: number | null
    furnishing: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size: number | null
    amenities: string[]
    rules: string[]
    images: string[]
    availableFrom: Date
    minTerm: number
    maxTerm: number | null
    isAvailable: boolean
    landlordId: string
    averageRating: number | null
    totalRatings: number
    createdAt: Date
    updatedAt: Date
    _count: AccommodationCountAggregateOutputType | null
    _avg: AccommodationAvgAggregateOutputType | null
    _sum: AccommodationSumAggregateOutputType | null
    _min: AccommodationMinAggregateOutputType | null
    _max: AccommodationMaxAggregateOutputType | null
  }

  type GetAccommodationGroupByPayload<T extends AccommodationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccommodationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccommodationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccommodationGroupByOutputType[P]>
            : GetScalarType<T[P], AccommodationGroupByOutputType[P]>
        }
      >
    >


  export type AccommodationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    banner?: boolean
    includeBills?: boolean
    deposit?: boolean
    furnishing?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    size?: boolean
    amenities?: boolean
    rules?: boolean
    images?: boolean
    availableFrom?: boolean
    minTerm?: boolean
    maxTerm?: boolean
    isAvailable?: boolean
    landlordId?: boolean
    averageRating?: boolean
    totalRatings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    landlord?: boolean | UserDefaultArgs<ExtArgs>
    reviews?: boolean | Accommodation$reviewsArgs<ExtArgs>
    ratings?: boolean | Accommodation$ratingsArgs<ExtArgs>
    likedBy?: boolean | Accommodation$likedByArgs<ExtArgs>
    pricingPlans?: boolean | Accommodation$pricingPlansArgs<ExtArgs>
    _count?: boolean | AccommodationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accommodation"]>

  export type AccommodationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    banner?: boolean
    includeBills?: boolean
    deposit?: boolean
    furnishing?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    size?: boolean
    amenities?: boolean
    rules?: boolean
    images?: boolean
    availableFrom?: boolean
    minTerm?: boolean
    maxTerm?: boolean
    isAvailable?: boolean
    landlordId?: boolean
    averageRating?: boolean
    totalRatings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accommodation"]>

  export type AccommodationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    banner?: boolean
    includeBills?: boolean
    deposit?: boolean
    furnishing?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    size?: boolean
    amenities?: boolean
    rules?: boolean
    images?: boolean
    availableFrom?: boolean
    minTerm?: boolean
    maxTerm?: boolean
    isAvailable?: boolean
    landlordId?: boolean
    averageRating?: boolean
    totalRatings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accommodation"]>

  export type AccommodationSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    banner?: boolean
    includeBills?: boolean
    deposit?: boolean
    furnishing?: boolean
    bathrooms?: boolean
    bedrooms?: boolean
    size?: boolean
    amenities?: boolean
    rules?: boolean
    images?: boolean
    availableFrom?: boolean
    minTerm?: boolean
    maxTerm?: boolean
    isAvailable?: boolean
    landlordId?: boolean
    averageRating?: boolean
    totalRatings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccommodationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "type" | "address" | "city" | "country" | "banner" | "includeBills" | "deposit" | "furnishing" | "bathrooms" | "bedrooms" | "size" | "amenities" | "rules" | "images" | "availableFrom" | "minTerm" | "maxTerm" | "isAvailable" | "landlordId" | "averageRating" | "totalRatings" | "createdAt" | "updatedAt", ExtArgs["result"]["accommodation"]>
  export type AccommodationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landlord?: boolean | UserDefaultArgs<ExtArgs>
    reviews?: boolean | Accommodation$reviewsArgs<ExtArgs>
    ratings?: boolean | Accommodation$ratingsArgs<ExtArgs>
    likedBy?: boolean | Accommodation$likedByArgs<ExtArgs>
    pricingPlans?: boolean | Accommodation$pricingPlansArgs<ExtArgs>
    _count?: boolean | AccommodationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccommodationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccommodationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landlord?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccommodationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Accommodation"
    objects: {
      landlord: Prisma.$UserPayload<ExtArgs>
      reviews: Prisma.$AccommodationReviewPayload<ExtArgs>[]
      ratings: Prisma.$AccommodationRatingPayload<ExtArgs>[]
      likedBy: Prisma.$LikedAccommodationsPayload<ExtArgs>[]
      pricingPlans: Prisma.$PricingPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      type: $Enums.AccommodationType
      address: string
      city: string
      country: string
      banner: string
      includeBills: boolean | null
      deposit: number | null
      furnishing: $Enums.FurnishingType | null
      bathrooms: number
      bedrooms: number
      size: number | null
      amenities: string[]
      rules: string[]
      images: string[]
      availableFrom: Date
      minTerm: number
      maxTerm: number | null
      isAvailable: boolean
      landlordId: string
      averageRating: number | null
      totalRatings: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accommodation"]>
    composites: {}
  }

  type AccommodationGetPayload<S extends boolean | null | undefined | AccommodationDefaultArgs> = $Result.GetResult<Prisma.$AccommodationPayload, S>

  type AccommodationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccommodationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccommodationCountAggregateInputType | true
    }

  export interface AccommodationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Accommodation'], meta: { name: 'Accommodation' } }
    /**
     * Find zero or one Accommodation that matches the filter.
     * @param {AccommodationFindUniqueArgs} args - Arguments to find a Accommodation
     * @example
     * // Get one Accommodation
     * const accommodation = await prisma.accommodation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccommodationFindUniqueArgs>(args: SelectSubset<T, AccommodationFindUniqueArgs<ExtArgs>>): Prisma__AccommodationClient<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accommodation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccommodationFindUniqueOrThrowArgs} args - Arguments to find a Accommodation
     * @example
     * // Get one Accommodation
     * const accommodation = await prisma.accommodation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccommodationFindUniqueOrThrowArgs>(args: SelectSubset<T, AccommodationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccommodationClient<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accommodation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationFindFirstArgs} args - Arguments to find a Accommodation
     * @example
     * // Get one Accommodation
     * const accommodation = await prisma.accommodation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccommodationFindFirstArgs>(args?: SelectSubset<T, AccommodationFindFirstArgs<ExtArgs>>): Prisma__AccommodationClient<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accommodation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationFindFirstOrThrowArgs} args - Arguments to find a Accommodation
     * @example
     * // Get one Accommodation
     * const accommodation = await prisma.accommodation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccommodationFindFirstOrThrowArgs>(args?: SelectSubset<T, AccommodationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccommodationClient<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accommodations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accommodations
     * const accommodations = await prisma.accommodation.findMany()
     * 
     * // Get first 10 Accommodations
     * const accommodations = await prisma.accommodation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accommodationWithIdOnly = await prisma.accommodation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccommodationFindManyArgs>(args?: SelectSubset<T, AccommodationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accommodation.
     * @param {AccommodationCreateArgs} args - Arguments to create a Accommodation.
     * @example
     * // Create one Accommodation
     * const Accommodation = await prisma.accommodation.create({
     *   data: {
     *     // ... data to create a Accommodation
     *   }
     * })
     * 
     */
    create<T extends AccommodationCreateArgs>(args: SelectSubset<T, AccommodationCreateArgs<ExtArgs>>): Prisma__AccommodationClient<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accommodations.
     * @param {AccommodationCreateManyArgs} args - Arguments to create many Accommodations.
     * @example
     * // Create many Accommodations
     * const accommodation = await prisma.accommodation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccommodationCreateManyArgs>(args?: SelectSubset<T, AccommodationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accommodations and returns the data saved in the database.
     * @param {AccommodationCreateManyAndReturnArgs} args - Arguments to create many Accommodations.
     * @example
     * // Create many Accommodations
     * const accommodation = await prisma.accommodation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accommodations and only return the `id`
     * const accommodationWithIdOnly = await prisma.accommodation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccommodationCreateManyAndReturnArgs>(args?: SelectSubset<T, AccommodationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Accommodation.
     * @param {AccommodationDeleteArgs} args - Arguments to delete one Accommodation.
     * @example
     * // Delete one Accommodation
     * const Accommodation = await prisma.accommodation.delete({
     *   where: {
     *     // ... filter to delete one Accommodation
     *   }
     * })
     * 
     */
    delete<T extends AccommodationDeleteArgs>(args: SelectSubset<T, AccommodationDeleteArgs<ExtArgs>>): Prisma__AccommodationClient<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accommodation.
     * @param {AccommodationUpdateArgs} args - Arguments to update one Accommodation.
     * @example
     * // Update one Accommodation
     * const accommodation = await prisma.accommodation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccommodationUpdateArgs>(args: SelectSubset<T, AccommodationUpdateArgs<ExtArgs>>): Prisma__AccommodationClient<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accommodations.
     * @param {AccommodationDeleteManyArgs} args - Arguments to filter Accommodations to delete.
     * @example
     * // Delete a few Accommodations
     * const { count } = await prisma.accommodation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccommodationDeleteManyArgs>(args?: SelectSubset<T, AccommodationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accommodations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accommodations
     * const accommodation = await prisma.accommodation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccommodationUpdateManyArgs>(args: SelectSubset<T, AccommodationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accommodations and returns the data updated in the database.
     * @param {AccommodationUpdateManyAndReturnArgs} args - Arguments to update many Accommodations.
     * @example
     * // Update many Accommodations
     * const accommodation = await prisma.accommodation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accommodations and only return the `id`
     * const accommodationWithIdOnly = await prisma.accommodation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccommodationUpdateManyAndReturnArgs>(args: SelectSubset<T, AccommodationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Accommodation.
     * @param {AccommodationUpsertArgs} args - Arguments to update or create a Accommodation.
     * @example
     * // Update or create a Accommodation
     * const accommodation = await prisma.accommodation.upsert({
     *   create: {
     *     // ... data to create a Accommodation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accommodation we want to update
     *   }
     * })
     */
    upsert<T extends AccommodationUpsertArgs>(args: SelectSubset<T, AccommodationUpsertArgs<ExtArgs>>): Prisma__AccommodationClient<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accommodations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationCountArgs} args - Arguments to filter Accommodations to count.
     * @example
     * // Count the number of Accommodations
     * const count = await prisma.accommodation.count({
     *   where: {
     *     // ... the filter for the Accommodations we want to count
     *   }
     * })
    **/
    count<T extends AccommodationCountArgs>(
      args?: Subset<T, AccommodationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccommodationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accommodation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccommodationAggregateArgs>(args: Subset<T, AccommodationAggregateArgs>): Prisma.PrismaPromise<GetAccommodationAggregateType<T>>

    /**
     * Group by Accommodation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccommodationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccommodationGroupByArgs['orderBy'] }
        : { orderBy?: AccommodationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccommodationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccommodationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Accommodation model
   */
  readonly fields: AccommodationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Accommodation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccommodationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    landlord<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviews<T extends Accommodation$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Accommodation$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Accommodation$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Accommodation$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedBy<T extends Accommodation$likedByArgs<ExtArgs> = {}>(args?: Subset<T, Accommodation$likedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pricingPlans<T extends Accommodation$pricingPlansArgs<ExtArgs> = {}>(args?: Subset<T, Accommodation$pricingPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Accommodation model
   */
  interface AccommodationFieldRefs {
    readonly id: FieldRef<"Accommodation", 'String'>
    readonly title: FieldRef<"Accommodation", 'String'>
    readonly description: FieldRef<"Accommodation", 'String'>
    readonly type: FieldRef<"Accommodation", 'AccommodationType'>
    readonly address: FieldRef<"Accommodation", 'String'>
    readonly city: FieldRef<"Accommodation", 'String'>
    readonly country: FieldRef<"Accommodation", 'String'>
    readonly banner: FieldRef<"Accommodation", 'String'>
    readonly includeBills: FieldRef<"Accommodation", 'Boolean'>
    readonly deposit: FieldRef<"Accommodation", 'Float'>
    readonly furnishing: FieldRef<"Accommodation", 'FurnishingType'>
    readonly bathrooms: FieldRef<"Accommodation", 'Int'>
    readonly bedrooms: FieldRef<"Accommodation", 'Int'>
    readonly size: FieldRef<"Accommodation", 'Float'>
    readonly amenities: FieldRef<"Accommodation", 'String[]'>
    readonly rules: FieldRef<"Accommodation", 'String[]'>
    readonly images: FieldRef<"Accommodation", 'String[]'>
    readonly availableFrom: FieldRef<"Accommodation", 'DateTime'>
    readonly minTerm: FieldRef<"Accommodation", 'Int'>
    readonly maxTerm: FieldRef<"Accommodation", 'Int'>
    readonly isAvailable: FieldRef<"Accommodation", 'Boolean'>
    readonly landlordId: FieldRef<"Accommodation", 'String'>
    readonly averageRating: FieldRef<"Accommodation", 'Float'>
    readonly totalRatings: FieldRef<"Accommodation", 'Int'>
    readonly createdAt: FieldRef<"Accommodation", 'DateTime'>
    readonly updatedAt: FieldRef<"Accommodation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Accommodation findUnique
   */
  export type AccommodationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationInclude<ExtArgs> | null
    /**
     * Filter, which Accommodation to fetch.
     */
    where: AccommodationWhereUniqueInput
  }

  /**
   * Accommodation findUniqueOrThrow
   */
  export type AccommodationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationInclude<ExtArgs> | null
    /**
     * Filter, which Accommodation to fetch.
     */
    where: AccommodationWhereUniqueInput
  }

  /**
   * Accommodation findFirst
   */
  export type AccommodationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationInclude<ExtArgs> | null
    /**
     * Filter, which Accommodation to fetch.
     */
    where?: AccommodationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accommodations to fetch.
     */
    orderBy?: AccommodationOrderByWithRelationInput | AccommodationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accommodations.
     */
    cursor?: AccommodationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accommodations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accommodations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accommodations.
     */
    distinct?: AccommodationScalarFieldEnum | AccommodationScalarFieldEnum[]
  }

  /**
   * Accommodation findFirstOrThrow
   */
  export type AccommodationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationInclude<ExtArgs> | null
    /**
     * Filter, which Accommodation to fetch.
     */
    where?: AccommodationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accommodations to fetch.
     */
    orderBy?: AccommodationOrderByWithRelationInput | AccommodationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accommodations.
     */
    cursor?: AccommodationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accommodations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accommodations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accommodations.
     */
    distinct?: AccommodationScalarFieldEnum | AccommodationScalarFieldEnum[]
  }

  /**
   * Accommodation findMany
   */
  export type AccommodationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationInclude<ExtArgs> | null
    /**
     * Filter, which Accommodations to fetch.
     */
    where?: AccommodationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accommodations to fetch.
     */
    orderBy?: AccommodationOrderByWithRelationInput | AccommodationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accommodations.
     */
    cursor?: AccommodationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accommodations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accommodations.
     */
    skip?: number
    distinct?: AccommodationScalarFieldEnum | AccommodationScalarFieldEnum[]
  }

  /**
   * Accommodation create
   */
  export type AccommodationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationInclude<ExtArgs> | null
    /**
     * The data needed to create a Accommodation.
     */
    data: XOR<AccommodationCreateInput, AccommodationUncheckedCreateInput>
  }

  /**
   * Accommodation createMany
   */
  export type AccommodationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accommodations.
     */
    data: AccommodationCreateManyInput | AccommodationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Accommodation createManyAndReturn
   */
  export type AccommodationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * The data used to create many Accommodations.
     */
    data: AccommodationCreateManyInput | AccommodationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Accommodation update
   */
  export type AccommodationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationInclude<ExtArgs> | null
    /**
     * The data needed to update a Accommodation.
     */
    data: XOR<AccommodationUpdateInput, AccommodationUncheckedUpdateInput>
    /**
     * Choose, which Accommodation to update.
     */
    where: AccommodationWhereUniqueInput
  }

  /**
   * Accommodation updateMany
   */
  export type AccommodationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accommodations.
     */
    data: XOR<AccommodationUpdateManyMutationInput, AccommodationUncheckedUpdateManyInput>
    /**
     * Filter which Accommodations to update
     */
    where?: AccommodationWhereInput
    /**
     * Limit how many Accommodations to update.
     */
    limit?: number
  }

  /**
   * Accommodation updateManyAndReturn
   */
  export type AccommodationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * The data used to update Accommodations.
     */
    data: XOR<AccommodationUpdateManyMutationInput, AccommodationUncheckedUpdateManyInput>
    /**
     * Filter which Accommodations to update
     */
    where?: AccommodationWhereInput
    /**
     * Limit how many Accommodations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Accommodation upsert
   */
  export type AccommodationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationInclude<ExtArgs> | null
    /**
     * The filter to search for the Accommodation to update in case it exists.
     */
    where: AccommodationWhereUniqueInput
    /**
     * In case the Accommodation found by the `where` argument doesn't exist, create a new Accommodation with this data.
     */
    create: XOR<AccommodationCreateInput, AccommodationUncheckedCreateInput>
    /**
     * In case the Accommodation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccommodationUpdateInput, AccommodationUncheckedUpdateInput>
  }

  /**
   * Accommodation delete
   */
  export type AccommodationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationInclude<ExtArgs> | null
    /**
     * Filter which Accommodation to delete.
     */
    where: AccommodationWhereUniqueInput
  }

  /**
   * Accommodation deleteMany
   */
  export type AccommodationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accommodations to delete
     */
    where?: AccommodationWhereInput
    /**
     * Limit how many Accommodations to delete.
     */
    limit?: number
  }

  /**
   * Accommodation.reviews
   */
  export type Accommodation$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewInclude<ExtArgs> | null
    where?: AccommodationReviewWhereInput
    orderBy?: AccommodationReviewOrderByWithRelationInput | AccommodationReviewOrderByWithRelationInput[]
    cursor?: AccommodationReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccommodationReviewScalarFieldEnum | AccommodationReviewScalarFieldEnum[]
  }

  /**
   * Accommodation.ratings
   */
  export type Accommodation$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingInclude<ExtArgs> | null
    where?: AccommodationRatingWhereInput
    orderBy?: AccommodationRatingOrderByWithRelationInput | AccommodationRatingOrderByWithRelationInput[]
    cursor?: AccommodationRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccommodationRatingScalarFieldEnum | AccommodationRatingScalarFieldEnum[]
  }

  /**
   * Accommodation.likedBy
   */
  export type Accommodation$likedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsInclude<ExtArgs> | null
    where?: LikedAccommodationsWhereInput
    orderBy?: LikedAccommodationsOrderByWithRelationInput | LikedAccommodationsOrderByWithRelationInput[]
    cursor?: LikedAccommodationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikedAccommodationsScalarFieldEnum | LikedAccommodationsScalarFieldEnum[]
  }

  /**
   * Accommodation.pricingPlans
   */
  export type Accommodation$pricingPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    where?: PricingPlanWhereInput
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    cursor?: PricingPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PricingPlanScalarFieldEnum | PricingPlanScalarFieldEnum[]
  }

  /**
   * Accommodation without action
   */
  export type AccommodationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationInclude<ExtArgs> | null
  }


  /**
   * Model PricingPlan
   */

  export type AggregatePricingPlan = {
    _count: PricingPlanCountAggregateOutputType | null
    _avg: PricingPlanAvgAggregateOutputType | null
    _sum: PricingPlanSumAggregateOutputType | null
    _min: PricingPlanMinAggregateOutputType | null
    _max: PricingPlanMaxAggregateOutputType | null
  }

  export type PricingPlanAvgAggregateOutputType = {
    price: number | null
  }

  export type PricingPlanSumAggregateOutputType = {
    price: number | null
  }

  export type PricingPlanMinAggregateOutputType = {
    id: string | null
    accommodationId: string | null
    type: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingPlanMaxAggregateOutputType = {
    id: string | null
    accommodationId: string | null
    type: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingPlanCountAggregateOutputType = {
    id: number
    accommodationId: number
    type: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PricingPlanAvgAggregateInputType = {
    price?: true
  }

  export type PricingPlanSumAggregateInputType = {
    price?: true
  }

  export type PricingPlanMinAggregateInputType = {
    id?: true
    accommodationId?: true
    type?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingPlanMaxAggregateInputType = {
    id?: true
    accommodationId?: true
    type?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingPlanCountAggregateInputType = {
    id?: true
    accommodationId?: true
    type?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PricingPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingPlan to aggregate.
     */
    where?: PricingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingPlans to fetch.
     */
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PricingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PricingPlans
    **/
    _count?: true | PricingPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingPlanMaxAggregateInputType
  }

  export type GetPricingPlanAggregateType<T extends PricingPlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePricingPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricingPlan[P]>
      : GetScalarType<T[P], AggregatePricingPlan[P]>
  }




  export type PricingPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingPlanWhereInput
    orderBy?: PricingPlanOrderByWithAggregationInput | PricingPlanOrderByWithAggregationInput[]
    by: PricingPlanScalarFieldEnum[] | PricingPlanScalarFieldEnum
    having?: PricingPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingPlanCountAggregateInputType | true
    _avg?: PricingPlanAvgAggregateInputType
    _sum?: PricingPlanSumAggregateInputType
    _min?: PricingPlanMinAggregateInputType
    _max?: PricingPlanMaxAggregateInputType
  }

  export type PricingPlanGroupByOutputType = {
    id: string
    accommodationId: string
    type: string
    price: number
    createdAt: Date
    updatedAt: Date
    _count: PricingPlanCountAggregateOutputType | null
    _avg: PricingPlanAvgAggregateOutputType | null
    _sum: PricingPlanSumAggregateOutputType | null
    _min: PricingPlanMinAggregateOutputType | null
    _max: PricingPlanMaxAggregateOutputType | null
  }

  type GetPricingPlanGroupByPayload<T extends PricingPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricingPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingPlanGroupByOutputType[P]>
            : GetScalarType<T[P], PricingPlanGroupByOutputType[P]>
        }
      >
    >


  export type PricingPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accommodationId?: boolean
    type?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricingPlan"]>

  export type PricingPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accommodationId?: boolean
    type?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricingPlan"]>

  export type PricingPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accommodationId?: boolean
    type?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricingPlan"]>

  export type PricingPlanSelectScalar = {
    id?: boolean
    accommodationId?: boolean
    type?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PricingPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accommodationId" | "type" | "price" | "createdAt" | "updatedAt", ExtArgs["result"]["pricingPlan"]>
  export type PricingPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }
  export type PricingPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }
  export type PricingPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }

  export type $PricingPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PricingPlan"
    objects: {
      accommodation: Prisma.$AccommodationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accommodationId: string
      type: string
      price: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pricingPlan"]>
    composites: {}
  }

  type PricingPlanGetPayload<S extends boolean | null | undefined | PricingPlanDefaultArgs> = $Result.GetResult<Prisma.$PricingPlanPayload, S>

  type PricingPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PricingPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PricingPlanCountAggregateInputType | true
    }

  export interface PricingPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PricingPlan'], meta: { name: 'PricingPlan' } }
    /**
     * Find zero or one PricingPlan that matches the filter.
     * @param {PricingPlanFindUniqueArgs} args - Arguments to find a PricingPlan
     * @example
     * // Get one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PricingPlanFindUniqueArgs>(args: SelectSubset<T, PricingPlanFindUniqueArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PricingPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PricingPlanFindUniqueOrThrowArgs} args - Arguments to find a PricingPlan
     * @example
     * // Get one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PricingPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PricingPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PricingPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanFindFirstArgs} args - Arguments to find a PricingPlan
     * @example
     * // Get one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PricingPlanFindFirstArgs>(args?: SelectSubset<T, PricingPlanFindFirstArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PricingPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanFindFirstOrThrowArgs} args - Arguments to find a PricingPlan
     * @example
     * // Get one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PricingPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PricingPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PricingPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PricingPlans
     * const pricingPlans = await prisma.pricingPlan.findMany()
     * 
     * // Get first 10 PricingPlans
     * const pricingPlans = await prisma.pricingPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricingPlanWithIdOnly = await prisma.pricingPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PricingPlanFindManyArgs>(args?: SelectSubset<T, PricingPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PricingPlan.
     * @param {PricingPlanCreateArgs} args - Arguments to create a PricingPlan.
     * @example
     * // Create one PricingPlan
     * const PricingPlan = await prisma.pricingPlan.create({
     *   data: {
     *     // ... data to create a PricingPlan
     *   }
     * })
     * 
     */
    create<T extends PricingPlanCreateArgs>(args: SelectSubset<T, PricingPlanCreateArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PricingPlans.
     * @param {PricingPlanCreateManyArgs} args - Arguments to create many PricingPlans.
     * @example
     * // Create many PricingPlans
     * const pricingPlan = await prisma.pricingPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PricingPlanCreateManyArgs>(args?: SelectSubset<T, PricingPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PricingPlans and returns the data saved in the database.
     * @param {PricingPlanCreateManyAndReturnArgs} args - Arguments to create many PricingPlans.
     * @example
     * // Create many PricingPlans
     * const pricingPlan = await prisma.pricingPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PricingPlans and only return the `id`
     * const pricingPlanWithIdOnly = await prisma.pricingPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PricingPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PricingPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PricingPlan.
     * @param {PricingPlanDeleteArgs} args - Arguments to delete one PricingPlan.
     * @example
     * // Delete one PricingPlan
     * const PricingPlan = await prisma.pricingPlan.delete({
     *   where: {
     *     // ... filter to delete one PricingPlan
     *   }
     * })
     * 
     */
    delete<T extends PricingPlanDeleteArgs>(args: SelectSubset<T, PricingPlanDeleteArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PricingPlan.
     * @param {PricingPlanUpdateArgs} args - Arguments to update one PricingPlan.
     * @example
     * // Update one PricingPlan
     * const pricingPlan = await prisma.pricingPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PricingPlanUpdateArgs>(args: SelectSubset<T, PricingPlanUpdateArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PricingPlans.
     * @param {PricingPlanDeleteManyArgs} args - Arguments to filter PricingPlans to delete.
     * @example
     * // Delete a few PricingPlans
     * const { count } = await prisma.pricingPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PricingPlanDeleteManyArgs>(args?: SelectSubset<T, PricingPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PricingPlans
     * const pricingPlan = await prisma.pricingPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PricingPlanUpdateManyArgs>(args: SelectSubset<T, PricingPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingPlans and returns the data updated in the database.
     * @param {PricingPlanUpdateManyAndReturnArgs} args - Arguments to update many PricingPlans.
     * @example
     * // Update many PricingPlans
     * const pricingPlan = await prisma.pricingPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PricingPlans and only return the `id`
     * const pricingPlanWithIdOnly = await prisma.pricingPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PricingPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PricingPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PricingPlan.
     * @param {PricingPlanUpsertArgs} args - Arguments to update or create a PricingPlan.
     * @example
     * // Update or create a PricingPlan
     * const pricingPlan = await prisma.pricingPlan.upsert({
     *   create: {
     *     // ... data to create a PricingPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PricingPlan we want to update
     *   }
     * })
     */
    upsert<T extends PricingPlanUpsertArgs>(args: SelectSubset<T, PricingPlanUpsertArgs<ExtArgs>>): Prisma__PricingPlanClient<$Result.GetResult<Prisma.$PricingPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PricingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanCountArgs} args - Arguments to filter PricingPlans to count.
     * @example
     * // Count the number of PricingPlans
     * const count = await prisma.pricingPlan.count({
     *   where: {
     *     // ... the filter for the PricingPlans we want to count
     *   }
     * })
    **/
    count<T extends PricingPlanCountArgs>(
      args?: Subset<T, PricingPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PricingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingPlanAggregateArgs>(args: Subset<T, PricingPlanAggregateArgs>): Prisma.PrismaPromise<GetPricingPlanAggregateType<T>>

    /**
     * Group by PricingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricingPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricingPlanGroupByArgs['orderBy'] }
        : { orderBy?: PricingPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricingPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PricingPlan model
   */
  readonly fields: PricingPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PricingPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PricingPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accommodation<T extends AccommodationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccommodationDefaultArgs<ExtArgs>>): Prisma__AccommodationClient<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PricingPlan model
   */
  interface PricingPlanFieldRefs {
    readonly id: FieldRef<"PricingPlan", 'String'>
    readonly accommodationId: FieldRef<"PricingPlan", 'String'>
    readonly type: FieldRef<"PricingPlan", 'String'>
    readonly price: FieldRef<"PricingPlan", 'Float'>
    readonly createdAt: FieldRef<"PricingPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"PricingPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PricingPlan findUnique
   */
  export type PricingPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * Filter, which PricingPlan to fetch.
     */
    where: PricingPlanWhereUniqueInput
  }

  /**
   * PricingPlan findUniqueOrThrow
   */
  export type PricingPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * Filter, which PricingPlan to fetch.
     */
    where: PricingPlanWhereUniqueInput
  }

  /**
   * PricingPlan findFirst
   */
  export type PricingPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * Filter, which PricingPlan to fetch.
     */
    where?: PricingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingPlans to fetch.
     */
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingPlans.
     */
    cursor?: PricingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingPlans.
     */
    distinct?: PricingPlanScalarFieldEnum | PricingPlanScalarFieldEnum[]
  }

  /**
   * PricingPlan findFirstOrThrow
   */
  export type PricingPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * Filter, which PricingPlan to fetch.
     */
    where?: PricingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingPlans to fetch.
     */
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingPlans.
     */
    cursor?: PricingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingPlans.
     */
    distinct?: PricingPlanScalarFieldEnum | PricingPlanScalarFieldEnum[]
  }

  /**
   * PricingPlan findMany
   */
  export type PricingPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * Filter, which PricingPlans to fetch.
     */
    where?: PricingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingPlans to fetch.
     */
    orderBy?: PricingPlanOrderByWithRelationInput | PricingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PricingPlans.
     */
    cursor?: PricingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingPlans.
     */
    skip?: number
    distinct?: PricingPlanScalarFieldEnum | PricingPlanScalarFieldEnum[]
  }

  /**
   * PricingPlan create
   */
  export type PricingPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a PricingPlan.
     */
    data: XOR<PricingPlanCreateInput, PricingPlanUncheckedCreateInput>
  }

  /**
   * PricingPlan createMany
   */
  export type PricingPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PricingPlans.
     */
    data: PricingPlanCreateManyInput | PricingPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PricingPlan createManyAndReturn
   */
  export type PricingPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * The data used to create many PricingPlans.
     */
    data: PricingPlanCreateManyInput | PricingPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PricingPlan update
   */
  export type PricingPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a PricingPlan.
     */
    data: XOR<PricingPlanUpdateInput, PricingPlanUncheckedUpdateInput>
    /**
     * Choose, which PricingPlan to update.
     */
    where: PricingPlanWhereUniqueInput
  }

  /**
   * PricingPlan updateMany
   */
  export type PricingPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PricingPlans.
     */
    data: XOR<PricingPlanUpdateManyMutationInput, PricingPlanUncheckedUpdateManyInput>
    /**
     * Filter which PricingPlans to update
     */
    where?: PricingPlanWhereInput
    /**
     * Limit how many PricingPlans to update.
     */
    limit?: number
  }

  /**
   * PricingPlan updateManyAndReturn
   */
  export type PricingPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * The data used to update PricingPlans.
     */
    data: XOR<PricingPlanUpdateManyMutationInput, PricingPlanUncheckedUpdateManyInput>
    /**
     * Filter which PricingPlans to update
     */
    where?: PricingPlanWhereInput
    /**
     * Limit how many PricingPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PricingPlan upsert
   */
  export type PricingPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the PricingPlan to update in case it exists.
     */
    where: PricingPlanWhereUniqueInput
    /**
     * In case the PricingPlan found by the `where` argument doesn't exist, create a new PricingPlan with this data.
     */
    create: XOR<PricingPlanCreateInput, PricingPlanUncheckedCreateInput>
    /**
     * In case the PricingPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PricingPlanUpdateInput, PricingPlanUncheckedUpdateInput>
  }

  /**
   * PricingPlan delete
   */
  export type PricingPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
    /**
     * Filter which PricingPlan to delete.
     */
    where: PricingPlanWhereUniqueInput
  }

  /**
   * PricingPlan deleteMany
   */
  export type PricingPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingPlans to delete
     */
    where?: PricingPlanWhereInput
    /**
     * Limit how many PricingPlans to delete.
     */
    limit?: number
  }

  /**
   * PricingPlan without action
   */
  export type PricingPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingPlan
     */
    select?: PricingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingPlan
     */
    omit?: PricingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingPlanInclude<ExtArgs> | null
  }


  /**
   * Model AccommodationApplication
   */

  export type AggregateAccommodationApplication = {
    _count: AccommodationApplicationCountAggregateOutputType | null
    _avg: AccommodationApplicationAvgAggregateOutputType | null
    _sum: AccommodationApplicationSumAggregateOutputType | null
    _min: AccommodationApplicationMinAggregateOutputType | null
    _max: AccommodationApplicationMaxAggregateOutputType | null
  }

  export type AccommodationApplicationAvgAggregateOutputType = {
    numberOfOccupants: number | null
  }

  export type AccommodationApplicationSumAggregateOutputType = {
    numberOfOccupants: number | null
  }

  export type AccommodationApplicationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accommodationId: string | null
    interestedFrom: Date | null
    interestedTill: Date | null
    numberOfOccupants: number | null
    additionalNotes: string | null
    status: $Enums.ApplicationStatus | null
    createdAt: Date | null
  }

  export type AccommodationApplicationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accommodationId: string | null
    interestedFrom: Date | null
    interestedTill: Date | null
    numberOfOccupants: number | null
    additionalNotes: string | null
    status: $Enums.ApplicationStatus | null
    createdAt: Date | null
  }

  export type AccommodationApplicationCountAggregateOutputType = {
    id: number
    userId: number
    accommodationId: number
    interestedFrom: number
    interestedTill: number
    numberOfOccupants: number
    additionalNotes: number
    status: number
    createdAt: number
    _all: number
  }


  export type AccommodationApplicationAvgAggregateInputType = {
    numberOfOccupants?: true
  }

  export type AccommodationApplicationSumAggregateInputType = {
    numberOfOccupants?: true
  }

  export type AccommodationApplicationMinAggregateInputType = {
    id?: true
    userId?: true
    accommodationId?: true
    interestedFrom?: true
    interestedTill?: true
    numberOfOccupants?: true
    additionalNotes?: true
    status?: true
    createdAt?: true
  }

  export type AccommodationApplicationMaxAggregateInputType = {
    id?: true
    userId?: true
    accommodationId?: true
    interestedFrom?: true
    interestedTill?: true
    numberOfOccupants?: true
    additionalNotes?: true
    status?: true
    createdAt?: true
  }

  export type AccommodationApplicationCountAggregateInputType = {
    id?: true
    userId?: true
    accommodationId?: true
    interestedFrom?: true
    interestedTill?: true
    numberOfOccupants?: true
    additionalNotes?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type AccommodationApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccommodationApplication to aggregate.
     */
    where?: AccommodationApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationApplications to fetch.
     */
    orderBy?: AccommodationApplicationOrderByWithRelationInput | AccommodationApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccommodationApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccommodationApplications
    **/
    _count?: true | AccommodationApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccommodationApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccommodationApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccommodationApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccommodationApplicationMaxAggregateInputType
  }

  export type GetAccommodationApplicationAggregateType<T extends AccommodationApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateAccommodationApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccommodationApplication[P]>
      : GetScalarType<T[P], AggregateAccommodationApplication[P]>
  }




  export type AccommodationApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccommodationApplicationWhereInput
    orderBy?: AccommodationApplicationOrderByWithAggregationInput | AccommodationApplicationOrderByWithAggregationInput[]
    by: AccommodationApplicationScalarFieldEnum[] | AccommodationApplicationScalarFieldEnum
    having?: AccommodationApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccommodationApplicationCountAggregateInputType | true
    _avg?: AccommodationApplicationAvgAggregateInputType
    _sum?: AccommodationApplicationSumAggregateInputType
    _min?: AccommodationApplicationMinAggregateInputType
    _max?: AccommodationApplicationMaxAggregateInputType
  }

  export type AccommodationApplicationGroupByOutputType = {
    id: string
    userId: string
    accommodationId: string
    interestedFrom: Date
    interestedTill: Date
    numberOfOccupants: number
    additionalNotes: string | null
    status: $Enums.ApplicationStatus
    createdAt: Date
    _count: AccommodationApplicationCountAggregateOutputType | null
    _avg: AccommodationApplicationAvgAggregateOutputType | null
    _sum: AccommodationApplicationSumAggregateOutputType | null
    _min: AccommodationApplicationMinAggregateOutputType | null
    _max: AccommodationApplicationMaxAggregateOutputType | null
  }

  type GetAccommodationApplicationGroupByPayload<T extends AccommodationApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccommodationApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccommodationApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccommodationApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], AccommodationApplicationGroupByOutputType[P]>
        }
      >
    >


  export type AccommodationApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accommodationId?: boolean
    interestedFrom?: boolean
    interestedTill?: boolean
    numberOfOccupants?: boolean
    additionalNotes?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["accommodationApplication"]>

  export type AccommodationApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accommodationId?: boolean
    interestedFrom?: boolean
    interestedTill?: boolean
    numberOfOccupants?: boolean
    additionalNotes?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["accommodationApplication"]>

  export type AccommodationApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accommodationId?: boolean
    interestedFrom?: boolean
    interestedTill?: boolean
    numberOfOccupants?: boolean
    additionalNotes?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["accommodationApplication"]>

  export type AccommodationApplicationSelectScalar = {
    id?: boolean
    userId?: boolean
    accommodationId?: boolean
    interestedFrom?: boolean
    interestedTill?: boolean
    numberOfOccupants?: boolean
    additionalNotes?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type AccommodationApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accommodationId" | "interestedFrom" | "interestedTill" | "numberOfOccupants" | "additionalNotes" | "status" | "createdAt", ExtArgs["result"]["accommodationApplication"]>

  export type $AccommodationApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccommodationApplication"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accommodationId: string
      interestedFrom: Date
      interestedTill: Date
      numberOfOccupants: number
      additionalNotes: string | null
      status: $Enums.ApplicationStatus
      createdAt: Date
    }, ExtArgs["result"]["accommodationApplication"]>
    composites: {}
  }

  type AccommodationApplicationGetPayload<S extends boolean | null | undefined | AccommodationApplicationDefaultArgs> = $Result.GetResult<Prisma.$AccommodationApplicationPayload, S>

  type AccommodationApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccommodationApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccommodationApplicationCountAggregateInputType | true
    }

  export interface AccommodationApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccommodationApplication'], meta: { name: 'AccommodationApplication' } }
    /**
     * Find zero or one AccommodationApplication that matches the filter.
     * @param {AccommodationApplicationFindUniqueArgs} args - Arguments to find a AccommodationApplication
     * @example
     * // Get one AccommodationApplication
     * const accommodationApplication = await prisma.accommodationApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccommodationApplicationFindUniqueArgs>(args: SelectSubset<T, AccommodationApplicationFindUniqueArgs<ExtArgs>>): Prisma__AccommodationApplicationClient<$Result.GetResult<Prisma.$AccommodationApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccommodationApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccommodationApplicationFindUniqueOrThrowArgs} args - Arguments to find a AccommodationApplication
     * @example
     * // Get one AccommodationApplication
     * const accommodationApplication = await prisma.accommodationApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccommodationApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, AccommodationApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccommodationApplicationClient<$Result.GetResult<Prisma.$AccommodationApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccommodationApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationApplicationFindFirstArgs} args - Arguments to find a AccommodationApplication
     * @example
     * // Get one AccommodationApplication
     * const accommodationApplication = await prisma.accommodationApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccommodationApplicationFindFirstArgs>(args?: SelectSubset<T, AccommodationApplicationFindFirstArgs<ExtArgs>>): Prisma__AccommodationApplicationClient<$Result.GetResult<Prisma.$AccommodationApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccommodationApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationApplicationFindFirstOrThrowArgs} args - Arguments to find a AccommodationApplication
     * @example
     * // Get one AccommodationApplication
     * const accommodationApplication = await prisma.accommodationApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccommodationApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, AccommodationApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccommodationApplicationClient<$Result.GetResult<Prisma.$AccommodationApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccommodationApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccommodationApplications
     * const accommodationApplications = await prisma.accommodationApplication.findMany()
     * 
     * // Get first 10 AccommodationApplications
     * const accommodationApplications = await prisma.accommodationApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accommodationApplicationWithIdOnly = await prisma.accommodationApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccommodationApplicationFindManyArgs>(args?: SelectSubset<T, AccommodationApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccommodationApplication.
     * @param {AccommodationApplicationCreateArgs} args - Arguments to create a AccommodationApplication.
     * @example
     * // Create one AccommodationApplication
     * const AccommodationApplication = await prisma.accommodationApplication.create({
     *   data: {
     *     // ... data to create a AccommodationApplication
     *   }
     * })
     * 
     */
    create<T extends AccommodationApplicationCreateArgs>(args: SelectSubset<T, AccommodationApplicationCreateArgs<ExtArgs>>): Prisma__AccommodationApplicationClient<$Result.GetResult<Prisma.$AccommodationApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccommodationApplications.
     * @param {AccommodationApplicationCreateManyArgs} args - Arguments to create many AccommodationApplications.
     * @example
     * // Create many AccommodationApplications
     * const accommodationApplication = await prisma.accommodationApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccommodationApplicationCreateManyArgs>(args?: SelectSubset<T, AccommodationApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccommodationApplications and returns the data saved in the database.
     * @param {AccommodationApplicationCreateManyAndReturnArgs} args - Arguments to create many AccommodationApplications.
     * @example
     * // Create many AccommodationApplications
     * const accommodationApplication = await prisma.accommodationApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccommodationApplications and only return the `id`
     * const accommodationApplicationWithIdOnly = await prisma.accommodationApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccommodationApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, AccommodationApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccommodationApplication.
     * @param {AccommodationApplicationDeleteArgs} args - Arguments to delete one AccommodationApplication.
     * @example
     * // Delete one AccommodationApplication
     * const AccommodationApplication = await prisma.accommodationApplication.delete({
     *   where: {
     *     // ... filter to delete one AccommodationApplication
     *   }
     * })
     * 
     */
    delete<T extends AccommodationApplicationDeleteArgs>(args: SelectSubset<T, AccommodationApplicationDeleteArgs<ExtArgs>>): Prisma__AccommodationApplicationClient<$Result.GetResult<Prisma.$AccommodationApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccommodationApplication.
     * @param {AccommodationApplicationUpdateArgs} args - Arguments to update one AccommodationApplication.
     * @example
     * // Update one AccommodationApplication
     * const accommodationApplication = await prisma.accommodationApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccommodationApplicationUpdateArgs>(args: SelectSubset<T, AccommodationApplicationUpdateArgs<ExtArgs>>): Prisma__AccommodationApplicationClient<$Result.GetResult<Prisma.$AccommodationApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccommodationApplications.
     * @param {AccommodationApplicationDeleteManyArgs} args - Arguments to filter AccommodationApplications to delete.
     * @example
     * // Delete a few AccommodationApplications
     * const { count } = await prisma.accommodationApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccommodationApplicationDeleteManyArgs>(args?: SelectSubset<T, AccommodationApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccommodationApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccommodationApplications
     * const accommodationApplication = await prisma.accommodationApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccommodationApplicationUpdateManyArgs>(args: SelectSubset<T, AccommodationApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccommodationApplications and returns the data updated in the database.
     * @param {AccommodationApplicationUpdateManyAndReturnArgs} args - Arguments to update many AccommodationApplications.
     * @example
     * // Update many AccommodationApplications
     * const accommodationApplication = await prisma.accommodationApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccommodationApplications and only return the `id`
     * const accommodationApplicationWithIdOnly = await prisma.accommodationApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccommodationApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, AccommodationApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccommodationApplication.
     * @param {AccommodationApplicationUpsertArgs} args - Arguments to update or create a AccommodationApplication.
     * @example
     * // Update or create a AccommodationApplication
     * const accommodationApplication = await prisma.accommodationApplication.upsert({
     *   create: {
     *     // ... data to create a AccommodationApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccommodationApplication we want to update
     *   }
     * })
     */
    upsert<T extends AccommodationApplicationUpsertArgs>(args: SelectSubset<T, AccommodationApplicationUpsertArgs<ExtArgs>>): Prisma__AccommodationApplicationClient<$Result.GetResult<Prisma.$AccommodationApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccommodationApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationApplicationCountArgs} args - Arguments to filter AccommodationApplications to count.
     * @example
     * // Count the number of AccommodationApplications
     * const count = await prisma.accommodationApplication.count({
     *   where: {
     *     // ... the filter for the AccommodationApplications we want to count
     *   }
     * })
    **/
    count<T extends AccommodationApplicationCountArgs>(
      args?: Subset<T, AccommodationApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccommodationApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccommodationApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccommodationApplicationAggregateArgs>(args: Subset<T, AccommodationApplicationAggregateArgs>): Prisma.PrismaPromise<GetAccommodationApplicationAggregateType<T>>

    /**
     * Group by AccommodationApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccommodationApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccommodationApplicationGroupByArgs['orderBy'] }
        : { orderBy?: AccommodationApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccommodationApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccommodationApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccommodationApplication model
   */
  readonly fields: AccommodationApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccommodationApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccommodationApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccommodationApplication model
   */
  interface AccommodationApplicationFieldRefs {
    readonly id: FieldRef<"AccommodationApplication", 'String'>
    readonly userId: FieldRef<"AccommodationApplication", 'String'>
    readonly accommodationId: FieldRef<"AccommodationApplication", 'String'>
    readonly interestedFrom: FieldRef<"AccommodationApplication", 'DateTime'>
    readonly interestedTill: FieldRef<"AccommodationApplication", 'DateTime'>
    readonly numberOfOccupants: FieldRef<"AccommodationApplication", 'Int'>
    readonly additionalNotes: FieldRef<"AccommodationApplication", 'String'>
    readonly status: FieldRef<"AccommodationApplication", 'ApplicationStatus'>
    readonly createdAt: FieldRef<"AccommodationApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccommodationApplication findUnique
   */
  export type AccommodationApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationApplication
     */
    select?: AccommodationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationApplication
     */
    omit?: AccommodationApplicationOmit<ExtArgs> | null
    /**
     * Filter, which AccommodationApplication to fetch.
     */
    where: AccommodationApplicationWhereUniqueInput
  }

  /**
   * AccommodationApplication findUniqueOrThrow
   */
  export type AccommodationApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationApplication
     */
    select?: AccommodationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationApplication
     */
    omit?: AccommodationApplicationOmit<ExtArgs> | null
    /**
     * Filter, which AccommodationApplication to fetch.
     */
    where: AccommodationApplicationWhereUniqueInput
  }

  /**
   * AccommodationApplication findFirst
   */
  export type AccommodationApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationApplication
     */
    select?: AccommodationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationApplication
     */
    omit?: AccommodationApplicationOmit<ExtArgs> | null
    /**
     * Filter, which AccommodationApplication to fetch.
     */
    where?: AccommodationApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationApplications to fetch.
     */
    orderBy?: AccommodationApplicationOrderByWithRelationInput | AccommodationApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccommodationApplications.
     */
    cursor?: AccommodationApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccommodationApplications.
     */
    distinct?: AccommodationApplicationScalarFieldEnum | AccommodationApplicationScalarFieldEnum[]
  }

  /**
   * AccommodationApplication findFirstOrThrow
   */
  export type AccommodationApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationApplication
     */
    select?: AccommodationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationApplication
     */
    omit?: AccommodationApplicationOmit<ExtArgs> | null
    /**
     * Filter, which AccommodationApplication to fetch.
     */
    where?: AccommodationApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationApplications to fetch.
     */
    orderBy?: AccommodationApplicationOrderByWithRelationInput | AccommodationApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccommodationApplications.
     */
    cursor?: AccommodationApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccommodationApplications.
     */
    distinct?: AccommodationApplicationScalarFieldEnum | AccommodationApplicationScalarFieldEnum[]
  }

  /**
   * AccommodationApplication findMany
   */
  export type AccommodationApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationApplication
     */
    select?: AccommodationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationApplication
     */
    omit?: AccommodationApplicationOmit<ExtArgs> | null
    /**
     * Filter, which AccommodationApplications to fetch.
     */
    where?: AccommodationApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationApplications to fetch.
     */
    orderBy?: AccommodationApplicationOrderByWithRelationInput | AccommodationApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccommodationApplications.
     */
    cursor?: AccommodationApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationApplications.
     */
    skip?: number
    distinct?: AccommodationApplicationScalarFieldEnum | AccommodationApplicationScalarFieldEnum[]
  }

  /**
   * AccommodationApplication create
   */
  export type AccommodationApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationApplication
     */
    select?: AccommodationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationApplication
     */
    omit?: AccommodationApplicationOmit<ExtArgs> | null
    /**
     * The data needed to create a AccommodationApplication.
     */
    data: XOR<AccommodationApplicationCreateInput, AccommodationApplicationUncheckedCreateInput>
  }

  /**
   * AccommodationApplication createMany
   */
  export type AccommodationApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccommodationApplications.
     */
    data: AccommodationApplicationCreateManyInput | AccommodationApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccommodationApplication createManyAndReturn
   */
  export type AccommodationApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationApplication
     */
    select?: AccommodationApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationApplication
     */
    omit?: AccommodationApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many AccommodationApplications.
     */
    data: AccommodationApplicationCreateManyInput | AccommodationApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccommodationApplication update
   */
  export type AccommodationApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationApplication
     */
    select?: AccommodationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationApplication
     */
    omit?: AccommodationApplicationOmit<ExtArgs> | null
    /**
     * The data needed to update a AccommodationApplication.
     */
    data: XOR<AccommodationApplicationUpdateInput, AccommodationApplicationUncheckedUpdateInput>
    /**
     * Choose, which AccommodationApplication to update.
     */
    where: AccommodationApplicationWhereUniqueInput
  }

  /**
   * AccommodationApplication updateMany
   */
  export type AccommodationApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccommodationApplications.
     */
    data: XOR<AccommodationApplicationUpdateManyMutationInput, AccommodationApplicationUncheckedUpdateManyInput>
    /**
     * Filter which AccommodationApplications to update
     */
    where?: AccommodationApplicationWhereInput
    /**
     * Limit how many AccommodationApplications to update.
     */
    limit?: number
  }

  /**
   * AccommodationApplication updateManyAndReturn
   */
  export type AccommodationApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationApplication
     */
    select?: AccommodationApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationApplication
     */
    omit?: AccommodationApplicationOmit<ExtArgs> | null
    /**
     * The data used to update AccommodationApplications.
     */
    data: XOR<AccommodationApplicationUpdateManyMutationInput, AccommodationApplicationUncheckedUpdateManyInput>
    /**
     * Filter which AccommodationApplications to update
     */
    where?: AccommodationApplicationWhereInput
    /**
     * Limit how many AccommodationApplications to update.
     */
    limit?: number
  }

  /**
   * AccommodationApplication upsert
   */
  export type AccommodationApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationApplication
     */
    select?: AccommodationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationApplication
     */
    omit?: AccommodationApplicationOmit<ExtArgs> | null
    /**
     * The filter to search for the AccommodationApplication to update in case it exists.
     */
    where: AccommodationApplicationWhereUniqueInput
    /**
     * In case the AccommodationApplication found by the `where` argument doesn't exist, create a new AccommodationApplication with this data.
     */
    create: XOR<AccommodationApplicationCreateInput, AccommodationApplicationUncheckedCreateInput>
    /**
     * In case the AccommodationApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccommodationApplicationUpdateInput, AccommodationApplicationUncheckedUpdateInput>
  }

  /**
   * AccommodationApplication delete
   */
  export type AccommodationApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationApplication
     */
    select?: AccommodationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationApplication
     */
    omit?: AccommodationApplicationOmit<ExtArgs> | null
    /**
     * Filter which AccommodationApplication to delete.
     */
    where: AccommodationApplicationWhereUniqueInput
  }

  /**
   * AccommodationApplication deleteMany
   */
  export type AccommodationApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccommodationApplications to delete
     */
    where?: AccommodationApplicationWhereInput
    /**
     * Limit how many AccommodationApplications to delete.
     */
    limit?: number
  }

  /**
   * AccommodationApplication without action
   */
  export type AccommodationApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationApplication
     */
    select?: AccommodationApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationApplication
     */
    omit?: AccommodationApplicationOmit<ExtArgs> | null
  }


  /**
   * Model AccommodationReview
   */

  export type AggregateAccommodationReview = {
    _count: AccommodationReviewCountAggregateOutputType | null
    _avg: AccommodationReviewAvgAggregateOutputType | null
    _sum: AccommodationReviewSumAggregateOutputType | null
    _min: AccommodationReviewMinAggregateOutputType | null
    _max: AccommodationReviewMaxAggregateOutputType | null
  }

  export type AccommodationReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type AccommodationReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type AccommodationReviewMinAggregateOutputType = {
    id: string | null
    rating: number | null
    review: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accommodationId: string | null
    userId: string | null
  }

  export type AccommodationReviewMaxAggregateOutputType = {
    id: string | null
    rating: number | null
    review: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accommodationId: string | null
    userId: string | null
  }

  export type AccommodationReviewCountAggregateOutputType = {
    id: number
    rating: number
    review: number
    createdAt: number
    updatedAt: number
    accommodationId: number
    userId: number
    _all: number
  }


  export type AccommodationReviewAvgAggregateInputType = {
    rating?: true
  }

  export type AccommodationReviewSumAggregateInputType = {
    rating?: true
  }

  export type AccommodationReviewMinAggregateInputType = {
    id?: true
    rating?: true
    review?: true
    createdAt?: true
    updatedAt?: true
    accommodationId?: true
    userId?: true
  }

  export type AccommodationReviewMaxAggregateInputType = {
    id?: true
    rating?: true
    review?: true
    createdAt?: true
    updatedAt?: true
    accommodationId?: true
    userId?: true
  }

  export type AccommodationReviewCountAggregateInputType = {
    id?: true
    rating?: true
    review?: true
    createdAt?: true
    updatedAt?: true
    accommodationId?: true
    userId?: true
    _all?: true
  }

  export type AccommodationReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccommodationReview to aggregate.
     */
    where?: AccommodationReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationReviews to fetch.
     */
    orderBy?: AccommodationReviewOrderByWithRelationInput | AccommodationReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccommodationReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccommodationReviews
    **/
    _count?: true | AccommodationReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccommodationReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccommodationReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccommodationReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccommodationReviewMaxAggregateInputType
  }

  export type GetAccommodationReviewAggregateType<T extends AccommodationReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateAccommodationReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccommodationReview[P]>
      : GetScalarType<T[P], AggregateAccommodationReview[P]>
  }




  export type AccommodationReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccommodationReviewWhereInput
    orderBy?: AccommodationReviewOrderByWithAggregationInput | AccommodationReviewOrderByWithAggregationInput[]
    by: AccommodationReviewScalarFieldEnum[] | AccommodationReviewScalarFieldEnum
    having?: AccommodationReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccommodationReviewCountAggregateInputType | true
    _avg?: AccommodationReviewAvgAggregateInputType
    _sum?: AccommodationReviewSumAggregateInputType
    _min?: AccommodationReviewMinAggregateInputType
    _max?: AccommodationReviewMaxAggregateInputType
  }

  export type AccommodationReviewGroupByOutputType = {
    id: string
    rating: number
    review: string
    createdAt: Date
    updatedAt: Date
    accommodationId: string
    userId: string
    _count: AccommodationReviewCountAggregateOutputType | null
    _avg: AccommodationReviewAvgAggregateOutputType | null
    _sum: AccommodationReviewSumAggregateOutputType | null
    _min: AccommodationReviewMinAggregateOutputType | null
    _max: AccommodationReviewMaxAggregateOutputType | null
  }

  type GetAccommodationReviewGroupByPayload<T extends AccommodationReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccommodationReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccommodationReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccommodationReviewGroupByOutputType[P]>
            : GetScalarType<T[P], AccommodationReviewGroupByOutputType[P]>
        }
      >
    >


  export type AccommodationReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    review?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accommodationId?: boolean
    userId?: boolean
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accommodationReview"]>

  export type AccommodationReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    review?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accommodationId?: boolean
    userId?: boolean
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accommodationReview"]>

  export type AccommodationReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    review?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accommodationId?: boolean
    userId?: boolean
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accommodationReview"]>

  export type AccommodationReviewSelectScalar = {
    id?: boolean
    rating?: boolean
    review?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accommodationId?: boolean
    userId?: boolean
  }

  export type AccommodationReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rating" | "review" | "createdAt" | "updatedAt" | "accommodationId" | "userId", ExtArgs["result"]["accommodationReview"]>
  export type AccommodationReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccommodationReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccommodationReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccommodationReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccommodationReview"
    objects: {
      accommodation: Prisma.$AccommodationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rating: number
      review: string
      createdAt: Date
      updatedAt: Date
      accommodationId: string
      userId: string
    }, ExtArgs["result"]["accommodationReview"]>
    composites: {}
  }

  type AccommodationReviewGetPayload<S extends boolean | null | undefined | AccommodationReviewDefaultArgs> = $Result.GetResult<Prisma.$AccommodationReviewPayload, S>

  type AccommodationReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccommodationReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccommodationReviewCountAggregateInputType | true
    }

  export interface AccommodationReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccommodationReview'], meta: { name: 'AccommodationReview' } }
    /**
     * Find zero or one AccommodationReview that matches the filter.
     * @param {AccommodationReviewFindUniqueArgs} args - Arguments to find a AccommodationReview
     * @example
     * // Get one AccommodationReview
     * const accommodationReview = await prisma.accommodationReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccommodationReviewFindUniqueArgs>(args: SelectSubset<T, AccommodationReviewFindUniqueArgs<ExtArgs>>): Prisma__AccommodationReviewClient<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccommodationReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccommodationReviewFindUniqueOrThrowArgs} args - Arguments to find a AccommodationReview
     * @example
     * // Get one AccommodationReview
     * const accommodationReview = await prisma.accommodationReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccommodationReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, AccommodationReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccommodationReviewClient<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccommodationReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationReviewFindFirstArgs} args - Arguments to find a AccommodationReview
     * @example
     * // Get one AccommodationReview
     * const accommodationReview = await prisma.accommodationReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccommodationReviewFindFirstArgs>(args?: SelectSubset<T, AccommodationReviewFindFirstArgs<ExtArgs>>): Prisma__AccommodationReviewClient<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccommodationReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationReviewFindFirstOrThrowArgs} args - Arguments to find a AccommodationReview
     * @example
     * // Get one AccommodationReview
     * const accommodationReview = await prisma.accommodationReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccommodationReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, AccommodationReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccommodationReviewClient<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccommodationReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccommodationReviews
     * const accommodationReviews = await prisma.accommodationReview.findMany()
     * 
     * // Get first 10 AccommodationReviews
     * const accommodationReviews = await prisma.accommodationReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accommodationReviewWithIdOnly = await prisma.accommodationReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccommodationReviewFindManyArgs>(args?: SelectSubset<T, AccommodationReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccommodationReview.
     * @param {AccommodationReviewCreateArgs} args - Arguments to create a AccommodationReview.
     * @example
     * // Create one AccommodationReview
     * const AccommodationReview = await prisma.accommodationReview.create({
     *   data: {
     *     // ... data to create a AccommodationReview
     *   }
     * })
     * 
     */
    create<T extends AccommodationReviewCreateArgs>(args: SelectSubset<T, AccommodationReviewCreateArgs<ExtArgs>>): Prisma__AccommodationReviewClient<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccommodationReviews.
     * @param {AccommodationReviewCreateManyArgs} args - Arguments to create many AccommodationReviews.
     * @example
     * // Create many AccommodationReviews
     * const accommodationReview = await prisma.accommodationReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccommodationReviewCreateManyArgs>(args?: SelectSubset<T, AccommodationReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccommodationReviews and returns the data saved in the database.
     * @param {AccommodationReviewCreateManyAndReturnArgs} args - Arguments to create many AccommodationReviews.
     * @example
     * // Create many AccommodationReviews
     * const accommodationReview = await prisma.accommodationReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccommodationReviews and only return the `id`
     * const accommodationReviewWithIdOnly = await prisma.accommodationReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccommodationReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, AccommodationReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccommodationReview.
     * @param {AccommodationReviewDeleteArgs} args - Arguments to delete one AccommodationReview.
     * @example
     * // Delete one AccommodationReview
     * const AccommodationReview = await prisma.accommodationReview.delete({
     *   where: {
     *     // ... filter to delete one AccommodationReview
     *   }
     * })
     * 
     */
    delete<T extends AccommodationReviewDeleteArgs>(args: SelectSubset<T, AccommodationReviewDeleteArgs<ExtArgs>>): Prisma__AccommodationReviewClient<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccommodationReview.
     * @param {AccommodationReviewUpdateArgs} args - Arguments to update one AccommodationReview.
     * @example
     * // Update one AccommodationReview
     * const accommodationReview = await prisma.accommodationReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccommodationReviewUpdateArgs>(args: SelectSubset<T, AccommodationReviewUpdateArgs<ExtArgs>>): Prisma__AccommodationReviewClient<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccommodationReviews.
     * @param {AccommodationReviewDeleteManyArgs} args - Arguments to filter AccommodationReviews to delete.
     * @example
     * // Delete a few AccommodationReviews
     * const { count } = await prisma.accommodationReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccommodationReviewDeleteManyArgs>(args?: SelectSubset<T, AccommodationReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccommodationReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccommodationReviews
     * const accommodationReview = await prisma.accommodationReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccommodationReviewUpdateManyArgs>(args: SelectSubset<T, AccommodationReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccommodationReviews and returns the data updated in the database.
     * @param {AccommodationReviewUpdateManyAndReturnArgs} args - Arguments to update many AccommodationReviews.
     * @example
     * // Update many AccommodationReviews
     * const accommodationReview = await prisma.accommodationReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccommodationReviews and only return the `id`
     * const accommodationReviewWithIdOnly = await prisma.accommodationReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccommodationReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, AccommodationReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccommodationReview.
     * @param {AccommodationReviewUpsertArgs} args - Arguments to update or create a AccommodationReview.
     * @example
     * // Update or create a AccommodationReview
     * const accommodationReview = await prisma.accommodationReview.upsert({
     *   create: {
     *     // ... data to create a AccommodationReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccommodationReview we want to update
     *   }
     * })
     */
    upsert<T extends AccommodationReviewUpsertArgs>(args: SelectSubset<T, AccommodationReviewUpsertArgs<ExtArgs>>): Prisma__AccommodationReviewClient<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccommodationReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationReviewCountArgs} args - Arguments to filter AccommodationReviews to count.
     * @example
     * // Count the number of AccommodationReviews
     * const count = await prisma.accommodationReview.count({
     *   where: {
     *     // ... the filter for the AccommodationReviews we want to count
     *   }
     * })
    **/
    count<T extends AccommodationReviewCountArgs>(
      args?: Subset<T, AccommodationReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccommodationReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccommodationReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccommodationReviewAggregateArgs>(args: Subset<T, AccommodationReviewAggregateArgs>): Prisma.PrismaPromise<GetAccommodationReviewAggregateType<T>>

    /**
     * Group by AccommodationReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccommodationReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccommodationReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccommodationReviewGroupByArgs['orderBy'] }
        : { orderBy?: AccommodationReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccommodationReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccommodationReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccommodationReview model
   */
  readonly fields: AccommodationReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccommodationReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccommodationReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accommodation<T extends AccommodationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccommodationDefaultArgs<ExtArgs>>): Prisma__AccommodationClient<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccommodationReview model
   */
  interface AccommodationReviewFieldRefs {
    readonly id: FieldRef<"AccommodationReview", 'String'>
    readonly rating: FieldRef<"AccommodationReview", 'Float'>
    readonly review: FieldRef<"AccommodationReview", 'String'>
    readonly createdAt: FieldRef<"AccommodationReview", 'DateTime'>
    readonly updatedAt: FieldRef<"AccommodationReview", 'DateTime'>
    readonly accommodationId: FieldRef<"AccommodationReview", 'String'>
    readonly userId: FieldRef<"AccommodationReview", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccommodationReview findUnique
   */
  export type AccommodationReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationReview to fetch.
     */
    where: AccommodationReviewWhereUniqueInput
  }

  /**
   * AccommodationReview findUniqueOrThrow
   */
  export type AccommodationReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationReview to fetch.
     */
    where: AccommodationReviewWhereUniqueInput
  }

  /**
   * AccommodationReview findFirst
   */
  export type AccommodationReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationReview to fetch.
     */
    where?: AccommodationReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationReviews to fetch.
     */
    orderBy?: AccommodationReviewOrderByWithRelationInput | AccommodationReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccommodationReviews.
     */
    cursor?: AccommodationReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccommodationReviews.
     */
    distinct?: AccommodationReviewScalarFieldEnum | AccommodationReviewScalarFieldEnum[]
  }

  /**
   * AccommodationReview findFirstOrThrow
   */
  export type AccommodationReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationReview to fetch.
     */
    where?: AccommodationReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationReviews to fetch.
     */
    orderBy?: AccommodationReviewOrderByWithRelationInput | AccommodationReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccommodationReviews.
     */
    cursor?: AccommodationReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccommodationReviews.
     */
    distinct?: AccommodationReviewScalarFieldEnum | AccommodationReviewScalarFieldEnum[]
  }

  /**
   * AccommodationReview findMany
   */
  export type AccommodationReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewInclude<ExtArgs> | null
    /**
     * Filter, which AccommodationReviews to fetch.
     */
    where?: AccommodationReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccommodationReviews to fetch.
     */
    orderBy?: AccommodationReviewOrderByWithRelationInput | AccommodationReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccommodationReviews.
     */
    cursor?: AccommodationReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccommodationReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccommodationReviews.
     */
    skip?: number
    distinct?: AccommodationReviewScalarFieldEnum | AccommodationReviewScalarFieldEnum[]
  }

  /**
   * AccommodationReview create
   */
  export type AccommodationReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a AccommodationReview.
     */
    data: XOR<AccommodationReviewCreateInput, AccommodationReviewUncheckedCreateInput>
  }

  /**
   * AccommodationReview createMany
   */
  export type AccommodationReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccommodationReviews.
     */
    data: AccommodationReviewCreateManyInput | AccommodationReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccommodationReview createManyAndReturn
   */
  export type AccommodationReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * The data used to create many AccommodationReviews.
     */
    data: AccommodationReviewCreateManyInput | AccommodationReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccommodationReview update
   */
  export type AccommodationReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a AccommodationReview.
     */
    data: XOR<AccommodationReviewUpdateInput, AccommodationReviewUncheckedUpdateInput>
    /**
     * Choose, which AccommodationReview to update.
     */
    where: AccommodationReviewWhereUniqueInput
  }

  /**
   * AccommodationReview updateMany
   */
  export type AccommodationReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccommodationReviews.
     */
    data: XOR<AccommodationReviewUpdateManyMutationInput, AccommodationReviewUncheckedUpdateManyInput>
    /**
     * Filter which AccommodationReviews to update
     */
    where?: AccommodationReviewWhereInput
    /**
     * Limit how many AccommodationReviews to update.
     */
    limit?: number
  }

  /**
   * AccommodationReview updateManyAndReturn
   */
  export type AccommodationReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * The data used to update AccommodationReviews.
     */
    data: XOR<AccommodationReviewUpdateManyMutationInput, AccommodationReviewUncheckedUpdateManyInput>
    /**
     * Filter which AccommodationReviews to update
     */
    where?: AccommodationReviewWhereInput
    /**
     * Limit how many AccommodationReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccommodationReview upsert
   */
  export type AccommodationReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the AccommodationReview to update in case it exists.
     */
    where: AccommodationReviewWhereUniqueInput
    /**
     * In case the AccommodationReview found by the `where` argument doesn't exist, create a new AccommodationReview with this data.
     */
    create: XOR<AccommodationReviewCreateInput, AccommodationReviewUncheckedCreateInput>
    /**
     * In case the AccommodationReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccommodationReviewUpdateInput, AccommodationReviewUncheckedUpdateInput>
  }

  /**
   * AccommodationReview delete
   */
  export type AccommodationReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewInclude<ExtArgs> | null
    /**
     * Filter which AccommodationReview to delete.
     */
    where: AccommodationReviewWhereUniqueInput
  }

  /**
   * AccommodationReview deleteMany
   */
  export type AccommodationReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccommodationReviews to delete
     */
    where?: AccommodationReviewWhereInput
    /**
     * Limit how many AccommodationReviews to delete.
     */
    limit?: number
  }

  /**
   * AccommodationReview without action
   */
  export type AccommodationReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    isRead: boolean | null
    senderId: string | null
    receiverId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    isRead: boolean | null
    senderId: string | null
    receiverId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    attachments: number
    isRead: number
    senderId: number
    receiverId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    isRead?: true
    senderId?: true
    receiverId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    isRead?: true
    senderId?: true
    receiverId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    attachments?: true
    isRead?: true
    senderId?: true
    receiverId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string
    attachments: string[]
    isRead: boolean
    senderId: string
    receiverId: string
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    attachments?: boolean
    isRead?: boolean
    senderId?: boolean
    receiverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    attachments?: boolean
    isRead?: boolean
    senderId?: boolean
    receiverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    attachments?: boolean
    isRead?: boolean
    senderId?: boolean
    receiverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    attachments?: boolean
    isRead?: boolean
    senderId?: boolean
    receiverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "attachments" | "isRead" | "senderId" | "receiverId" | "createdAt" | "updatedAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      attachments: string[]
      isRead: boolean
      senderId: string
      receiverId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly attachments: FieldRef<"Message", 'String[]'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly receiverId: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowMaxAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowCountAggregateOutputType = {
    id: number
    followerId: number
    followingId: number
    createdAt: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowMaxAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowCountAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    id: string
    followerId: string
    followingId: string
    createdAt: Date
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectScalar = {
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
  }

  export type FollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followerId" | "followingId" | "createdAt", ExtArgs["result"]["follow"]>
  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FollowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerId: string
      followingId: string
      createdAt: Date
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followWithIdOnly = await prisma.follow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {FollowCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows and returns the data updated in the database.
     * @param {FollowUpdateManyAndReturnArgs} args - Arguments to update many Follows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */
  interface FollowFieldRefs {
    readonly id: FieldRef<"Follow", 'String'>
    readonly followerId: FieldRef<"Follow", 'String'>
    readonly followingId: FieldRef<"Follow", 'String'>
    readonly createdAt: FieldRef<"Follow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Follow createManyAndReturn
   */
  export type FollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
  }

  /**
   * Follow updateManyAndReturn
   */
  export type FollowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to delete.
     */
    limit?: number
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model Loan
   */

  export type AggregateLoan = {
    _count: LoanCountAggregateOutputType | null
    _avg: LoanAvgAggregateOutputType | null
    _sum: LoanSumAggregateOutputType | null
    _min: LoanMinAggregateOutputType | null
    _max: LoanMaxAggregateOutputType | null
  }

  export type LoanAvgAggregateOutputType = {
    amount: number | null
    interestRate: number | null
    duration: number | null
    maxApplications: number | null
  }

  export type LoanSumAggregateOutputType = {
    amount: number | null
    interestRate: number | null
    duration: number | null
    maxApplications: number | null
  }

  export type LoanMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    amount: number | null
    interestRate: number | null
    duration: number | null
    deadline: Date | null
    maxApplications: number | null
    isActive: boolean | null
    universityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    amount: number | null
    interestRate: number | null
    duration: number | null
    deadline: Date | null
    maxApplications: number | null
    isActive: boolean | null
    universityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanCountAggregateOutputType = {
    id: number
    title: number
    description: number
    amount: number
    interestRate: number
    duration: number
    eligibilityCriteria: number
    documents: number
    deadline: number
    maxApplications: number
    isActive: number
    universityId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoanAvgAggregateInputType = {
    amount?: true
    interestRate?: true
    duration?: true
    maxApplications?: true
  }

  export type LoanSumAggregateInputType = {
    amount?: true
    interestRate?: true
    duration?: true
    maxApplications?: true
  }

  export type LoanMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    amount?: true
    interestRate?: true
    duration?: true
    deadline?: true
    maxApplications?: true
    isActive?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    amount?: true
    interestRate?: true
    duration?: true
    deadline?: true
    maxApplications?: true
    isActive?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    amount?: true
    interestRate?: true
    duration?: true
    eligibilityCriteria?: true
    documents?: true
    deadline?: true
    maxApplications?: true
    isActive?: true
    universityId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loan to aggregate.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loans
    **/
    _count?: true | LoanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanMaxAggregateInputType
  }

  export type GetLoanAggregateType<T extends LoanAggregateArgs> = {
        [P in keyof T & keyof AggregateLoan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoan[P]>
      : GetScalarType<T[P], AggregateLoan[P]>
  }




  export type LoanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanWhereInput
    orderBy?: LoanOrderByWithAggregationInput | LoanOrderByWithAggregationInput[]
    by: LoanScalarFieldEnum[] | LoanScalarFieldEnum
    having?: LoanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanCountAggregateInputType | true
    _avg?: LoanAvgAggregateInputType
    _sum?: LoanSumAggregateInputType
    _min?: LoanMinAggregateInputType
    _max?: LoanMaxAggregateInputType
  }

  export type LoanGroupByOutputType = {
    id: string
    title: string
    description: string
    amount: number
    interestRate: number
    duration: number
    eligibilityCriteria: string[]
    documents: string[]
    deadline: Date | null
    maxApplications: number | null
    isActive: boolean
    universityId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LoanCountAggregateOutputType | null
    _avg: LoanAvgAggregateOutputType | null
    _sum: LoanSumAggregateOutputType | null
    _min: LoanMinAggregateOutputType | null
    _max: LoanMaxAggregateOutputType | null
  }

  type GetLoanGroupByPayload<T extends LoanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanGroupByOutputType[P]>
            : GetScalarType<T[P], LoanGroupByOutputType[P]>
        }
      >
    >


  export type LoanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    interestRate?: boolean
    duration?: boolean
    eligibilityCriteria?: boolean
    documents?: boolean
    deadline?: boolean
    maxApplications?: boolean
    isActive?: boolean
    universityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    university?: boolean | Loan$universityArgs<ExtArgs>
    applications?: boolean | Loan$applicationsArgs<ExtArgs>
    _count?: boolean | LoanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loan"]>

  export type LoanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    interestRate?: boolean
    duration?: boolean
    eligibilityCriteria?: boolean
    documents?: boolean
    deadline?: boolean
    maxApplications?: boolean
    isActive?: boolean
    universityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    university?: boolean | Loan$universityArgs<ExtArgs>
  }, ExtArgs["result"]["loan"]>

  export type LoanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    interestRate?: boolean
    duration?: boolean
    eligibilityCriteria?: boolean
    documents?: boolean
    deadline?: boolean
    maxApplications?: boolean
    isActive?: boolean
    universityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    university?: boolean | Loan$universityArgs<ExtArgs>
  }, ExtArgs["result"]["loan"]>

  export type LoanSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    interestRate?: boolean
    duration?: boolean
    eligibilityCriteria?: boolean
    documents?: boolean
    deadline?: boolean
    maxApplications?: boolean
    isActive?: boolean
    universityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "amount" | "interestRate" | "duration" | "eligibilityCriteria" | "documents" | "deadline" | "maxApplications" | "isActive" | "universityId" | "createdAt" | "updatedAt", ExtArgs["result"]["loan"]>
  export type LoanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | Loan$universityArgs<ExtArgs>
    applications?: boolean | Loan$applicationsArgs<ExtArgs>
    _count?: boolean | LoanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LoanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | Loan$universityArgs<ExtArgs>
  }
  export type LoanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | Loan$universityArgs<ExtArgs>
  }

  export type $LoanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Loan"
    objects: {
      university: Prisma.$UniversityPayload<ExtArgs> | null
      applications: Prisma.$LoanApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      amount: number
      interestRate: number
      duration: number
      eligibilityCriteria: string[]
      documents: string[]
      deadline: Date | null
      maxApplications: number | null
      isActive: boolean
      universityId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loan"]>
    composites: {}
  }

  type LoanGetPayload<S extends boolean | null | undefined | LoanDefaultArgs> = $Result.GetResult<Prisma.$LoanPayload, S>

  type LoanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoanCountAggregateInputType | true
    }

  export interface LoanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Loan'], meta: { name: 'Loan' } }
    /**
     * Find zero or one Loan that matches the filter.
     * @param {LoanFindUniqueArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanFindUniqueArgs>(args: SelectSubset<T, LoanFindUniqueArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Loan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoanFindUniqueOrThrowArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindFirstArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanFindFirstArgs>(args?: SelectSubset<T, LoanFindFirstArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindFirstOrThrowArgs} args - Arguments to find a Loan
     * @example
     * // Get one Loan
     * const loan = await prisma.loan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Loans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loans
     * const loans = await prisma.loan.findMany()
     * 
     * // Get first 10 Loans
     * const loans = await prisma.loan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanWithIdOnly = await prisma.loan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanFindManyArgs>(args?: SelectSubset<T, LoanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Loan.
     * @param {LoanCreateArgs} args - Arguments to create a Loan.
     * @example
     * // Create one Loan
     * const Loan = await prisma.loan.create({
     *   data: {
     *     // ... data to create a Loan
     *   }
     * })
     * 
     */
    create<T extends LoanCreateArgs>(args: SelectSubset<T, LoanCreateArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Loans.
     * @param {LoanCreateManyArgs} args - Arguments to create many Loans.
     * @example
     * // Create many Loans
     * const loan = await prisma.loan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanCreateManyArgs>(args?: SelectSubset<T, LoanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Loans and returns the data saved in the database.
     * @param {LoanCreateManyAndReturnArgs} args - Arguments to create many Loans.
     * @example
     * // Create many Loans
     * const loan = await prisma.loan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Loans and only return the `id`
     * const loanWithIdOnly = await prisma.loan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Loan.
     * @param {LoanDeleteArgs} args - Arguments to delete one Loan.
     * @example
     * // Delete one Loan
     * const Loan = await prisma.loan.delete({
     *   where: {
     *     // ... filter to delete one Loan
     *   }
     * })
     * 
     */
    delete<T extends LoanDeleteArgs>(args: SelectSubset<T, LoanDeleteArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Loan.
     * @param {LoanUpdateArgs} args - Arguments to update one Loan.
     * @example
     * // Update one Loan
     * const loan = await prisma.loan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanUpdateArgs>(args: SelectSubset<T, LoanUpdateArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Loans.
     * @param {LoanDeleteManyArgs} args - Arguments to filter Loans to delete.
     * @example
     * // Delete a few Loans
     * const { count } = await prisma.loan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanDeleteManyArgs>(args?: SelectSubset<T, LoanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loans
     * const loan = await prisma.loan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanUpdateManyArgs>(args: SelectSubset<T, LoanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loans and returns the data updated in the database.
     * @param {LoanUpdateManyAndReturnArgs} args - Arguments to update many Loans.
     * @example
     * // Update many Loans
     * const loan = await prisma.loan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Loans and only return the `id`
     * const loanWithIdOnly = await prisma.loan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoanUpdateManyAndReturnArgs>(args: SelectSubset<T, LoanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Loan.
     * @param {LoanUpsertArgs} args - Arguments to update or create a Loan.
     * @example
     * // Update or create a Loan
     * const loan = await prisma.loan.upsert({
     *   create: {
     *     // ... data to create a Loan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loan we want to update
     *   }
     * })
     */
    upsert<T extends LoanUpsertArgs>(args: SelectSubset<T, LoanUpsertArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanCountArgs} args - Arguments to filter Loans to count.
     * @example
     * // Count the number of Loans
     * const count = await prisma.loan.count({
     *   where: {
     *     // ... the filter for the Loans we want to count
     *   }
     * })
    **/
    count<T extends LoanCountArgs>(
      args?: Subset<T, LoanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanAggregateArgs>(args: Subset<T, LoanAggregateArgs>): Prisma.PrismaPromise<GetLoanAggregateType<T>>

    /**
     * Group by Loan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanGroupByArgs['orderBy'] }
        : { orderBy?: LoanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Loan model
   */
  readonly fields: LoanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Loan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    university<T extends Loan$universityArgs<ExtArgs> = {}>(args?: Subset<T, Loan$universityArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    applications<T extends Loan$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Loan$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Loan model
   */
  interface LoanFieldRefs {
    readonly id: FieldRef<"Loan", 'String'>
    readonly title: FieldRef<"Loan", 'String'>
    readonly description: FieldRef<"Loan", 'String'>
    readonly amount: FieldRef<"Loan", 'Float'>
    readonly interestRate: FieldRef<"Loan", 'Float'>
    readonly duration: FieldRef<"Loan", 'Int'>
    readonly eligibilityCriteria: FieldRef<"Loan", 'String[]'>
    readonly documents: FieldRef<"Loan", 'String[]'>
    readonly deadline: FieldRef<"Loan", 'DateTime'>
    readonly maxApplications: FieldRef<"Loan", 'Int'>
    readonly isActive: FieldRef<"Loan", 'Boolean'>
    readonly universityId: FieldRef<"Loan", 'String'>
    readonly createdAt: FieldRef<"Loan", 'DateTime'>
    readonly updatedAt: FieldRef<"Loan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Loan findUnique
   */
  export type LoanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan findUniqueOrThrow
   */
  export type LoanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan findFirst
   */
  export type LoanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loans.
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loans.
     */
    distinct?: LoanScalarFieldEnum | LoanScalarFieldEnum[]
  }

  /**
   * Loan findFirstOrThrow
   */
  export type LoanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loan to fetch.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loans.
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loans.
     */
    distinct?: LoanScalarFieldEnum | LoanScalarFieldEnum[]
  }

  /**
   * Loan findMany
   */
  export type LoanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter, which Loans to fetch.
     */
    where?: LoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loans to fetch.
     */
    orderBy?: LoanOrderByWithRelationInput | LoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loans.
     */
    cursor?: LoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loans.
     */
    skip?: number
    distinct?: LoanScalarFieldEnum | LoanScalarFieldEnum[]
  }

  /**
   * Loan create
   */
  export type LoanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * The data needed to create a Loan.
     */
    data: XOR<LoanCreateInput, LoanUncheckedCreateInput>
  }

  /**
   * Loan createMany
   */
  export type LoanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Loans.
     */
    data: LoanCreateManyInput | LoanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Loan createManyAndReturn
   */
  export type LoanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * The data used to create many Loans.
     */
    data: LoanCreateManyInput | LoanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Loan update
   */
  export type LoanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * The data needed to update a Loan.
     */
    data: XOR<LoanUpdateInput, LoanUncheckedUpdateInput>
    /**
     * Choose, which Loan to update.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan updateMany
   */
  export type LoanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Loans.
     */
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyInput>
    /**
     * Filter which Loans to update
     */
    where?: LoanWhereInput
    /**
     * Limit how many Loans to update.
     */
    limit?: number
  }

  /**
   * Loan updateManyAndReturn
   */
  export type LoanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * The data used to update Loans.
     */
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyInput>
    /**
     * Filter which Loans to update
     */
    where?: LoanWhereInput
    /**
     * Limit how many Loans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Loan upsert
   */
  export type LoanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * The filter to search for the Loan to update in case it exists.
     */
    where: LoanWhereUniqueInput
    /**
     * In case the Loan found by the `where` argument doesn't exist, create a new Loan with this data.
     */
    create: XOR<LoanCreateInput, LoanUncheckedCreateInput>
    /**
     * In case the Loan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanUpdateInput, LoanUncheckedUpdateInput>
  }

  /**
   * Loan delete
   */
  export type LoanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
    /**
     * Filter which Loan to delete.
     */
    where: LoanWhereUniqueInput
  }

  /**
   * Loan deleteMany
   */
  export type LoanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loans to delete
     */
    where?: LoanWhereInput
    /**
     * Limit how many Loans to delete.
     */
    limit?: number
  }

  /**
   * Loan.university
   */
  export type Loan$universityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInclude<ExtArgs> | null
    where?: UniversityWhereInput
  }

  /**
   * Loan.applications
   */
  export type Loan$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    where?: LoanApplicationWhereInput
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    cursor?: LoanApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoanApplicationScalarFieldEnum | LoanApplicationScalarFieldEnum[]
  }

  /**
   * Loan without action
   */
  export type LoanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loan
     */
    select?: LoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loan
     */
    omit?: LoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanInclude<ExtArgs> | null
  }


  /**
   * Model LoanApplication
   */

  export type AggregateLoanApplication = {
    _count: LoanApplicationCountAggregateOutputType | null
    _min: LoanApplicationMinAggregateOutputType | null
    _max: LoanApplicationMaxAggregateOutputType | null
  }

  export type LoanApplicationMinAggregateOutputType = {
    id: string | null
    status: $Enums.ApplicationStatus | null
    notes: string | null
    loanId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanApplicationMaxAggregateOutputType = {
    id: string | null
    status: $Enums.ApplicationStatus | null
    notes: string | null
    loanId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoanApplicationCountAggregateOutputType = {
    id: number
    status: number
    documents: number
    academicInfo: number
    financialInfo: number
    notes: number
    loanId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoanApplicationMinAggregateInputType = {
    id?: true
    status?: true
    notes?: true
    loanId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanApplicationMaxAggregateInputType = {
    id?: true
    status?: true
    notes?: true
    loanId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoanApplicationCountAggregateInputType = {
    id?: true
    status?: true
    documents?: true
    academicInfo?: true
    financialInfo?: true
    notes?: true
    loanId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoanApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanApplication to aggregate.
     */
    where?: LoanApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanApplications to fetch.
     */
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoanApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoanApplications
    **/
    _count?: true | LoanApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoanApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoanApplicationMaxAggregateInputType
  }

  export type GetLoanApplicationAggregateType<T extends LoanApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateLoanApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoanApplication[P]>
      : GetScalarType<T[P], AggregateLoanApplication[P]>
  }




  export type LoanApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoanApplicationWhereInput
    orderBy?: LoanApplicationOrderByWithAggregationInput | LoanApplicationOrderByWithAggregationInput[]
    by: LoanApplicationScalarFieldEnum[] | LoanApplicationScalarFieldEnum
    having?: LoanApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoanApplicationCountAggregateInputType | true
    _min?: LoanApplicationMinAggregateInputType
    _max?: LoanApplicationMaxAggregateInputType
  }

  export type LoanApplicationGroupByOutputType = {
    id: string
    status: $Enums.ApplicationStatus
    documents: string[]
    academicInfo: JsonValue
    financialInfo: JsonValue
    notes: string | null
    loanId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: LoanApplicationCountAggregateOutputType | null
    _min: LoanApplicationMinAggregateOutputType | null
    _max: LoanApplicationMaxAggregateOutputType | null
  }

  type GetLoanApplicationGroupByPayload<T extends LoanApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoanApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoanApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoanApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], LoanApplicationGroupByOutputType[P]>
        }
      >
    >


  export type LoanApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    documents?: boolean
    academicInfo?: boolean
    financialInfo?: boolean
    notes?: boolean
    loanId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanApplication"]>

  export type LoanApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    documents?: boolean
    academicInfo?: boolean
    financialInfo?: boolean
    notes?: boolean
    loanId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanApplication"]>

  export type LoanApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    documents?: boolean
    academicInfo?: boolean
    financialInfo?: boolean
    notes?: boolean
    loanId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loan?: boolean | LoanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loanApplication"]>

  export type LoanApplicationSelectScalar = {
    id?: boolean
    status?: boolean
    documents?: boolean
    academicInfo?: boolean
    financialInfo?: boolean
    notes?: boolean
    loanId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoanApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "documents" | "academicInfo" | "financialInfo" | "notes" | "loanId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["loanApplication"]>
  export type LoanApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LoanApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LoanApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loan?: boolean | LoanDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LoanApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoanApplication"
    objects: {
      loan: Prisma.$LoanPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.ApplicationStatus
      documents: string[]
      academicInfo: Prisma.JsonValue
      financialInfo: Prisma.JsonValue
      notes: string | null
      loanId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loanApplication"]>
    composites: {}
  }

  type LoanApplicationGetPayload<S extends boolean | null | undefined | LoanApplicationDefaultArgs> = $Result.GetResult<Prisma.$LoanApplicationPayload, S>

  type LoanApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoanApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoanApplicationCountAggregateInputType | true
    }

  export interface LoanApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoanApplication'], meta: { name: 'LoanApplication' } }
    /**
     * Find zero or one LoanApplication that matches the filter.
     * @param {LoanApplicationFindUniqueArgs} args - Arguments to find a LoanApplication
     * @example
     * // Get one LoanApplication
     * const loanApplication = await prisma.loanApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoanApplicationFindUniqueArgs>(args: SelectSubset<T, LoanApplicationFindUniqueArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoanApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoanApplicationFindUniqueOrThrowArgs} args - Arguments to find a LoanApplication
     * @example
     * // Get one LoanApplication
     * const loanApplication = await prisma.loanApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoanApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, LoanApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationFindFirstArgs} args - Arguments to find a LoanApplication
     * @example
     * // Get one LoanApplication
     * const loanApplication = await prisma.loanApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoanApplicationFindFirstArgs>(args?: SelectSubset<T, LoanApplicationFindFirstArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoanApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationFindFirstOrThrowArgs} args - Arguments to find a LoanApplication
     * @example
     * // Get one LoanApplication
     * const loanApplication = await prisma.loanApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoanApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, LoanApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoanApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoanApplications
     * const loanApplications = await prisma.loanApplication.findMany()
     * 
     * // Get first 10 LoanApplications
     * const loanApplications = await prisma.loanApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loanApplicationWithIdOnly = await prisma.loanApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoanApplicationFindManyArgs>(args?: SelectSubset<T, LoanApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoanApplication.
     * @param {LoanApplicationCreateArgs} args - Arguments to create a LoanApplication.
     * @example
     * // Create one LoanApplication
     * const LoanApplication = await prisma.loanApplication.create({
     *   data: {
     *     // ... data to create a LoanApplication
     *   }
     * })
     * 
     */
    create<T extends LoanApplicationCreateArgs>(args: SelectSubset<T, LoanApplicationCreateArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoanApplications.
     * @param {LoanApplicationCreateManyArgs} args - Arguments to create many LoanApplications.
     * @example
     * // Create many LoanApplications
     * const loanApplication = await prisma.loanApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoanApplicationCreateManyArgs>(args?: SelectSubset<T, LoanApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoanApplications and returns the data saved in the database.
     * @param {LoanApplicationCreateManyAndReturnArgs} args - Arguments to create many LoanApplications.
     * @example
     * // Create many LoanApplications
     * const loanApplication = await prisma.loanApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoanApplications and only return the `id`
     * const loanApplicationWithIdOnly = await prisma.loanApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoanApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, LoanApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoanApplication.
     * @param {LoanApplicationDeleteArgs} args - Arguments to delete one LoanApplication.
     * @example
     * // Delete one LoanApplication
     * const LoanApplication = await prisma.loanApplication.delete({
     *   where: {
     *     // ... filter to delete one LoanApplication
     *   }
     * })
     * 
     */
    delete<T extends LoanApplicationDeleteArgs>(args: SelectSubset<T, LoanApplicationDeleteArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoanApplication.
     * @param {LoanApplicationUpdateArgs} args - Arguments to update one LoanApplication.
     * @example
     * // Update one LoanApplication
     * const loanApplication = await prisma.loanApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoanApplicationUpdateArgs>(args: SelectSubset<T, LoanApplicationUpdateArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoanApplications.
     * @param {LoanApplicationDeleteManyArgs} args - Arguments to filter LoanApplications to delete.
     * @example
     * // Delete a few LoanApplications
     * const { count } = await prisma.loanApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoanApplicationDeleteManyArgs>(args?: SelectSubset<T, LoanApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoanApplications
     * const loanApplication = await prisma.loanApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoanApplicationUpdateManyArgs>(args: SelectSubset<T, LoanApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoanApplications and returns the data updated in the database.
     * @param {LoanApplicationUpdateManyAndReturnArgs} args - Arguments to update many LoanApplications.
     * @example
     * // Update many LoanApplications
     * const loanApplication = await prisma.loanApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoanApplications and only return the `id`
     * const loanApplicationWithIdOnly = await prisma.loanApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoanApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, LoanApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoanApplication.
     * @param {LoanApplicationUpsertArgs} args - Arguments to update or create a LoanApplication.
     * @example
     * // Update or create a LoanApplication
     * const loanApplication = await prisma.loanApplication.upsert({
     *   create: {
     *     // ... data to create a LoanApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoanApplication we want to update
     *   }
     * })
     */
    upsert<T extends LoanApplicationUpsertArgs>(args: SelectSubset<T, LoanApplicationUpsertArgs<ExtArgs>>): Prisma__LoanApplicationClient<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoanApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationCountArgs} args - Arguments to filter LoanApplications to count.
     * @example
     * // Count the number of LoanApplications
     * const count = await prisma.loanApplication.count({
     *   where: {
     *     // ... the filter for the LoanApplications we want to count
     *   }
     * })
    **/
    count<T extends LoanApplicationCountArgs>(
      args?: Subset<T, LoanApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoanApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoanApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoanApplicationAggregateArgs>(args: Subset<T, LoanApplicationAggregateArgs>): Prisma.PrismaPromise<GetLoanApplicationAggregateType<T>>

    /**
     * Group by LoanApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoanApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoanApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoanApplicationGroupByArgs['orderBy'] }
        : { orderBy?: LoanApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoanApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoanApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoanApplication model
   */
  readonly fields: LoanApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoanApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoanApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loan<T extends LoanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoanDefaultArgs<ExtArgs>>): Prisma__LoanClient<$Result.GetResult<Prisma.$LoanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoanApplication model
   */
  interface LoanApplicationFieldRefs {
    readonly id: FieldRef<"LoanApplication", 'String'>
    readonly status: FieldRef<"LoanApplication", 'ApplicationStatus'>
    readonly documents: FieldRef<"LoanApplication", 'String[]'>
    readonly academicInfo: FieldRef<"LoanApplication", 'Json'>
    readonly financialInfo: FieldRef<"LoanApplication", 'Json'>
    readonly notes: FieldRef<"LoanApplication", 'String'>
    readonly loanId: FieldRef<"LoanApplication", 'String'>
    readonly userId: FieldRef<"LoanApplication", 'String'>
    readonly createdAt: FieldRef<"LoanApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"LoanApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoanApplication findUnique
   */
  export type LoanApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplication to fetch.
     */
    where: LoanApplicationWhereUniqueInput
  }

  /**
   * LoanApplication findUniqueOrThrow
   */
  export type LoanApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplication to fetch.
     */
    where: LoanApplicationWhereUniqueInput
  }

  /**
   * LoanApplication findFirst
   */
  export type LoanApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplication to fetch.
     */
    where?: LoanApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanApplications to fetch.
     */
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanApplications.
     */
    cursor?: LoanApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanApplications.
     */
    distinct?: LoanApplicationScalarFieldEnum | LoanApplicationScalarFieldEnum[]
  }

  /**
   * LoanApplication findFirstOrThrow
   */
  export type LoanApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplication to fetch.
     */
    where?: LoanApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanApplications to fetch.
     */
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoanApplications.
     */
    cursor?: LoanApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoanApplications.
     */
    distinct?: LoanApplicationScalarFieldEnum | LoanApplicationScalarFieldEnum[]
  }

  /**
   * LoanApplication findMany
   */
  export type LoanApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LoanApplications to fetch.
     */
    where?: LoanApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoanApplications to fetch.
     */
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoanApplications.
     */
    cursor?: LoanApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoanApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoanApplications.
     */
    skip?: number
    distinct?: LoanApplicationScalarFieldEnum | LoanApplicationScalarFieldEnum[]
  }

  /**
   * LoanApplication create
   */
  export type LoanApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a LoanApplication.
     */
    data: XOR<LoanApplicationCreateInput, LoanApplicationUncheckedCreateInput>
  }

  /**
   * LoanApplication createMany
   */
  export type LoanApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoanApplications.
     */
    data: LoanApplicationCreateManyInput | LoanApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoanApplication createManyAndReturn
   */
  export type LoanApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many LoanApplications.
     */
    data: LoanApplicationCreateManyInput | LoanApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanApplication update
   */
  export type LoanApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a LoanApplication.
     */
    data: XOR<LoanApplicationUpdateInput, LoanApplicationUncheckedUpdateInput>
    /**
     * Choose, which LoanApplication to update.
     */
    where: LoanApplicationWhereUniqueInput
  }

  /**
   * LoanApplication updateMany
   */
  export type LoanApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoanApplications.
     */
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyInput>
    /**
     * Filter which LoanApplications to update
     */
    where?: LoanApplicationWhereInput
    /**
     * Limit how many LoanApplications to update.
     */
    limit?: number
  }

  /**
   * LoanApplication updateManyAndReturn
   */
  export type LoanApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * The data used to update LoanApplications.
     */
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyInput>
    /**
     * Filter which LoanApplications to update
     */
    where?: LoanApplicationWhereInput
    /**
     * Limit how many LoanApplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoanApplication upsert
   */
  export type LoanApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the LoanApplication to update in case it exists.
     */
    where: LoanApplicationWhereUniqueInput
    /**
     * In case the LoanApplication found by the `where` argument doesn't exist, create a new LoanApplication with this data.
     */
    create: XOR<LoanApplicationCreateInput, LoanApplicationUncheckedCreateInput>
    /**
     * In case the LoanApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoanApplicationUpdateInput, LoanApplicationUncheckedUpdateInput>
  }

  /**
   * LoanApplication delete
   */
  export type LoanApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    /**
     * Filter which LoanApplication to delete.
     */
    where: LoanApplicationWhereUniqueInput
  }

  /**
   * LoanApplication deleteMany
   */
  export type LoanApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoanApplications to delete
     */
    where?: LoanApplicationWhereInput
    /**
     * Limit how many LoanApplications to delete.
     */
    limit?: number
  }

  /**
   * LoanApplication without action
   */
  export type LoanApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
  }


  /**
   * Model Vote
   */

  export type AggregateVote = {
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  export type VoteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    articleId: string | null
    status: $Enums.VoteType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    articleId: string | null
    status: $Enums.VoteType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoteCountAggregateOutputType = {
    id: number
    userId: number
    articleId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoteMinAggregateInputType = {
    id?: true
    userId?: true
    articleId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoteMaxAggregateInputType = {
    id?: true
    userId?: true
    articleId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoteCountAggregateInputType = {
    id?: true
    userId?: true
    articleId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vote to aggregate.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Votes
    **/
    _count?: true | VoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoteMaxAggregateInputType
  }

  export type GetVoteAggregateType<T extends VoteAggregateArgs> = {
        [P in keyof T & keyof AggregateVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVote[P]>
      : GetScalarType<T[P], AggregateVote[P]>
  }




  export type VoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithAggregationInput | VoteOrderByWithAggregationInput[]
    by: VoteScalarFieldEnum[] | VoteScalarFieldEnum
    having?: VoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoteCountAggregateInputType | true
    _min?: VoteMinAggregateInputType
    _max?: VoteMaxAggregateInputType
  }

  export type VoteGroupByOutputType = {
    id: string
    userId: string
    articleId: string
    status: $Enums.VoteType
    createdAt: Date
    updatedAt: Date
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  type GetVoteGroupByPayload<T extends VoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoteGroupByOutputType[P]>
            : GetScalarType<T[P], VoteGroupByOutputType[P]>
        }
      >
    >


  export type VoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    articleId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    articleId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    articleId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectScalar = {
    id?: boolean
    userId?: boolean
    articleId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "articleId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["vote"]>
  export type VoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }
  export type VoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }
  export type VoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
  }

  export type $VotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vote"
    objects: {
      article: Prisma.$ArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      articleId: string
      status: $Enums.VoteType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vote"]>
    composites: {}
  }

  type VoteGetPayload<S extends boolean | null | undefined | VoteDefaultArgs> = $Result.GetResult<Prisma.$VotePayload, S>

  type VoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoteCountAggregateInputType | true
    }

  export interface VoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vote'], meta: { name: 'Vote' } }
    /**
     * Find zero or one Vote that matches the filter.
     * @param {VoteFindUniqueArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoteFindUniqueArgs>(args: SelectSubset<T, VoteFindUniqueArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoteFindUniqueOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoteFindUniqueOrThrowArgs>(args: SelectSubset<T, VoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoteFindFirstArgs>(args?: SelectSubset<T, VoteFindFirstArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoteFindFirstOrThrowArgs>(args?: SelectSubset<T, VoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.vote.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.vote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voteWithIdOnly = await prisma.vote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoteFindManyArgs>(args?: SelectSubset<T, VoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vote.
     * @param {VoteCreateArgs} args - Arguments to create a Vote.
     * @example
     * // Create one Vote
     * const Vote = await prisma.vote.create({
     *   data: {
     *     // ... data to create a Vote
     *   }
     * })
     * 
     */
    create<T extends VoteCreateArgs>(args: SelectSubset<T, VoteCreateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Votes.
     * @param {VoteCreateManyArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoteCreateManyArgs>(args?: SelectSubset<T, VoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Votes and returns the data saved in the database.
     * @param {VoteCreateManyAndReturnArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoteCreateManyAndReturnArgs>(args?: SelectSubset<T, VoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vote.
     * @param {VoteDeleteArgs} args - Arguments to delete one Vote.
     * @example
     * // Delete one Vote
     * const Vote = await prisma.vote.delete({
     *   where: {
     *     // ... filter to delete one Vote
     *   }
     * })
     * 
     */
    delete<T extends VoteDeleteArgs>(args: SelectSubset<T, VoteDeleteArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vote.
     * @param {VoteUpdateArgs} args - Arguments to update one Vote.
     * @example
     * // Update one Vote
     * const vote = await prisma.vote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoteUpdateArgs>(args: SelectSubset<T, VoteUpdateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Votes.
     * @param {VoteDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.vote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoteDeleteManyArgs>(args?: SelectSubset<T, VoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoteUpdateManyArgs>(args: SelectSubset<T, VoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes and returns the data updated in the database.
     * @param {VoteUpdateManyAndReturnArgs} args - Arguments to update many Votes.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoteUpdateManyAndReturnArgs>(args: SelectSubset<T, VoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vote.
     * @param {VoteUpsertArgs} args - Arguments to update or create a Vote.
     * @example
     * // Update or create a Vote
     * const vote = await prisma.vote.upsert({
     *   create: {
     *     // ... data to create a Vote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vote we want to update
     *   }
     * })
     */
    upsert<T extends VoteUpsertArgs>(args: SelectSubset<T, VoteUpsertArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.vote.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends VoteCountArgs>(
      args?: Subset<T, VoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoteAggregateArgs>(args: Subset<T, VoteAggregateArgs>): Prisma.PrismaPromise<GetVoteAggregateType<T>>

    /**
     * Group by Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoteGroupByArgs['orderBy'] }
        : { orderBy?: VoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vote model
   */
  readonly fields: VoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends ArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArticleDefaultArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vote model
   */
  interface VoteFieldRefs {
    readonly id: FieldRef<"Vote", 'String'>
    readonly userId: FieldRef<"Vote", 'String'>
    readonly articleId: FieldRef<"Vote", 'String'>
    readonly status: FieldRef<"Vote", 'VoteType'>
    readonly createdAt: FieldRef<"Vote", 'DateTime'>
    readonly updatedAt: FieldRef<"Vote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vote findUnique
   */
  export type VoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findUniqueOrThrow
   */
  export type VoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findFirst
   */
  export type VoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findFirstOrThrow
   */
  export type VoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findMany
   */
  export type VoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Votes to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote create
   */
  export type VoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Vote.
     */
    data: XOR<VoteCreateInput, VoteUncheckedCreateInput>
  }

  /**
   * Vote createMany
   */
  export type VoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vote createManyAndReturn
   */
  export type VoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote update
   */
  export type VoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Vote.
     */
    data: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
    /**
     * Choose, which Vote to update.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote updateMany
   */
  export type VoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
  }

  /**
   * Vote updateManyAndReturn
   */
  export type VoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote upsert
   */
  export type VoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Vote to update in case it exists.
     */
    where: VoteWhereUniqueInput
    /**
     * In case the Vote found by the `where` argument doesn't exist, create a new Vote with this data.
     */
    create: XOR<VoteCreateInput, VoteUncheckedCreateInput>
    /**
     * In case the Vote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
  }

  /**
   * Vote delete
   */
  export type VoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter which Vote to delete.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote deleteMany
   */
  export type VoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Votes to delete
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to delete.
     */
    limit?: number
  }

  /**
   * Vote without action
   */
  export type VoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    followersCount: number | null
    postsCount: number | null
  }

  export type GroupSumAggregateOutputType = {
    followersCount: number | null
    postsCount: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    banner: string | null
    logo: string | null
    description: string | null
    privacy: $Enums.GroupPrivacy | null
    followersCount: number | null
    postsCount: number | null
    createdById: string | null
    isPinned: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    banner: string | null
    logo: string | null
    description: string | null
    privacy: $Enums.GroupPrivacy | null
    followersCount: number | null
    postsCount: number | null
    createdById: string | null
    isPinned: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    banner: number
    logo: number
    description: number
    privacy: number
    followersCount: number
    postsCount: number
    createdById: number
    isPinned: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    followersCount?: true
    postsCount?: true
  }

  export type GroupSumAggregateInputType = {
    followersCount?: true
    postsCount?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    banner?: true
    logo?: true
    description?: true
    privacy?: true
    followersCount?: true
    postsCount?: true
    createdById?: true
    isPinned?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    banner?: true
    logo?: true
    description?: true
    privacy?: true
    followersCount?: true
    postsCount?: true
    createdById?: true
    isPinned?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    banner?: true
    logo?: true
    description?: true
    privacy?: true
    followersCount?: true
    postsCount?: true
    createdById?: true
    isPinned?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string
    slug: string
    banner: string | null
    logo: string | null
    description: string
    privacy: $Enums.GroupPrivacy
    followersCount: number
    postsCount: number
    createdById: string
    isPinned: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    banner?: boolean
    logo?: boolean
    description?: boolean
    privacy?: boolean
    followersCount?: boolean
    postsCount?: boolean
    createdById?: boolean
    isPinned?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    events?: boolean | Group$eventsArgs<ExtArgs>
    articles?: boolean | Group$articlesArgs<ExtArgs>
    forums?: boolean | Group$forumsArgs<ExtArgs>
    members?: boolean | Group$membersArgs<ExtArgs>
    moderators?: boolean | Group$moderatorsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    banner?: boolean
    logo?: boolean
    description?: boolean
    privacy?: boolean
    followersCount?: boolean
    postsCount?: boolean
    createdById?: boolean
    isPinned?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    banner?: boolean
    logo?: boolean
    description?: boolean
    privacy?: boolean
    followersCount?: boolean
    postsCount?: boolean
    createdById?: boolean
    isPinned?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    banner?: boolean
    logo?: boolean
    description?: boolean
    privacy?: boolean
    followersCount?: boolean
    postsCount?: boolean
    createdById?: boolean
    isPinned?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "banner" | "logo" | "description" | "privacy" | "followersCount" | "postsCount" | "createdById" | "isPinned" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    events?: boolean | Group$eventsArgs<ExtArgs>
    articles?: boolean | Group$articlesArgs<ExtArgs>
    forums?: boolean | Group$forumsArgs<ExtArgs>
    members?: boolean | Group$membersArgs<ExtArgs>
    moderators?: boolean | Group$moderatorsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      events: Prisma.$EventPayload<ExtArgs>[]
      articles: Prisma.$ArticlePayload<ExtArgs>[]
      forums: Prisma.$ForumPayload<ExtArgs>[]
      members: Prisma.$GroupMemberPayload<ExtArgs>[]
      moderators: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      banner: string | null
      logo: string | null
      description: string
      privacy: $Enums.GroupPrivacy
      followersCount: number
      postsCount: number
      createdById: string
      isPinned: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    events<T extends Group$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Group$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    articles<T extends Group$articlesArgs<ExtArgs> = {}>(args?: Subset<T, Group$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    forums<T extends Group$forumsArgs<ExtArgs> = {}>(args?: Subset<T, Group$forumsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Group$membersArgs<ExtArgs> = {}>(args?: Subset<T, Group$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moderators<T extends Group$moderatorsArgs<ExtArgs> = {}>(args?: Subset<T, Group$moderatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly slug: FieldRef<"Group", 'String'>
    readonly banner: FieldRef<"Group", 'String'>
    readonly logo: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly privacy: FieldRef<"Group", 'GroupPrivacy'>
    readonly followersCount: FieldRef<"Group", 'Int'>
    readonly postsCount: FieldRef<"Group", 'Int'>
    readonly createdById: FieldRef<"Group", 'String'>
    readonly isPinned: FieldRef<"Group", 'Boolean'>
    readonly isActive: FieldRef<"Group", 'Boolean'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group updateManyAndReturn
   */
  export type GroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.events
   */
  export type Group$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Group.articles
   */
  export type Group$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Group.forums
   */
  export type Group$forumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumInclude<ExtArgs> | null
    where?: ForumWhereInput
    orderBy?: ForumOrderByWithRelationInput | ForumOrderByWithRelationInput[]
    cursor?: ForumWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumScalarFieldEnum | ForumScalarFieldEnum[]
  }

  /**
   * Group.members
   */
  export type Group$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * Group.moderators
   */
  export type Group$moderatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model GroupMember
   */

  export type AggregateGroupMember = {
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  export type GroupMemberMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: $Enums.GroupMemberRole | null
    joinedAt: Date | null
  }

  export type GroupMemberMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: $Enums.GroupMemberRole | null
    joinedAt: Date | null
  }

  export type GroupMemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type GroupMemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type GroupMemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type GroupMemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type GroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMember to aggregate.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMembers
    **/
    _count?: true | GroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GetGroupMemberAggregateType<T extends GroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMember[P]>
      : GetScalarType<T[P], AggregateGroupMember[P]>
  }




  export type GroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithAggregationInput | GroupMemberOrderByWithAggregationInput[]
    by: GroupMemberScalarFieldEnum[] | GroupMemberScalarFieldEnum
    having?: GroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMemberCountAggregateInputType | true
    _min?: GroupMemberMinAggregateInputType
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GroupMemberGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    role: $Enums.GroupMemberRole
    joinedAt: Date
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  type GetGroupMemberGroupByPayload<T extends GroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type GroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type GroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "userId" | "role" | "joinedAt", ExtArgs["result"]["groupMember"]>
  export type GroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMember"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      role: $Enums.GroupMemberRole
      joinedAt: Date
    }, ExtArgs["result"]["groupMember"]>
    composites: {}
  }

  type GroupMemberGetPayload<S extends boolean | null | undefined | GroupMemberDefaultArgs> = $Result.GetResult<Prisma.$GroupMemberPayload, S>

  type GroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMemberCountAggregateInputType | true
    }

  export interface GroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMember'], meta: { name: 'GroupMember' } }
    /**
     * Find zero or one GroupMember that matches the filter.
     * @param {GroupMemberFindUniqueArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMemberFindUniqueArgs>(args: SelectSubset<T, GroupMemberFindUniqueArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupMemberFindUniqueOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMemberFindFirstArgs>(args?: SelectSubset<T, GroupMemberFindFirstArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMembers
     * const groupMembers = await prisma.groupMember.findMany()
     * 
     * // Get first 10 GroupMembers
     * const groupMembers = await prisma.groupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMemberFindManyArgs>(args?: SelectSubset<T, GroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupMember.
     * @param {GroupMemberCreateArgs} args - Arguments to create a GroupMember.
     * @example
     * // Create one GroupMember
     * const GroupMember = await prisma.groupMember.create({
     *   data: {
     *     // ... data to create a GroupMember
     *   }
     * })
     * 
     */
    create<T extends GroupMemberCreateArgs>(args: SelectSubset<T, GroupMemberCreateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupMembers.
     * @param {GroupMemberCreateManyArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMemberCreateManyArgs>(args?: SelectSubset<T, GroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMembers and returns the data saved in the database.
     * @param {GroupMemberCreateManyAndReturnArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupMember.
     * @param {GroupMemberDeleteArgs} args - Arguments to delete one GroupMember.
     * @example
     * // Delete one GroupMember
     * const GroupMember = await prisma.groupMember.delete({
     *   where: {
     *     // ... filter to delete one GroupMember
     *   }
     * })
     * 
     */
    delete<T extends GroupMemberDeleteArgs>(args: SelectSubset<T, GroupMemberDeleteArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupMember.
     * @param {GroupMemberUpdateArgs} args - Arguments to update one GroupMember.
     * @example
     * // Update one GroupMember
     * const groupMember = await prisma.groupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMemberUpdateArgs>(args: SelectSubset<T, GroupMemberUpdateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupMembers.
     * @param {GroupMemberDeleteManyArgs} args - Arguments to filter GroupMembers to delete.
     * @example
     * // Delete a few GroupMembers
     * const { count } = await prisma.groupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMemberDeleteManyArgs>(args?: SelectSubset<T, GroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMemberUpdateManyArgs>(args: SelectSubset<T, GroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers and returns the data updated in the database.
     * @param {GroupMemberUpdateManyAndReturnArgs} args - Arguments to update many GroupMembers.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupMember.
     * @param {GroupMemberUpsertArgs} args - Arguments to update or create a GroupMember.
     * @example
     * // Update or create a GroupMember
     * const groupMember = await prisma.groupMember.upsert({
     *   create: {
     *     // ... data to create a GroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMember we want to update
     *   }
     * })
     */
    upsert<T extends GroupMemberUpsertArgs>(args: SelectSubset<T, GroupMemberUpsertArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberCountArgs} args - Arguments to filter GroupMembers to count.
     * @example
     * // Count the number of GroupMembers
     * const count = await prisma.groupMember.count({
     *   where: {
     *     // ... the filter for the GroupMembers we want to count
     *   }
     * })
    **/
    count<T extends GroupMemberCountArgs>(
      args?: Subset<T, GroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMemberAggregateArgs>(args: Subset<T, GroupMemberAggregateArgs>): Prisma.PrismaPromise<GetGroupMemberAggregateType<T>>

    /**
     * Group by GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: GroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMember model
   */
  readonly fields: GroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMember model
   */
  interface GroupMemberFieldRefs {
    readonly id: FieldRef<"GroupMember", 'String'>
    readonly groupId: FieldRef<"GroupMember", 'String'>
    readonly userId: FieldRef<"GroupMember", 'String'>
    readonly role: FieldRef<"GroupMember", 'GroupMemberRole'>
    readonly joinedAt: FieldRef<"GroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupMember findUnique
   */
  export type GroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findUniqueOrThrow
   */
  export type GroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findFirst
   */
  export type GroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findFirstOrThrow
   */
  export type GroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findMany
   */
  export type GroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember create
   */
  export type GroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMember.
     */
    data: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
  }

  /**
   * GroupMember createMany
   */
  export type GroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMember createManyAndReturn
   */
  export type GroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember update
   */
  export type GroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMember.
     */
    data: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
    /**
     * Choose, which GroupMember to update.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember updateMany
   */
  export type GroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
  }

  /**
   * GroupMember updateManyAndReturn
   */
  export type GroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember upsert
   */
  export type GroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMember to update in case it exists.
     */
    where: GroupMemberWhereUniqueInput
    /**
     * In case the GroupMember found by the `where` argument doesn't exist, create a new GroupMember with this data.
     */
    create: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
    /**
     * In case the GroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
  }

  /**
   * GroupMember delete
   */
  export type GroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter which GroupMember to delete.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember deleteMany
   */
  export type GroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMembers to delete
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to delete.
     */
    limit?: number
  }

  /**
   * GroupMember without action
   */
  export type GroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    totalSlots: number | null
    registeredSlots: number | null
    waitlistSlots: number | null
    ticketPrice: number | null
  }

  export type EventSumAggregateOutputType = {
    totalSlots: number | null
    registeredSlots: number | null
    waitlistSlots: number | null
    ticketPrice: number | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    date: Date | null
    startTime: Date | null
    endTime: Date | null
    image: string | null
    location: string | null
    eventType: $Enums.EventType | null
    registrationType: $Enums.RegistrationType | null
    totalSlots: number | null
    registeredSlots: number | null
    waitlistSlots: number | null
    ticketPrice: number | null
    currency: string | null
    address: string | null
    virtualLink: string | null
    contactById: string | null
    groupId: string | null
    status: $Enums.EventStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    date: Date | null
    startTime: Date | null
    endTime: Date | null
    image: string | null
    location: string | null
    eventType: $Enums.EventType | null
    registrationType: $Enums.RegistrationType | null
    totalSlots: number | null
    registeredSlots: number | null
    waitlistSlots: number | null
    ticketPrice: number | null
    currency: string | null
    address: string | null
    virtualLink: string | null
    contactById: string | null
    groupId: string | null
    status: $Enums.EventStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    date: number
    startTime: number
    endTime: number
    image: number
    location: number
    eventType: number
    registrationType: number
    totalSlots: number
    registeredSlots: number
    waitlistSlots: number
    ticketPrice: number
    currency: number
    address: number
    virtualLink: number
    contactById: number
    groupId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    totalSlots?: true
    registeredSlots?: true
    waitlistSlots?: true
    ticketPrice?: true
  }

  export type EventSumAggregateInputType = {
    totalSlots?: true
    registeredSlots?: true
    waitlistSlots?: true
    ticketPrice?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    date?: true
    startTime?: true
    endTime?: true
    image?: true
    location?: true
    eventType?: true
    registrationType?: true
    totalSlots?: true
    registeredSlots?: true
    waitlistSlots?: true
    ticketPrice?: true
    currency?: true
    address?: true
    virtualLink?: true
    contactById?: true
    groupId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    date?: true
    startTime?: true
    endTime?: true
    image?: true
    location?: true
    eventType?: true
    registrationType?: true
    totalSlots?: true
    registeredSlots?: true
    waitlistSlots?: true
    ticketPrice?: true
    currency?: true
    address?: true
    virtualLink?: true
    contactById?: true
    groupId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    date?: true
    startTime?: true
    endTime?: true
    image?: true
    location?: true
    eventType?: true
    registrationType?: true
    totalSlots?: true
    registeredSlots?: true
    waitlistSlots?: true
    ticketPrice?: true
    currency?: true
    address?: true
    virtualLink?: true
    contactById?: true
    groupId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string
    date: Date
    startTime: Date
    endTime: Date | null
    image: string | null
    location: string
    eventType: $Enums.EventType
    registrationType: $Enums.RegistrationType
    totalSlots: number
    registeredSlots: number
    waitlistSlots: number | null
    ticketPrice: number | null
    currency: string | null
    address: string | null
    virtualLink: string | null
    contactById: string
    groupId: string
    status: $Enums.EventStatus
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    image?: boolean
    location?: boolean
    eventType?: boolean
    registrationType?: boolean
    totalSlots?: boolean
    registeredSlots?: boolean
    waitlistSlots?: boolean
    ticketPrice?: boolean
    currency?: boolean
    address?: boolean
    virtualLink?: boolean
    contactById?: boolean
    groupId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactBy?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
    registrations?: boolean | Event$registrationsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    image?: boolean
    location?: boolean
    eventType?: boolean
    registrationType?: boolean
    totalSlots?: boolean
    registeredSlots?: boolean
    waitlistSlots?: boolean
    ticketPrice?: boolean
    currency?: boolean
    address?: boolean
    virtualLink?: boolean
    contactById?: boolean
    groupId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactBy?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    image?: boolean
    location?: boolean
    eventType?: boolean
    registrationType?: boolean
    totalSlots?: boolean
    registeredSlots?: boolean
    waitlistSlots?: boolean
    ticketPrice?: boolean
    currency?: boolean
    address?: boolean
    virtualLink?: boolean
    contactById?: boolean
    groupId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactBy?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    image?: boolean
    location?: boolean
    eventType?: boolean
    registrationType?: boolean
    totalSlots?: boolean
    registeredSlots?: boolean
    waitlistSlots?: boolean
    ticketPrice?: boolean
    currency?: boolean
    address?: boolean
    virtualLink?: boolean
    contactById?: boolean
    groupId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "description" | "date" | "startTime" | "endTime" | "image" | "location" | "eventType" | "registrationType" | "totalSlots" | "registeredSlots" | "waitlistSlots" | "ticketPrice" | "currency" | "address" | "virtualLink" | "contactById" | "groupId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactBy?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
    registrations?: boolean | Event$registrationsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactBy?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactBy?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      contactBy: Prisma.$UserPayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs>
      registrations: Prisma.$EventRegistrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string
      date: Date
      startTime: Date
      endTime: Date | null
      image: string | null
      location: string
      eventType: $Enums.EventType
      registrationType: $Enums.RegistrationType
      totalSlots: number
      registeredSlots: number
      waitlistSlots: number | null
      ticketPrice: number | null
      currency: string | null
      address: string | null
      virtualLink: string | null
      contactById: string
      groupId: string
      status: $Enums.EventStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contactBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    registrations<T extends Event$registrationsArgs<ExtArgs> = {}>(args?: Subset<T, Event$registrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly slug: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly date: FieldRef<"Event", 'DateTime'>
    readonly startTime: FieldRef<"Event", 'DateTime'>
    readonly endTime: FieldRef<"Event", 'DateTime'>
    readonly image: FieldRef<"Event", 'String'>
    readonly location: FieldRef<"Event", 'String'>
    readonly eventType: FieldRef<"Event", 'EventType'>
    readonly registrationType: FieldRef<"Event", 'RegistrationType'>
    readonly totalSlots: FieldRef<"Event", 'Int'>
    readonly registeredSlots: FieldRef<"Event", 'Int'>
    readonly waitlistSlots: FieldRef<"Event", 'Int'>
    readonly ticketPrice: FieldRef<"Event", 'Float'>
    readonly currency: FieldRef<"Event", 'String'>
    readonly address: FieldRef<"Event", 'String'>
    readonly virtualLink: FieldRef<"Event", 'String'>
    readonly contactById: FieldRef<"Event", 'String'>
    readonly groupId: FieldRef<"Event", 'String'>
    readonly status: FieldRef<"Event", 'EventStatus'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.registrations
   */
  export type Event$registrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    where?: EventRegistrationWhereInput
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    cursor?: EventRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventRegistration
   */

  export type AggregateEventRegistration = {
    _count: EventRegistrationCountAggregateOutputType | null
    _min: EventRegistrationMinAggregateOutputType | null
    _max: EventRegistrationMaxAggregateOutputType | null
  }

  export type EventRegistrationMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    status: $Enums.EventRegistrationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventRegistrationMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    status: $Enums.EventRegistrationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventRegistrationCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    status: number
    additionalInfo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventRegistrationMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventRegistrationMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventRegistrationCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    status?: true
    additionalInfo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRegistration to aggregate.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventRegistrations
    **/
    _count?: true | EventRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventRegistrationMaxAggregateInputType
  }

  export type GetEventRegistrationAggregateType<T extends EventRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateEventRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventRegistration[P]>
      : GetScalarType<T[P], AggregateEventRegistration[P]>
  }




  export type EventRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
    orderBy?: EventRegistrationOrderByWithAggregationInput | EventRegistrationOrderByWithAggregationInput[]
    by: EventRegistrationScalarFieldEnum[] | EventRegistrationScalarFieldEnum
    having?: EventRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventRegistrationCountAggregateInputType | true
    _min?: EventRegistrationMinAggregateInputType
    _max?: EventRegistrationMaxAggregateInputType
  }

  export type EventRegistrationGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    status: $Enums.EventRegistrationStatus
    additionalInfo: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: EventRegistrationCountAggregateOutputType | null
    _min: EventRegistrationMinAggregateOutputType | null
    _max: EventRegistrationMaxAggregateOutputType | null
  }

  type GetEventRegistrationGroupByPayload<T extends EventRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], EventRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type EventRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    additionalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventRegistration"]>

  export type EventRegistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    additionalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventRegistration"]>

  export type EventRegistrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    additionalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventRegistration"]>

  export type EventRegistrationSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    status?: boolean
    additionalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "userId" | "status" | "additionalInfo" | "createdAt" | "updatedAt", ExtArgs["result"]["eventRegistration"]>
  export type EventRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type EventRegistrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type EventRegistrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $EventRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventRegistration"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      status: $Enums.EventRegistrationStatus
      additionalInfo: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eventRegistration"]>
    composites: {}
  }

  type EventRegistrationGetPayload<S extends boolean | null | undefined | EventRegistrationDefaultArgs> = $Result.GetResult<Prisma.$EventRegistrationPayload, S>

  type EventRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventRegistrationCountAggregateInputType | true
    }

  export interface EventRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventRegistration'], meta: { name: 'EventRegistration' } }
    /**
     * Find zero or one EventRegistration that matches the filter.
     * @param {EventRegistrationFindUniqueArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventRegistrationFindUniqueArgs>(args: SelectSubset<T, EventRegistrationFindUniqueArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventRegistrationFindUniqueOrThrowArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, EventRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindFirstArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventRegistrationFindFirstArgs>(args?: SelectSubset<T, EventRegistrationFindFirstArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindFirstOrThrowArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, EventRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventRegistrations
     * const eventRegistrations = await prisma.eventRegistration.findMany()
     * 
     * // Get first 10 EventRegistrations
     * const eventRegistrations = await prisma.eventRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventRegistrationWithIdOnly = await prisma.eventRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventRegistrationFindManyArgs>(args?: SelectSubset<T, EventRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventRegistration.
     * @param {EventRegistrationCreateArgs} args - Arguments to create a EventRegistration.
     * @example
     * // Create one EventRegistration
     * const EventRegistration = await prisma.eventRegistration.create({
     *   data: {
     *     // ... data to create a EventRegistration
     *   }
     * })
     * 
     */
    create<T extends EventRegistrationCreateArgs>(args: SelectSubset<T, EventRegistrationCreateArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventRegistrations.
     * @param {EventRegistrationCreateManyArgs} args - Arguments to create many EventRegistrations.
     * @example
     * // Create many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventRegistrationCreateManyArgs>(args?: SelectSubset<T, EventRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventRegistrations and returns the data saved in the database.
     * @param {EventRegistrationCreateManyAndReturnArgs} args - Arguments to create many EventRegistrations.
     * @example
     * // Create many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventRegistrations and only return the `id`
     * const eventRegistrationWithIdOnly = await prisma.eventRegistration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventRegistrationCreateManyAndReturnArgs>(args?: SelectSubset<T, EventRegistrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventRegistration.
     * @param {EventRegistrationDeleteArgs} args - Arguments to delete one EventRegistration.
     * @example
     * // Delete one EventRegistration
     * const EventRegistration = await prisma.eventRegistration.delete({
     *   where: {
     *     // ... filter to delete one EventRegistration
     *   }
     * })
     * 
     */
    delete<T extends EventRegistrationDeleteArgs>(args: SelectSubset<T, EventRegistrationDeleteArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventRegistration.
     * @param {EventRegistrationUpdateArgs} args - Arguments to update one EventRegistration.
     * @example
     * // Update one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventRegistrationUpdateArgs>(args: SelectSubset<T, EventRegistrationUpdateArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventRegistrations.
     * @param {EventRegistrationDeleteManyArgs} args - Arguments to filter EventRegistrations to delete.
     * @example
     * // Delete a few EventRegistrations
     * const { count } = await prisma.eventRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventRegistrationDeleteManyArgs>(args?: SelectSubset<T, EventRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventRegistrationUpdateManyArgs>(args: SelectSubset<T, EventRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventRegistrations and returns the data updated in the database.
     * @param {EventRegistrationUpdateManyAndReturnArgs} args - Arguments to update many EventRegistrations.
     * @example
     * // Update many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventRegistrations and only return the `id`
     * const eventRegistrationWithIdOnly = await prisma.eventRegistration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventRegistrationUpdateManyAndReturnArgs>(args: SelectSubset<T, EventRegistrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventRegistration.
     * @param {EventRegistrationUpsertArgs} args - Arguments to update or create a EventRegistration.
     * @example
     * // Update or create a EventRegistration
     * const eventRegistration = await prisma.eventRegistration.upsert({
     *   create: {
     *     // ... data to create a EventRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventRegistration we want to update
     *   }
     * })
     */
    upsert<T extends EventRegistrationUpsertArgs>(args: SelectSubset<T, EventRegistrationUpsertArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationCountArgs} args - Arguments to filter EventRegistrations to count.
     * @example
     * // Count the number of EventRegistrations
     * const count = await prisma.eventRegistration.count({
     *   where: {
     *     // ... the filter for the EventRegistrations we want to count
     *   }
     * })
    **/
    count<T extends EventRegistrationCountArgs>(
      args?: Subset<T, EventRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventRegistrationAggregateArgs>(args: Subset<T, EventRegistrationAggregateArgs>): Prisma.PrismaPromise<GetEventRegistrationAggregateType<T>>

    /**
     * Group by EventRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: EventRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventRegistration model
   */
  readonly fields: EventRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventRegistration model
   */
  interface EventRegistrationFieldRefs {
    readonly id: FieldRef<"EventRegistration", 'String'>
    readonly eventId: FieldRef<"EventRegistration", 'String'>
    readonly userId: FieldRef<"EventRegistration", 'String'>
    readonly status: FieldRef<"EventRegistration", 'EventRegistrationStatus'>
    readonly additionalInfo: FieldRef<"EventRegistration", 'Json'>
    readonly createdAt: FieldRef<"EventRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"EventRegistration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventRegistration findUnique
   */
  export type EventRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration findUniqueOrThrow
   */
  export type EventRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration findFirst
   */
  export type EventRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRegistrations.
     */
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * EventRegistration findFirstOrThrow
   */
  export type EventRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRegistrations.
     */
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * EventRegistration findMany
   */
  export type EventRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistrations to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * EventRegistration create
   */
  export type EventRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a EventRegistration.
     */
    data: XOR<EventRegistrationCreateInput, EventRegistrationUncheckedCreateInput>
  }

  /**
   * EventRegistration createMany
   */
  export type EventRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventRegistrations.
     */
    data: EventRegistrationCreateManyInput | EventRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventRegistration createManyAndReturn
   */
  export type EventRegistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * The data used to create many EventRegistrations.
     */
    data: EventRegistrationCreateManyInput | EventRegistrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventRegistration update
   */
  export type EventRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a EventRegistration.
     */
    data: XOR<EventRegistrationUpdateInput, EventRegistrationUncheckedUpdateInput>
    /**
     * Choose, which EventRegistration to update.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration updateMany
   */
  export type EventRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventRegistrations.
     */
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which EventRegistrations to update
     */
    where?: EventRegistrationWhereInput
    /**
     * Limit how many EventRegistrations to update.
     */
    limit?: number
  }

  /**
   * EventRegistration updateManyAndReturn
   */
  export type EventRegistrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * The data used to update EventRegistrations.
     */
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which EventRegistrations to update
     */
    where?: EventRegistrationWhereInput
    /**
     * Limit how many EventRegistrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventRegistration upsert
   */
  export type EventRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the EventRegistration to update in case it exists.
     */
    where: EventRegistrationWhereUniqueInput
    /**
     * In case the EventRegistration found by the `where` argument doesn't exist, create a new EventRegistration with this data.
     */
    create: XOR<EventRegistrationCreateInput, EventRegistrationUncheckedCreateInput>
    /**
     * In case the EventRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventRegistrationUpdateInput, EventRegistrationUncheckedUpdateInput>
  }

  /**
   * EventRegistration delete
   */
  export type EventRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter which EventRegistration to delete.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration deleteMany
   */
  export type EventRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRegistrations to delete
     */
    where?: EventRegistrationWhereInput
    /**
     * Limit how many EventRegistrations to delete.
     */
    limit?: number
  }

  /**
   * EventRegistration without action
   */
  export type EventRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model Forum
   */

  export type AggregateForum = {
    _count: ForumCountAggregateOutputType | null
    _avg: ForumAvgAggregateOutputType | null
    _sum: ForumSumAggregateOutputType | null
    _min: ForumMinAggregateOutputType | null
    _max: ForumMaxAggregateOutputType | null
  }

  export type ForumAvgAggregateOutputType = {
    viewCount: number | null
    topicCount: number | null
    replyCount: number | null
  }

  export type ForumSumAggregateOutputType = {
    viewCount: number | null
    topicCount: number | null
    replyCount: number | null
  }

  export type ForumMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    groupId: string | null
    type: $Enums.ForumType | null
    privacy: $Enums.ForumPrivacy | null
    creatorId: string | null
    viewCount: number | null
    topicCount: number | null
    replyCount: number | null
    lastReplyAt: Date | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    groupId: string | null
    type: $Enums.ForumType | null
    privacy: $Enums.ForumPrivacy | null
    creatorId: string | null
    viewCount: number | null
    topicCount: number | null
    replyCount: number | null
    lastReplyAt: Date | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCountAggregateOutputType = {
    id: number
    title: number
    description: number
    groupId: number
    type: number
    privacy: number
    attachments: number
    creatorId: number
    viewCount: number
    topicCount: number
    replyCount: number
    lastReplyAt: number
    isLocked: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumAvgAggregateInputType = {
    viewCount?: true
    topicCount?: true
    replyCount?: true
  }

  export type ForumSumAggregateInputType = {
    viewCount?: true
    topicCount?: true
    replyCount?: true
  }

  export type ForumMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    groupId?: true
    type?: true
    privacy?: true
    creatorId?: true
    viewCount?: true
    topicCount?: true
    replyCount?: true
    lastReplyAt?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    groupId?: true
    type?: true
    privacy?: true
    creatorId?: true
    viewCount?: true
    topicCount?: true
    replyCount?: true
    lastReplyAt?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    groupId?: true
    type?: true
    privacy?: true
    attachments?: true
    creatorId?: true
    viewCount?: true
    topicCount?: true
    replyCount?: true
    lastReplyAt?: true
    isLocked?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forum to aggregate.
     */
    where?: ForumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forums to fetch.
     */
    orderBy?: ForumOrderByWithRelationInput | ForumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Forums
    **/
    _count?: true | ForumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumMaxAggregateInputType
  }

  export type GetForumAggregateType<T extends ForumAggregateArgs> = {
        [P in keyof T & keyof AggregateForum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForum[P]>
      : GetScalarType<T[P], AggregateForum[P]>
  }




  export type ForumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumWhereInput
    orderBy?: ForumOrderByWithAggregationInput | ForumOrderByWithAggregationInput[]
    by: ForumScalarFieldEnum[] | ForumScalarFieldEnum
    having?: ForumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumCountAggregateInputType | true
    _avg?: ForumAvgAggregateInputType
    _sum?: ForumSumAggregateInputType
    _min?: ForumMinAggregateInputType
    _max?: ForumMaxAggregateInputType
  }

  export type ForumGroupByOutputType = {
    id: string
    title: string
    description: string | null
    groupId: string
    type: $Enums.ForumType
    privacy: $Enums.ForumPrivacy
    attachments: string[]
    creatorId: string
    viewCount: number
    topicCount: number
    replyCount: number
    lastReplyAt: Date | null
    isLocked: boolean
    tags: string[]
    createdAt: Date
    updatedAt: Date
    _count: ForumCountAggregateOutputType | null
    _avg: ForumAvgAggregateOutputType | null
    _sum: ForumSumAggregateOutputType | null
    _min: ForumMinAggregateOutputType | null
    _max: ForumMaxAggregateOutputType | null
  }

  type GetForumGroupByPayload<T extends ForumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumGroupByOutputType[P]>
            : GetScalarType<T[P], ForumGroupByOutputType[P]>
        }
      >
    >


  export type ForumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    groupId?: boolean
    type?: boolean
    privacy?: boolean
    attachments?: boolean
    creatorId?: boolean
    viewCount?: boolean
    topicCount?: boolean
    replyCount?: boolean
    lastReplyAt?: boolean
    isLocked?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    topics?: boolean | Forum$topicsArgs<ExtArgs>
    forumReplies?: boolean | Forum$forumRepliesArgs<ExtArgs>
    _count?: boolean | ForumCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forum"]>

  export type ForumSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    groupId?: boolean
    type?: boolean
    privacy?: boolean
    attachments?: boolean
    creatorId?: boolean
    viewCount?: boolean
    topicCount?: boolean
    replyCount?: boolean
    lastReplyAt?: boolean
    isLocked?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forum"]>

  export type ForumSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    groupId?: boolean
    type?: boolean
    privacy?: boolean
    attachments?: boolean
    creatorId?: boolean
    viewCount?: boolean
    topicCount?: boolean
    replyCount?: boolean
    lastReplyAt?: boolean
    isLocked?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forum"]>

  export type ForumSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    groupId?: boolean
    type?: boolean
    privacy?: boolean
    attachments?: boolean
    creatorId?: boolean
    viewCount?: boolean
    topicCount?: boolean
    replyCount?: boolean
    lastReplyAt?: boolean
    isLocked?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "groupId" | "type" | "privacy" | "attachments" | "creatorId" | "viewCount" | "topicCount" | "replyCount" | "lastReplyAt" | "isLocked" | "tags" | "createdAt" | "updatedAt", ExtArgs["result"]["forum"]>
  export type ForumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    topics?: boolean | Forum$topicsArgs<ExtArgs>
    forumReplies?: boolean | Forum$forumRepliesArgs<ExtArgs>
    _count?: boolean | ForumCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ForumIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ForumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Forum"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      topics: Prisma.$ForumTopicPayload<ExtArgs>[]
      forumReplies: Prisma.$ForumReplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      groupId: string
      type: $Enums.ForumType
      privacy: $Enums.ForumPrivacy
      attachments: string[]
      creatorId: string
      viewCount: number
      topicCount: number
      replyCount: number
      lastReplyAt: Date | null
      isLocked: boolean
      tags: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forum"]>
    composites: {}
  }

  type ForumGetPayload<S extends boolean | null | undefined | ForumDefaultArgs> = $Result.GetResult<Prisma.$ForumPayload, S>

  type ForumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ForumFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumCountAggregateInputType | true
    }

  export interface ForumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Forum'], meta: { name: 'Forum' } }
    /**
     * Find zero or one Forum that matches the filter.
     * @param {ForumFindUniqueArgs} args - Arguments to find a Forum
     * @example
     * // Get one Forum
     * const forum = await prisma.forum.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumFindUniqueArgs>(args: SelectSubset<T, ForumFindUniqueArgs<ExtArgs>>): Prisma__ForumClient<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Forum that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ForumFindUniqueOrThrowArgs} args - Arguments to find a Forum
     * @example
     * // Get one Forum
     * const forum = await prisma.forum.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumClient<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Forum that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumFindFirstArgs} args - Arguments to find a Forum
     * @example
     * // Get one Forum
     * const forum = await prisma.forum.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumFindFirstArgs>(args?: SelectSubset<T, ForumFindFirstArgs<ExtArgs>>): Prisma__ForumClient<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Forum that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumFindFirstOrThrowArgs} args - Arguments to find a Forum
     * @example
     * // Get one Forum
     * const forum = await prisma.forum.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumClient<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Forums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forums
     * const forums = await prisma.forum.findMany()
     * 
     * // Get first 10 Forums
     * const forums = await prisma.forum.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumWithIdOnly = await prisma.forum.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumFindManyArgs>(args?: SelectSubset<T, ForumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Forum.
     * @param {ForumCreateArgs} args - Arguments to create a Forum.
     * @example
     * // Create one Forum
     * const Forum = await prisma.forum.create({
     *   data: {
     *     // ... data to create a Forum
     *   }
     * })
     * 
     */
    create<T extends ForumCreateArgs>(args: SelectSubset<T, ForumCreateArgs<ExtArgs>>): Prisma__ForumClient<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Forums.
     * @param {ForumCreateManyArgs} args - Arguments to create many Forums.
     * @example
     * // Create many Forums
     * const forum = await prisma.forum.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumCreateManyArgs>(args?: SelectSubset<T, ForumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Forums and returns the data saved in the database.
     * @param {ForumCreateManyAndReturnArgs} args - Arguments to create many Forums.
     * @example
     * // Create many Forums
     * const forum = await prisma.forum.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Forums and only return the `id`
     * const forumWithIdOnly = await prisma.forum.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Forum.
     * @param {ForumDeleteArgs} args - Arguments to delete one Forum.
     * @example
     * // Delete one Forum
     * const Forum = await prisma.forum.delete({
     *   where: {
     *     // ... filter to delete one Forum
     *   }
     * })
     * 
     */
    delete<T extends ForumDeleteArgs>(args: SelectSubset<T, ForumDeleteArgs<ExtArgs>>): Prisma__ForumClient<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Forum.
     * @param {ForumUpdateArgs} args - Arguments to update one Forum.
     * @example
     * // Update one Forum
     * const forum = await prisma.forum.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumUpdateArgs>(args: SelectSubset<T, ForumUpdateArgs<ExtArgs>>): Prisma__ForumClient<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Forums.
     * @param {ForumDeleteManyArgs} args - Arguments to filter Forums to delete.
     * @example
     * // Delete a few Forums
     * const { count } = await prisma.forum.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumDeleteManyArgs>(args?: SelectSubset<T, ForumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forums
     * const forum = await prisma.forum.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumUpdateManyArgs>(args: SelectSubset<T, ForumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forums and returns the data updated in the database.
     * @param {ForumUpdateManyAndReturnArgs} args - Arguments to update many Forums.
     * @example
     * // Update many Forums
     * const forum = await prisma.forum.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Forums and only return the `id`
     * const forumWithIdOnly = await prisma.forum.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ForumUpdateManyAndReturnArgs>(args: SelectSubset<T, ForumUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Forum.
     * @param {ForumUpsertArgs} args - Arguments to update or create a Forum.
     * @example
     * // Update or create a Forum
     * const forum = await prisma.forum.upsert({
     *   create: {
     *     // ... data to create a Forum
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Forum we want to update
     *   }
     * })
     */
    upsert<T extends ForumUpsertArgs>(args: SelectSubset<T, ForumUpsertArgs<ExtArgs>>): Prisma__ForumClient<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Forums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCountArgs} args - Arguments to filter Forums to count.
     * @example
     * // Count the number of Forums
     * const count = await prisma.forum.count({
     *   where: {
     *     // ... the filter for the Forums we want to count
     *   }
     * })
    **/
    count<T extends ForumCountArgs>(
      args?: Subset<T, ForumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Forum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumAggregateArgs>(args: Subset<T, ForumAggregateArgs>): Prisma.PrismaPromise<GetForumAggregateType<T>>

    /**
     * Group by Forum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumGroupByArgs['orderBy'] }
        : { orderBy?: ForumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Forum model
   */
  readonly fields: ForumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Forum.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    topics<T extends Forum$topicsArgs<ExtArgs> = {}>(args?: Subset<T, Forum$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    forumReplies<T extends Forum$forumRepliesArgs<ExtArgs> = {}>(args?: Subset<T, Forum$forumRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Forum model
   */
  interface ForumFieldRefs {
    readonly id: FieldRef<"Forum", 'String'>
    readonly title: FieldRef<"Forum", 'String'>
    readonly description: FieldRef<"Forum", 'String'>
    readonly groupId: FieldRef<"Forum", 'String'>
    readonly type: FieldRef<"Forum", 'ForumType'>
    readonly privacy: FieldRef<"Forum", 'ForumPrivacy'>
    readonly attachments: FieldRef<"Forum", 'String[]'>
    readonly creatorId: FieldRef<"Forum", 'String'>
    readonly viewCount: FieldRef<"Forum", 'Int'>
    readonly topicCount: FieldRef<"Forum", 'Int'>
    readonly replyCount: FieldRef<"Forum", 'Int'>
    readonly lastReplyAt: FieldRef<"Forum", 'DateTime'>
    readonly isLocked: FieldRef<"Forum", 'Boolean'>
    readonly tags: FieldRef<"Forum", 'String[]'>
    readonly createdAt: FieldRef<"Forum", 'DateTime'>
    readonly updatedAt: FieldRef<"Forum", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Forum findUnique
   */
  export type ForumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumInclude<ExtArgs> | null
    /**
     * Filter, which Forum to fetch.
     */
    where: ForumWhereUniqueInput
  }

  /**
   * Forum findUniqueOrThrow
   */
  export type ForumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumInclude<ExtArgs> | null
    /**
     * Filter, which Forum to fetch.
     */
    where: ForumWhereUniqueInput
  }

  /**
   * Forum findFirst
   */
  export type ForumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumInclude<ExtArgs> | null
    /**
     * Filter, which Forum to fetch.
     */
    where?: ForumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forums to fetch.
     */
    orderBy?: ForumOrderByWithRelationInput | ForumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forums.
     */
    cursor?: ForumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forums.
     */
    distinct?: ForumScalarFieldEnum | ForumScalarFieldEnum[]
  }

  /**
   * Forum findFirstOrThrow
   */
  export type ForumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumInclude<ExtArgs> | null
    /**
     * Filter, which Forum to fetch.
     */
    where?: ForumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forums to fetch.
     */
    orderBy?: ForumOrderByWithRelationInput | ForumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Forums.
     */
    cursor?: ForumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Forums.
     */
    distinct?: ForumScalarFieldEnum | ForumScalarFieldEnum[]
  }

  /**
   * Forum findMany
   */
  export type ForumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumInclude<ExtArgs> | null
    /**
     * Filter, which Forums to fetch.
     */
    where?: ForumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Forums to fetch.
     */
    orderBy?: ForumOrderByWithRelationInput | ForumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Forums.
     */
    cursor?: ForumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Forums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Forums.
     */
    skip?: number
    distinct?: ForumScalarFieldEnum | ForumScalarFieldEnum[]
  }

  /**
   * Forum create
   */
  export type ForumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumInclude<ExtArgs> | null
    /**
     * The data needed to create a Forum.
     */
    data: XOR<ForumCreateInput, ForumUncheckedCreateInput>
  }

  /**
   * Forum createMany
   */
  export type ForumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Forums.
     */
    data: ForumCreateManyInput | ForumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Forum createManyAndReturn
   */
  export type ForumCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * The data used to create many Forums.
     */
    data: ForumCreateManyInput | ForumCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Forum update
   */
  export type ForumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumInclude<ExtArgs> | null
    /**
     * The data needed to update a Forum.
     */
    data: XOR<ForumUpdateInput, ForumUncheckedUpdateInput>
    /**
     * Choose, which Forum to update.
     */
    where: ForumWhereUniqueInput
  }

  /**
   * Forum updateMany
   */
  export type ForumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Forums.
     */
    data: XOR<ForumUpdateManyMutationInput, ForumUncheckedUpdateManyInput>
    /**
     * Filter which Forums to update
     */
    where?: ForumWhereInput
    /**
     * Limit how many Forums to update.
     */
    limit?: number
  }

  /**
   * Forum updateManyAndReturn
   */
  export type ForumUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * The data used to update Forums.
     */
    data: XOR<ForumUpdateManyMutationInput, ForumUncheckedUpdateManyInput>
    /**
     * Filter which Forums to update
     */
    where?: ForumWhereInput
    /**
     * Limit how many Forums to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Forum upsert
   */
  export type ForumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumInclude<ExtArgs> | null
    /**
     * The filter to search for the Forum to update in case it exists.
     */
    where: ForumWhereUniqueInput
    /**
     * In case the Forum found by the `where` argument doesn't exist, create a new Forum with this data.
     */
    create: XOR<ForumCreateInput, ForumUncheckedCreateInput>
    /**
     * In case the Forum was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumUpdateInput, ForumUncheckedUpdateInput>
  }

  /**
   * Forum delete
   */
  export type ForumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumInclude<ExtArgs> | null
    /**
     * Filter which Forum to delete.
     */
    where: ForumWhereUniqueInput
  }

  /**
   * Forum deleteMany
   */
  export type ForumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Forums to delete
     */
    where?: ForumWhereInput
    /**
     * Limit how many Forums to delete.
     */
    limit?: number
  }

  /**
   * Forum.topics
   */
  export type Forum$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    where?: ForumTopicWhereInput
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    cursor?: ForumTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * Forum.forumReplies
   */
  export type Forum$forumRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    where?: ForumReplyWhereInput
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    cursor?: ForumReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumReplyScalarFieldEnum | ForumReplyScalarFieldEnum[]
  }

  /**
   * Forum without action
   */
  export type ForumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumInclude<ExtArgs> | null
  }


  /**
   * Model ForumTopic
   */

  export type AggregateForumTopic = {
    _count: ForumTopicCountAggregateOutputType | null
    _avg: ForumTopicAvgAggregateOutputType | null
    _sum: ForumTopicSumAggregateOutputType | null
    _min: ForumTopicMinAggregateOutputType | null
    _max: ForumTopicMaxAggregateOutputType | null
  }

  export type ForumTopicAvgAggregateOutputType = {
    viewCount: number | null
    replyCount: number | null
  }

  export type ForumTopicSumAggregateOutputType = {
    viewCount: number | null
    replyCount: number | null
  }

  export type ForumTopicMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    forumId: string | null
    creatorId: string | null
    type: $Enums.TopicType | null
    isPinned: boolean | null
    isClosed: boolean | null
    viewCount: number | null
    replyCount: number | null
    lastReplyAt: Date | null
    status: $Enums.TopicStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumTopicMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    forumId: string | null
    creatorId: string | null
    type: $Enums.TopicType | null
    isPinned: boolean | null
    isClosed: boolean | null
    viewCount: number | null
    replyCount: number | null
    lastReplyAt: Date | null
    status: $Enums.TopicStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumTopicCountAggregateOutputType = {
    id: number
    title: number
    content: number
    forumId: number
    creatorId: number
    type: number
    isPinned: number
    isClosed: number
    viewCount: number
    replyCount: number
    lastReplyAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumTopicAvgAggregateInputType = {
    viewCount?: true
    replyCount?: true
  }

  export type ForumTopicSumAggregateInputType = {
    viewCount?: true
    replyCount?: true
  }

  export type ForumTopicMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    forumId?: true
    creatorId?: true
    type?: true
    isPinned?: true
    isClosed?: true
    viewCount?: true
    replyCount?: true
    lastReplyAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumTopicMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    forumId?: true
    creatorId?: true
    type?: true
    isPinned?: true
    isClosed?: true
    viewCount?: true
    replyCount?: true
    lastReplyAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumTopicCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    forumId?: true
    creatorId?: true
    type?: true
    isPinned?: true
    isClosed?: true
    viewCount?: true
    replyCount?: true
    lastReplyAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumTopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumTopic to aggregate.
     */
    where?: ForumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopics to fetch.
     */
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumTopics
    **/
    _count?: true | ForumTopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumTopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumTopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumTopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumTopicMaxAggregateInputType
  }

  export type GetForumTopicAggregateType<T extends ForumTopicAggregateArgs> = {
        [P in keyof T & keyof AggregateForumTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumTopic[P]>
      : GetScalarType<T[P], AggregateForumTopic[P]>
  }




  export type ForumTopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumTopicWhereInput
    orderBy?: ForumTopicOrderByWithAggregationInput | ForumTopicOrderByWithAggregationInput[]
    by: ForumTopicScalarFieldEnum[] | ForumTopicScalarFieldEnum
    having?: ForumTopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumTopicCountAggregateInputType | true
    _avg?: ForumTopicAvgAggregateInputType
    _sum?: ForumTopicSumAggregateInputType
    _min?: ForumTopicMinAggregateInputType
    _max?: ForumTopicMaxAggregateInputType
  }

  export type ForumTopicGroupByOutputType = {
    id: string
    title: string
    content: string
    forumId: string
    creatorId: string
    type: $Enums.TopicType
    isPinned: boolean
    isClosed: boolean
    viewCount: number
    replyCount: number
    lastReplyAt: Date | null
    status: $Enums.TopicStatus
    createdAt: Date
    updatedAt: Date
    _count: ForumTopicCountAggregateOutputType | null
    _avg: ForumTopicAvgAggregateOutputType | null
    _sum: ForumTopicSumAggregateOutputType | null
    _min: ForumTopicMinAggregateOutputType | null
    _max: ForumTopicMaxAggregateOutputType | null
  }

  type GetForumTopicGroupByPayload<T extends ForumTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumTopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumTopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumTopicGroupByOutputType[P]>
            : GetScalarType<T[P], ForumTopicGroupByOutputType[P]>
        }
      >
    >


  export type ForumTopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    forumId?: boolean
    creatorId?: boolean
    type?: boolean
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: boolean
    replyCount?: boolean
    lastReplyAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    forum?: boolean | ForumDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    posts?: boolean | ForumTopic$postsArgs<ExtArgs>
    replies?: boolean | ForumTopic$repliesArgs<ExtArgs>
    _count?: boolean | ForumTopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumTopic"]>

  export type ForumTopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    forumId?: boolean
    creatorId?: boolean
    type?: boolean
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: boolean
    replyCount?: boolean
    lastReplyAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    forum?: boolean | ForumDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumTopic"]>

  export type ForumTopicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    forumId?: boolean
    creatorId?: boolean
    type?: boolean
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: boolean
    replyCount?: boolean
    lastReplyAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    forum?: boolean | ForumDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumTopic"]>

  export type ForumTopicSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    forumId?: boolean
    creatorId?: boolean
    type?: boolean
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: boolean
    replyCount?: boolean
    lastReplyAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumTopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "forumId" | "creatorId" | "type" | "isPinned" | "isClosed" | "viewCount" | "replyCount" | "lastReplyAt" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["forumTopic"]>
  export type ForumTopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forum?: boolean | ForumDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    posts?: boolean | ForumTopic$postsArgs<ExtArgs>
    replies?: boolean | ForumTopic$repliesArgs<ExtArgs>
    _count?: boolean | ForumTopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumTopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forum?: boolean | ForumDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ForumTopicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forum?: boolean | ForumDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ForumTopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumTopic"
    objects: {
      forum: Prisma.$ForumPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      posts: Prisma.$ForumPostPayload<ExtArgs>[]
      replies: Prisma.$ForumReplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      forumId: string
      creatorId: string
      type: $Enums.TopicType
      isPinned: boolean
      isClosed: boolean
      viewCount: number
      replyCount: number
      lastReplyAt: Date | null
      status: $Enums.TopicStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumTopic"]>
    composites: {}
  }

  type ForumTopicGetPayload<S extends boolean | null | undefined | ForumTopicDefaultArgs> = $Result.GetResult<Prisma.$ForumTopicPayload, S>

  type ForumTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ForumTopicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumTopicCountAggregateInputType | true
    }

  export interface ForumTopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumTopic'], meta: { name: 'ForumTopic' } }
    /**
     * Find zero or one ForumTopic that matches the filter.
     * @param {ForumTopicFindUniqueArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumTopicFindUniqueArgs>(args: SelectSubset<T, ForumTopicFindUniqueArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumTopic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ForumTopicFindUniqueOrThrowArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumTopicFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumTopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicFindFirstArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumTopicFindFirstArgs>(args?: SelectSubset<T, ForumTopicFindFirstArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicFindFirstOrThrowArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumTopicFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumTopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumTopics
     * const forumTopics = await prisma.forumTopic.findMany()
     * 
     * // Get first 10 ForumTopics
     * const forumTopics = await prisma.forumTopic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumTopicWithIdOnly = await prisma.forumTopic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumTopicFindManyArgs>(args?: SelectSubset<T, ForumTopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumTopic.
     * @param {ForumTopicCreateArgs} args - Arguments to create a ForumTopic.
     * @example
     * // Create one ForumTopic
     * const ForumTopic = await prisma.forumTopic.create({
     *   data: {
     *     // ... data to create a ForumTopic
     *   }
     * })
     * 
     */
    create<T extends ForumTopicCreateArgs>(args: SelectSubset<T, ForumTopicCreateArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumTopics.
     * @param {ForumTopicCreateManyArgs} args - Arguments to create many ForumTopics.
     * @example
     * // Create many ForumTopics
     * const forumTopic = await prisma.forumTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumTopicCreateManyArgs>(args?: SelectSubset<T, ForumTopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumTopics and returns the data saved in the database.
     * @param {ForumTopicCreateManyAndReturnArgs} args - Arguments to create many ForumTopics.
     * @example
     * // Create many ForumTopics
     * const forumTopic = await prisma.forumTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumTopics and only return the `id`
     * const forumTopicWithIdOnly = await prisma.forumTopic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumTopicCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumTopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumTopic.
     * @param {ForumTopicDeleteArgs} args - Arguments to delete one ForumTopic.
     * @example
     * // Delete one ForumTopic
     * const ForumTopic = await prisma.forumTopic.delete({
     *   where: {
     *     // ... filter to delete one ForumTopic
     *   }
     * })
     * 
     */
    delete<T extends ForumTopicDeleteArgs>(args: SelectSubset<T, ForumTopicDeleteArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumTopic.
     * @param {ForumTopicUpdateArgs} args - Arguments to update one ForumTopic.
     * @example
     * // Update one ForumTopic
     * const forumTopic = await prisma.forumTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumTopicUpdateArgs>(args: SelectSubset<T, ForumTopicUpdateArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumTopics.
     * @param {ForumTopicDeleteManyArgs} args - Arguments to filter ForumTopics to delete.
     * @example
     * // Delete a few ForumTopics
     * const { count } = await prisma.forumTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumTopicDeleteManyArgs>(args?: SelectSubset<T, ForumTopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumTopics
     * const forumTopic = await prisma.forumTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumTopicUpdateManyArgs>(args: SelectSubset<T, ForumTopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumTopics and returns the data updated in the database.
     * @param {ForumTopicUpdateManyAndReturnArgs} args - Arguments to update many ForumTopics.
     * @example
     * // Update many ForumTopics
     * const forumTopic = await prisma.forumTopic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumTopics and only return the `id`
     * const forumTopicWithIdOnly = await prisma.forumTopic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ForumTopicUpdateManyAndReturnArgs>(args: SelectSubset<T, ForumTopicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumTopic.
     * @param {ForumTopicUpsertArgs} args - Arguments to update or create a ForumTopic.
     * @example
     * // Update or create a ForumTopic
     * const forumTopic = await prisma.forumTopic.upsert({
     *   create: {
     *     // ... data to create a ForumTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumTopic we want to update
     *   }
     * })
     */
    upsert<T extends ForumTopicUpsertArgs>(args: SelectSubset<T, ForumTopicUpsertArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicCountArgs} args - Arguments to filter ForumTopics to count.
     * @example
     * // Count the number of ForumTopics
     * const count = await prisma.forumTopic.count({
     *   where: {
     *     // ... the filter for the ForumTopics we want to count
     *   }
     * })
    **/
    count<T extends ForumTopicCountArgs>(
      args?: Subset<T, ForumTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumTopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumTopicAggregateArgs>(args: Subset<T, ForumTopicAggregateArgs>): Prisma.PrismaPromise<GetForumTopicAggregateType<T>>

    /**
     * Group by ForumTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumTopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumTopicGroupByArgs['orderBy'] }
        : { orderBy?: ForumTopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumTopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumTopic model
   */
  readonly fields: ForumTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumTopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    forum<T extends ForumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumDefaultArgs<ExtArgs>>): Prisma__ForumClient<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    posts<T extends ForumTopic$postsArgs<ExtArgs> = {}>(args?: Subset<T, ForumTopic$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    replies<T extends ForumTopic$repliesArgs<ExtArgs> = {}>(args?: Subset<T, ForumTopic$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumTopic model
   */
  interface ForumTopicFieldRefs {
    readonly id: FieldRef<"ForumTopic", 'String'>
    readonly title: FieldRef<"ForumTopic", 'String'>
    readonly content: FieldRef<"ForumTopic", 'String'>
    readonly forumId: FieldRef<"ForumTopic", 'String'>
    readonly creatorId: FieldRef<"ForumTopic", 'String'>
    readonly type: FieldRef<"ForumTopic", 'TopicType'>
    readonly isPinned: FieldRef<"ForumTopic", 'Boolean'>
    readonly isClosed: FieldRef<"ForumTopic", 'Boolean'>
    readonly viewCount: FieldRef<"ForumTopic", 'Int'>
    readonly replyCount: FieldRef<"ForumTopic", 'Int'>
    readonly lastReplyAt: FieldRef<"ForumTopic", 'DateTime'>
    readonly status: FieldRef<"ForumTopic", 'TopicStatus'>
    readonly createdAt: FieldRef<"ForumTopic", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumTopic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumTopic findUnique
   */
  export type ForumTopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopic to fetch.
     */
    where: ForumTopicWhereUniqueInput
  }

  /**
   * ForumTopic findUniqueOrThrow
   */
  export type ForumTopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopic to fetch.
     */
    where: ForumTopicWhereUniqueInput
  }

  /**
   * ForumTopic findFirst
   */
  export type ForumTopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopic to fetch.
     */
    where?: ForumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopics to fetch.
     */
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumTopics.
     */
    cursor?: ForumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumTopics.
     */
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * ForumTopic findFirstOrThrow
   */
  export type ForumTopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopic to fetch.
     */
    where?: ForumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopics to fetch.
     */
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumTopics.
     */
    cursor?: ForumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumTopics.
     */
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * ForumTopic findMany
   */
  export type ForumTopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopics to fetch.
     */
    where?: ForumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopics to fetch.
     */
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumTopics.
     */
    cursor?: ForumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopics.
     */
    skip?: number
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * ForumTopic create
   */
  export type ForumTopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumTopic.
     */
    data: XOR<ForumTopicCreateInput, ForumTopicUncheckedCreateInput>
  }

  /**
   * ForumTopic createMany
   */
  export type ForumTopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumTopics.
     */
    data: ForumTopicCreateManyInput | ForumTopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumTopic createManyAndReturn
   */
  export type ForumTopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * The data used to create many ForumTopics.
     */
    data: ForumTopicCreateManyInput | ForumTopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumTopic update
   */
  export type ForumTopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumTopic.
     */
    data: XOR<ForumTopicUpdateInput, ForumTopicUncheckedUpdateInput>
    /**
     * Choose, which ForumTopic to update.
     */
    where: ForumTopicWhereUniqueInput
  }

  /**
   * ForumTopic updateMany
   */
  export type ForumTopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumTopics.
     */
    data: XOR<ForumTopicUpdateManyMutationInput, ForumTopicUncheckedUpdateManyInput>
    /**
     * Filter which ForumTopics to update
     */
    where?: ForumTopicWhereInput
    /**
     * Limit how many ForumTopics to update.
     */
    limit?: number
  }

  /**
   * ForumTopic updateManyAndReturn
   */
  export type ForumTopicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * The data used to update ForumTopics.
     */
    data: XOR<ForumTopicUpdateManyMutationInput, ForumTopicUncheckedUpdateManyInput>
    /**
     * Filter which ForumTopics to update
     */
    where?: ForumTopicWhereInput
    /**
     * Limit how many ForumTopics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumTopic upsert
   */
  export type ForumTopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumTopic to update in case it exists.
     */
    where: ForumTopicWhereUniqueInput
    /**
     * In case the ForumTopic found by the `where` argument doesn't exist, create a new ForumTopic with this data.
     */
    create: XOR<ForumTopicCreateInput, ForumTopicUncheckedCreateInput>
    /**
     * In case the ForumTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumTopicUpdateInput, ForumTopicUncheckedUpdateInput>
  }

  /**
   * ForumTopic delete
   */
  export type ForumTopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter which ForumTopic to delete.
     */
    where: ForumTopicWhereUniqueInput
  }

  /**
   * ForumTopic deleteMany
   */
  export type ForumTopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumTopics to delete
     */
    where?: ForumTopicWhereInput
    /**
     * Limit how many ForumTopics to delete.
     */
    limit?: number
  }

  /**
   * ForumTopic.posts
   */
  export type ForumTopic$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    cursor?: ForumPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumTopic.replies
   */
  export type ForumTopic$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    where?: ForumReplyWhereInput
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    cursor?: ForumReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumReplyScalarFieldEnum | ForumReplyScalarFieldEnum[]
  }

  /**
   * ForumTopic without action
   */
  export type ForumTopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
  }


  /**
   * Model ForumReply
   */

  export type AggregateForumReply = {
    _count: ForumReplyCountAggregateOutputType | null
    _avg: ForumReplyAvgAggregateOutputType | null
    _sum: ForumReplySumAggregateOutputType | null
    _min: ForumReplyMinAggregateOutputType | null
    _max: ForumReplyMaxAggregateOutputType | null
  }

  export type ForumReplyAvgAggregateOutputType = {
    likes: number | null
  }

  export type ForumReplySumAggregateOutputType = {
    likes: number | null
  }

  export type ForumReplyMinAggregateOutputType = {
    id: string | null
    forumId: string | null
    topicId: string | null
    userId: string | null
    content: string | null
    likes: number | null
    parentReplyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumReplyMaxAggregateOutputType = {
    id: string | null
    forumId: string | null
    topicId: string | null
    userId: string | null
    content: string | null
    likes: number | null
    parentReplyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumReplyCountAggregateOutputType = {
    id: number
    forumId: number
    topicId: number
    userId: number
    content: number
    attachments: number
    likes: number
    parentReplyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumReplyAvgAggregateInputType = {
    likes?: true
  }

  export type ForumReplySumAggregateInputType = {
    likes?: true
  }

  export type ForumReplyMinAggregateInputType = {
    id?: true
    forumId?: true
    topicId?: true
    userId?: true
    content?: true
    likes?: true
    parentReplyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumReplyMaxAggregateInputType = {
    id?: true
    forumId?: true
    topicId?: true
    userId?: true
    content?: true
    likes?: true
    parentReplyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumReplyCountAggregateInputType = {
    id?: true
    forumId?: true
    topicId?: true
    userId?: true
    content?: true
    attachments?: true
    likes?: true
    parentReplyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumReply to aggregate.
     */
    where?: ForumReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplies to fetch.
     */
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumReplies
    **/
    _count?: true | ForumReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumReplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumReplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumReplyMaxAggregateInputType
  }

  export type GetForumReplyAggregateType<T extends ForumReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateForumReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumReply[P]>
      : GetScalarType<T[P], AggregateForumReply[P]>
  }




  export type ForumReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumReplyWhereInput
    orderBy?: ForumReplyOrderByWithAggregationInput | ForumReplyOrderByWithAggregationInput[]
    by: ForumReplyScalarFieldEnum[] | ForumReplyScalarFieldEnum
    having?: ForumReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumReplyCountAggregateInputType | true
    _avg?: ForumReplyAvgAggregateInputType
    _sum?: ForumReplySumAggregateInputType
    _min?: ForumReplyMinAggregateInputType
    _max?: ForumReplyMaxAggregateInputType
  }

  export type ForumReplyGroupByOutputType = {
    id: string
    forumId: string
    topicId: string
    userId: string
    content: string
    attachments: string[]
    likes: number
    parentReplyId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ForumReplyCountAggregateOutputType | null
    _avg: ForumReplyAvgAggregateOutputType | null
    _sum: ForumReplySumAggregateOutputType | null
    _min: ForumReplyMinAggregateOutputType | null
    _max: ForumReplyMaxAggregateOutputType | null
  }

  type GetForumReplyGroupByPayload<T extends ForumReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumReplyGroupByOutputType[P]>
            : GetScalarType<T[P], ForumReplyGroupByOutputType[P]>
        }
      >
    >


  export type ForumReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    forumId?: boolean
    topicId?: boolean
    userId?: boolean
    content?: boolean
    attachments?: boolean
    likes?: boolean
    parentReplyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    forum?: boolean | ForumDefaultArgs<ExtArgs>
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reactions?: boolean | ForumReply$reactionsArgs<ExtArgs>
    parentReply?: boolean | ForumReply$parentReplyArgs<ExtArgs>
    childReplies?: boolean | ForumReply$childRepliesArgs<ExtArgs>
    _count?: boolean | ForumReplyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumReply"]>

  export type ForumReplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    forumId?: boolean
    topicId?: boolean
    userId?: boolean
    content?: boolean
    attachments?: boolean
    likes?: boolean
    parentReplyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    forum?: boolean | ForumDefaultArgs<ExtArgs>
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parentReply?: boolean | ForumReply$parentReplyArgs<ExtArgs>
  }, ExtArgs["result"]["forumReply"]>

  export type ForumReplySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    forumId?: boolean
    topicId?: boolean
    userId?: boolean
    content?: boolean
    attachments?: boolean
    likes?: boolean
    parentReplyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    forum?: boolean | ForumDefaultArgs<ExtArgs>
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parentReply?: boolean | ForumReply$parentReplyArgs<ExtArgs>
  }, ExtArgs["result"]["forumReply"]>

  export type ForumReplySelectScalar = {
    id?: boolean
    forumId?: boolean
    topicId?: boolean
    userId?: boolean
    content?: boolean
    attachments?: boolean
    likes?: boolean
    parentReplyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumReplyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "forumId" | "topicId" | "userId" | "content" | "attachments" | "likes" | "parentReplyId" | "createdAt" | "updatedAt", ExtArgs["result"]["forumReply"]>
  export type ForumReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forum?: boolean | ForumDefaultArgs<ExtArgs>
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reactions?: boolean | ForumReply$reactionsArgs<ExtArgs>
    parentReply?: boolean | ForumReply$parentReplyArgs<ExtArgs>
    childReplies?: boolean | ForumReply$childRepliesArgs<ExtArgs>
    _count?: boolean | ForumReplyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumReplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forum?: boolean | ForumDefaultArgs<ExtArgs>
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parentReply?: boolean | ForumReply$parentReplyArgs<ExtArgs>
  }
  export type ForumReplyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forum?: boolean | ForumDefaultArgs<ExtArgs>
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parentReply?: boolean | ForumReply$parentReplyArgs<ExtArgs>
  }

  export type $ForumReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumReply"
    objects: {
      forum: Prisma.$ForumPayload<ExtArgs>
      topic: Prisma.$ForumTopicPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      reactions: Prisma.$ForumReplyReactionPayload<ExtArgs>[]
      parentReply: Prisma.$ForumReplyPayload<ExtArgs> | null
      childReplies: Prisma.$ForumReplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      forumId: string
      topicId: string
      userId: string
      content: string
      attachments: string[]
      likes: number
      parentReplyId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumReply"]>
    composites: {}
  }

  type ForumReplyGetPayload<S extends boolean | null | undefined | ForumReplyDefaultArgs> = $Result.GetResult<Prisma.$ForumReplyPayload, S>

  type ForumReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ForumReplyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumReplyCountAggregateInputType | true
    }

  export interface ForumReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumReply'], meta: { name: 'ForumReply' } }
    /**
     * Find zero or one ForumReply that matches the filter.
     * @param {ForumReplyFindUniqueArgs} args - Arguments to find a ForumReply
     * @example
     * // Get one ForumReply
     * const forumReply = await prisma.forumReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumReplyFindUniqueArgs>(args: SelectSubset<T, ForumReplyFindUniqueArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumReply that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ForumReplyFindUniqueOrThrowArgs} args - Arguments to find a ForumReply
     * @example
     * // Get one ForumReply
     * const forumReply = await prisma.forumReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyFindFirstArgs} args - Arguments to find a ForumReply
     * @example
     * // Get one ForumReply
     * const forumReply = await prisma.forumReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumReplyFindFirstArgs>(args?: SelectSubset<T, ForumReplyFindFirstArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyFindFirstOrThrowArgs} args - Arguments to find a ForumReply
     * @example
     * // Get one ForumReply
     * const forumReply = await prisma.forumReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumReplies
     * const forumReplies = await prisma.forumReply.findMany()
     * 
     * // Get first 10 ForumReplies
     * const forumReplies = await prisma.forumReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumReplyWithIdOnly = await prisma.forumReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumReplyFindManyArgs>(args?: SelectSubset<T, ForumReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumReply.
     * @param {ForumReplyCreateArgs} args - Arguments to create a ForumReply.
     * @example
     * // Create one ForumReply
     * const ForumReply = await prisma.forumReply.create({
     *   data: {
     *     // ... data to create a ForumReply
     *   }
     * })
     * 
     */
    create<T extends ForumReplyCreateArgs>(args: SelectSubset<T, ForumReplyCreateArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumReplies.
     * @param {ForumReplyCreateManyArgs} args - Arguments to create many ForumReplies.
     * @example
     * // Create many ForumReplies
     * const forumReply = await prisma.forumReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumReplyCreateManyArgs>(args?: SelectSubset<T, ForumReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumReplies and returns the data saved in the database.
     * @param {ForumReplyCreateManyAndReturnArgs} args - Arguments to create many ForumReplies.
     * @example
     * // Create many ForumReplies
     * const forumReply = await prisma.forumReply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumReplies and only return the `id`
     * const forumReplyWithIdOnly = await prisma.forumReply.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumReplyCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumReplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumReply.
     * @param {ForumReplyDeleteArgs} args - Arguments to delete one ForumReply.
     * @example
     * // Delete one ForumReply
     * const ForumReply = await prisma.forumReply.delete({
     *   where: {
     *     // ... filter to delete one ForumReply
     *   }
     * })
     * 
     */
    delete<T extends ForumReplyDeleteArgs>(args: SelectSubset<T, ForumReplyDeleteArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumReply.
     * @param {ForumReplyUpdateArgs} args - Arguments to update one ForumReply.
     * @example
     * // Update one ForumReply
     * const forumReply = await prisma.forumReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumReplyUpdateArgs>(args: SelectSubset<T, ForumReplyUpdateArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumReplies.
     * @param {ForumReplyDeleteManyArgs} args - Arguments to filter ForumReplies to delete.
     * @example
     * // Delete a few ForumReplies
     * const { count } = await prisma.forumReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumReplyDeleteManyArgs>(args?: SelectSubset<T, ForumReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumReplies
     * const forumReply = await prisma.forumReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumReplyUpdateManyArgs>(args: SelectSubset<T, ForumReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumReplies and returns the data updated in the database.
     * @param {ForumReplyUpdateManyAndReturnArgs} args - Arguments to update many ForumReplies.
     * @example
     * // Update many ForumReplies
     * const forumReply = await prisma.forumReply.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumReplies and only return the `id`
     * const forumReplyWithIdOnly = await prisma.forumReply.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ForumReplyUpdateManyAndReturnArgs>(args: SelectSubset<T, ForumReplyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumReply.
     * @param {ForumReplyUpsertArgs} args - Arguments to update or create a ForumReply.
     * @example
     * // Update or create a ForumReply
     * const forumReply = await prisma.forumReply.upsert({
     *   create: {
     *     // ... data to create a ForumReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumReply we want to update
     *   }
     * })
     */
    upsert<T extends ForumReplyUpsertArgs>(args: SelectSubset<T, ForumReplyUpsertArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyCountArgs} args - Arguments to filter ForumReplies to count.
     * @example
     * // Count the number of ForumReplies
     * const count = await prisma.forumReply.count({
     *   where: {
     *     // ... the filter for the ForumReplies we want to count
     *   }
     * })
    **/
    count<T extends ForumReplyCountArgs>(
      args?: Subset<T, ForumReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumReplyAggregateArgs>(args: Subset<T, ForumReplyAggregateArgs>): Prisma.PrismaPromise<GetForumReplyAggregateType<T>>

    /**
     * Group by ForumReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumReplyGroupByArgs['orderBy'] }
        : { orderBy?: ForumReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumReply model
   */
  readonly fields: ForumReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    forum<T extends ForumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumDefaultArgs<ExtArgs>>): Prisma__ForumClient<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    topic<T extends ForumTopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumTopicDefaultArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reactions<T extends ForumReply$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, ForumReply$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parentReply<T extends ForumReply$parentReplyArgs<ExtArgs> = {}>(args?: Subset<T, ForumReply$parentReplyArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    childReplies<T extends ForumReply$childRepliesArgs<ExtArgs> = {}>(args?: Subset<T, ForumReply$childRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumReply model
   */
  interface ForumReplyFieldRefs {
    readonly id: FieldRef<"ForumReply", 'String'>
    readonly forumId: FieldRef<"ForumReply", 'String'>
    readonly topicId: FieldRef<"ForumReply", 'String'>
    readonly userId: FieldRef<"ForumReply", 'String'>
    readonly content: FieldRef<"ForumReply", 'String'>
    readonly attachments: FieldRef<"ForumReply", 'String[]'>
    readonly likes: FieldRef<"ForumReply", 'Int'>
    readonly parentReplyId: FieldRef<"ForumReply", 'String'>
    readonly createdAt: FieldRef<"ForumReply", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumReply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumReply findUnique
   */
  export type ForumReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * Filter, which ForumReply to fetch.
     */
    where: ForumReplyWhereUniqueInput
  }

  /**
   * ForumReply findUniqueOrThrow
   */
  export type ForumReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * Filter, which ForumReply to fetch.
     */
    where: ForumReplyWhereUniqueInput
  }

  /**
   * ForumReply findFirst
   */
  export type ForumReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * Filter, which ForumReply to fetch.
     */
    where?: ForumReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplies to fetch.
     */
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumReplies.
     */
    cursor?: ForumReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumReplies.
     */
    distinct?: ForumReplyScalarFieldEnum | ForumReplyScalarFieldEnum[]
  }

  /**
   * ForumReply findFirstOrThrow
   */
  export type ForumReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * Filter, which ForumReply to fetch.
     */
    where?: ForumReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplies to fetch.
     */
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumReplies.
     */
    cursor?: ForumReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumReplies.
     */
    distinct?: ForumReplyScalarFieldEnum | ForumReplyScalarFieldEnum[]
  }

  /**
   * ForumReply findMany
   */
  export type ForumReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * Filter, which ForumReplies to fetch.
     */
    where?: ForumReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplies to fetch.
     */
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumReplies.
     */
    cursor?: ForumReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplies.
     */
    skip?: number
    distinct?: ForumReplyScalarFieldEnum | ForumReplyScalarFieldEnum[]
  }

  /**
   * ForumReply create
   */
  export type ForumReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumReply.
     */
    data: XOR<ForumReplyCreateInput, ForumReplyUncheckedCreateInput>
  }

  /**
   * ForumReply createMany
   */
  export type ForumReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumReplies.
     */
    data: ForumReplyCreateManyInput | ForumReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumReply createManyAndReturn
   */
  export type ForumReplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * The data used to create many ForumReplies.
     */
    data: ForumReplyCreateManyInput | ForumReplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumReply update
   */
  export type ForumReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumReply.
     */
    data: XOR<ForumReplyUpdateInput, ForumReplyUncheckedUpdateInput>
    /**
     * Choose, which ForumReply to update.
     */
    where: ForumReplyWhereUniqueInput
  }

  /**
   * ForumReply updateMany
   */
  export type ForumReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumReplies.
     */
    data: XOR<ForumReplyUpdateManyMutationInput, ForumReplyUncheckedUpdateManyInput>
    /**
     * Filter which ForumReplies to update
     */
    where?: ForumReplyWhereInput
    /**
     * Limit how many ForumReplies to update.
     */
    limit?: number
  }

  /**
   * ForumReply updateManyAndReturn
   */
  export type ForumReplyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * The data used to update ForumReplies.
     */
    data: XOR<ForumReplyUpdateManyMutationInput, ForumReplyUncheckedUpdateManyInput>
    /**
     * Filter which ForumReplies to update
     */
    where?: ForumReplyWhereInput
    /**
     * Limit how many ForumReplies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumReply upsert
   */
  export type ForumReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumReply to update in case it exists.
     */
    where: ForumReplyWhereUniqueInput
    /**
     * In case the ForumReply found by the `where` argument doesn't exist, create a new ForumReply with this data.
     */
    create: XOR<ForumReplyCreateInput, ForumReplyUncheckedCreateInput>
    /**
     * In case the ForumReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumReplyUpdateInput, ForumReplyUncheckedUpdateInput>
  }

  /**
   * ForumReply delete
   */
  export type ForumReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    /**
     * Filter which ForumReply to delete.
     */
    where: ForumReplyWhereUniqueInput
  }

  /**
   * ForumReply deleteMany
   */
  export type ForumReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumReplies to delete
     */
    where?: ForumReplyWhereInput
    /**
     * Limit how many ForumReplies to delete.
     */
    limit?: number
  }

  /**
   * ForumReply.reactions
   */
  export type ForumReply$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionInclude<ExtArgs> | null
    where?: ForumReplyReactionWhereInput
    orderBy?: ForumReplyReactionOrderByWithRelationInput | ForumReplyReactionOrderByWithRelationInput[]
    cursor?: ForumReplyReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumReplyReactionScalarFieldEnum | ForumReplyReactionScalarFieldEnum[]
  }

  /**
   * ForumReply.parentReply
   */
  export type ForumReply$parentReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    where?: ForumReplyWhereInput
  }

  /**
   * ForumReply.childReplies
   */
  export type ForumReply$childRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    where?: ForumReplyWhereInput
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    cursor?: ForumReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumReplyScalarFieldEnum | ForumReplyScalarFieldEnum[]
  }

  /**
   * ForumReply without action
   */
  export type ForumReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
  }


  /**
   * Model ForumPost
   */

  export type AggregateForumPost = {
    _count: ForumPostCountAggregateOutputType | null
    _avg: ForumPostAvgAggregateOutputType | null
    _sum: ForumPostSumAggregateOutputType | null
    _min: ForumPostMinAggregateOutputType | null
    _max: ForumPostMaxAggregateOutputType | null
  }

  export type ForumPostAvgAggregateOutputType = {
    likes: number | null
  }

  export type ForumPostSumAggregateOutputType = {
    likes: number | null
  }

  export type ForumPostMinAggregateOutputType = {
    id: string | null
    content: string | null
    topicId: string | null
    creatorId: string | null
    likes: number | null
    parentPostId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumPostMaxAggregateOutputType = {
    id: string | null
    content: string | null
    topicId: string | null
    creatorId: string | null
    likes: number | null
    parentPostId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumPostCountAggregateOutputType = {
    id: number
    content: number
    topicId: number
    creatorId: number
    likes: number
    parentPostId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumPostAvgAggregateInputType = {
    likes?: true
  }

  export type ForumPostSumAggregateInputType = {
    likes?: true
  }

  export type ForumPostMinAggregateInputType = {
    id?: true
    content?: true
    topicId?: true
    creatorId?: true
    likes?: true
    parentPostId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumPostMaxAggregateInputType = {
    id?: true
    content?: true
    topicId?: true
    creatorId?: true
    likes?: true
    parentPostId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumPostCountAggregateInputType = {
    id?: true
    content?: true
    topicId?: true
    creatorId?: true
    likes?: true
    parentPostId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPost to aggregate.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumPosts
    **/
    _count?: true | ForumPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumPostMaxAggregateInputType
  }

  export type GetForumPostAggregateType<T extends ForumPostAggregateArgs> = {
        [P in keyof T & keyof AggregateForumPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumPost[P]>
      : GetScalarType<T[P], AggregateForumPost[P]>
  }




  export type ForumPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithAggregationInput | ForumPostOrderByWithAggregationInput[]
    by: ForumPostScalarFieldEnum[] | ForumPostScalarFieldEnum
    having?: ForumPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumPostCountAggregateInputType | true
    _avg?: ForumPostAvgAggregateInputType
    _sum?: ForumPostSumAggregateInputType
    _min?: ForumPostMinAggregateInputType
    _max?: ForumPostMaxAggregateInputType
  }

  export type ForumPostGroupByOutputType = {
    id: string
    content: string
    topicId: string
    creatorId: string
    likes: number
    parentPostId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ForumPostCountAggregateOutputType | null
    _avg: ForumPostAvgAggregateOutputType | null
    _sum: ForumPostSumAggregateOutputType | null
    _min: ForumPostMinAggregateOutputType | null
    _max: ForumPostMaxAggregateOutputType | null
  }

  type GetForumPostGroupByPayload<T extends ForumPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumPostGroupByOutputType[P]>
            : GetScalarType<T[P], ForumPostGroupByOutputType[P]>
        }
      >
    >


  export type ForumPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    topicId?: boolean
    creatorId?: boolean
    likes?: boolean
    parentPostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    reactions?: boolean | ForumPost$reactionsArgs<ExtArgs>
    parentPost?: boolean | ForumPost$parentPostArgs<ExtArgs>
    replies?: boolean | ForumPost$repliesArgs<ExtArgs>
    _count?: boolean | ForumPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    topicId?: boolean
    creatorId?: boolean
    likes?: boolean
    parentPostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    parentPost?: boolean | ForumPost$parentPostArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    topicId?: boolean
    creatorId?: boolean
    likes?: boolean
    parentPostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    parentPost?: boolean | ForumPost$parentPostArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectScalar = {
    id?: boolean
    content?: boolean
    topicId?: boolean
    creatorId?: boolean
    likes?: boolean
    parentPostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "topicId" | "creatorId" | "likes" | "parentPostId" | "createdAt" | "updatedAt", ExtArgs["result"]["forumPost"]>
  export type ForumPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    reactions?: boolean | ForumPost$reactionsArgs<ExtArgs>
    parentPost?: boolean | ForumPost$parentPostArgs<ExtArgs>
    replies?: boolean | ForumPost$repliesArgs<ExtArgs>
    _count?: boolean | ForumPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    parentPost?: boolean | ForumPost$parentPostArgs<ExtArgs>
  }
  export type ForumPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    parentPost?: boolean | ForumPost$parentPostArgs<ExtArgs>
  }

  export type $ForumPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumPost"
    objects: {
      topic: Prisma.$ForumTopicPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      reactions: Prisma.$ForumPostReactionPayload<ExtArgs>[]
      parentPost: Prisma.$ForumPostPayload<ExtArgs> | null
      replies: Prisma.$ForumPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      topicId: string
      creatorId: string
      likes: number
      parentPostId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumPost"]>
    composites: {}
  }

  type ForumPostGetPayload<S extends boolean | null | undefined | ForumPostDefaultArgs> = $Result.GetResult<Prisma.$ForumPostPayload, S>

  type ForumPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ForumPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumPostCountAggregateInputType | true
    }

  export interface ForumPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumPost'], meta: { name: 'ForumPost' } }
    /**
     * Find zero or one ForumPost that matches the filter.
     * @param {ForumPostFindUniqueArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumPostFindUniqueArgs>(args: SelectSubset<T, ForumPostFindUniqueArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ForumPostFindUniqueOrThrowArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumPostFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindFirstArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumPostFindFirstArgs>(args?: SelectSubset<T, ForumPostFindFirstArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindFirstOrThrowArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumPostFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumPosts
     * const forumPosts = await prisma.forumPost.findMany()
     * 
     * // Get first 10 ForumPosts
     * const forumPosts = await prisma.forumPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumPostFindManyArgs>(args?: SelectSubset<T, ForumPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumPost.
     * @param {ForumPostCreateArgs} args - Arguments to create a ForumPost.
     * @example
     * // Create one ForumPost
     * const ForumPost = await prisma.forumPost.create({
     *   data: {
     *     // ... data to create a ForumPost
     *   }
     * })
     * 
     */
    create<T extends ForumPostCreateArgs>(args: SelectSubset<T, ForumPostCreateArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumPosts.
     * @param {ForumPostCreateManyArgs} args - Arguments to create many ForumPosts.
     * @example
     * // Create many ForumPosts
     * const forumPost = await prisma.forumPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumPostCreateManyArgs>(args?: SelectSubset<T, ForumPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumPosts and returns the data saved in the database.
     * @param {ForumPostCreateManyAndReturnArgs} args - Arguments to create many ForumPosts.
     * @example
     * // Create many ForumPosts
     * const forumPost = await prisma.forumPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumPosts and only return the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumPostCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumPost.
     * @param {ForumPostDeleteArgs} args - Arguments to delete one ForumPost.
     * @example
     * // Delete one ForumPost
     * const ForumPost = await prisma.forumPost.delete({
     *   where: {
     *     // ... filter to delete one ForumPost
     *   }
     * })
     * 
     */
    delete<T extends ForumPostDeleteArgs>(args: SelectSubset<T, ForumPostDeleteArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumPost.
     * @param {ForumPostUpdateArgs} args - Arguments to update one ForumPost.
     * @example
     * // Update one ForumPost
     * const forumPost = await prisma.forumPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumPostUpdateArgs>(args: SelectSubset<T, ForumPostUpdateArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumPosts.
     * @param {ForumPostDeleteManyArgs} args - Arguments to filter ForumPosts to delete.
     * @example
     * // Delete a few ForumPosts
     * const { count } = await prisma.forumPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumPostDeleteManyArgs>(args?: SelectSubset<T, ForumPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumPosts
     * const forumPost = await prisma.forumPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumPostUpdateManyArgs>(args: SelectSubset<T, ForumPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumPosts and returns the data updated in the database.
     * @param {ForumPostUpdateManyAndReturnArgs} args - Arguments to update many ForumPosts.
     * @example
     * // Update many ForumPosts
     * const forumPost = await prisma.forumPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumPosts and only return the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ForumPostUpdateManyAndReturnArgs>(args: SelectSubset<T, ForumPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumPost.
     * @param {ForumPostUpsertArgs} args - Arguments to update or create a ForumPost.
     * @example
     * // Update or create a ForumPost
     * const forumPost = await prisma.forumPost.upsert({
     *   create: {
     *     // ... data to create a ForumPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumPost we want to update
     *   }
     * })
     */
    upsert<T extends ForumPostUpsertArgs>(args: SelectSubset<T, ForumPostUpsertArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostCountArgs} args - Arguments to filter ForumPosts to count.
     * @example
     * // Count the number of ForumPosts
     * const count = await prisma.forumPost.count({
     *   where: {
     *     // ... the filter for the ForumPosts we want to count
     *   }
     * })
    **/
    count<T extends ForumPostCountArgs>(
      args?: Subset<T, ForumPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumPostAggregateArgs>(args: Subset<T, ForumPostAggregateArgs>): Prisma.PrismaPromise<GetForumPostAggregateType<T>>

    /**
     * Group by ForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumPostGroupByArgs['orderBy'] }
        : { orderBy?: ForumPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumPost model
   */
  readonly fields: ForumPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends ForumTopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumTopicDefaultArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reactions<T extends ForumPost$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, ForumPost$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parentPost<T extends ForumPost$parentPostArgs<ExtArgs> = {}>(args?: Subset<T, ForumPost$parentPostArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends ForumPost$repliesArgs<ExtArgs> = {}>(args?: Subset<T, ForumPost$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumPost model
   */
  interface ForumPostFieldRefs {
    readonly id: FieldRef<"ForumPost", 'String'>
    readonly content: FieldRef<"ForumPost", 'String'>
    readonly topicId: FieldRef<"ForumPost", 'String'>
    readonly creatorId: FieldRef<"ForumPost", 'String'>
    readonly likes: FieldRef<"ForumPost", 'Int'>
    readonly parentPostId: FieldRef<"ForumPost", 'String'>
    readonly createdAt: FieldRef<"ForumPost", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumPost findUnique
   */
  export type ForumPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost findUniqueOrThrow
   */
  export type ForumPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost findFirst
   */
  export type ForumPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost findFirstOrThrow
   */
  export type ForumPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost findMany
   */
  export type ForumPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPosts to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost create
   */
  export type ForumPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumPost.
     */
    data: XOR<ForumPostCreateInput, ForumPostUncheckedCreateInput>
  }

  /**
   * ForumPost createMany
   */
  export type ForumPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumPosts.
     */
    data: ForumPostCreateManyInput | ForumPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumPost createManyAndReturn
   */
  export type ForumPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * The data used to create many ForumPosts.
     */
    data: ForumPostCreateManyInput | ForumPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumPost update
   */
  export type ForumPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumPost.
     */
    data: XOR<ForumPostUpdateInput, ForumPostUncheckedUpdateInput>
    /**
     * Choose, which ForumPost to update.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost updateMany
   */
  export type ForumPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumPosts.
     */
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyInput>
    /**
     * Filter which ForumPosts to update
     */
    where?: ForumPostWhereInput
    /**
     * Limit how many ForumPosts to update.
     */
    limit?: number
  }

  /**
   * ForumPost updateManyAndReturn
   */
  export type ForumPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * The data used to update ForumPosts.
     */
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyInput>
    /**
     * Filter which ForumPosts to update
     */
    where?: ForumPostWhereInput
    /**
     * Limit how many ForumPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumPost upsert
   */
  export type ForumPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumPost to update in case it exists.
     */
    where: ForumPostWhereUniqueInput
    /**
     * In case the ForumPost found by the `where` argument doesn't exist, create a new ForumPost with this data.
     */
    create: XOR<ForumPostCreateInput, ForumPostUncheckedCreateInput>
    /**
     * In case the ForumPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumPostUpdateInput, ForumPostUncheckedUpdateInput>
  }

  /**
   * ForumPost delete
   */
  export type ForumPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter which ForumPost to delete.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost deleteMany
   */
  export type ForumPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPosts to delete
     */
    where?: ForumPostWhereInput
    /**
     * Limit how many ForumPosts to delete.
     */
    limit?: number
  }

  /**
   * ForumPost.reactions
   */
  export type ForumPost$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionInclude<ExtArgs> | null
    where?: ForumPostReactionWhereInput
    orderBy?: ForumPostReactionOrderByWithRelationInput | ForumPostReactionOrderByWithRelationInput[]
    cursor?: ForumPostReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumPostReactionScalarFieldEnum | ForumPostReactionScalarFieldEnum[]
  }

  /**
   * ForumPost.parentPost
   */
  export type ForumPost$parentPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    where?: ForumPostWhereInput
  }

  /**
   * ForumPost.replies
   */
  export type ForumPost$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    cursor?: ForumPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost without action
   */
  export type ForumPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
  }


  /**
   * Model ForumReplyReaction
   */

  export type AggregateForumReplyReaction = {
    _count: ForumReplyReactionCountAggregateOutputType | null
    _min: ForumReplyReactionMinAggregateOutputType | null
    _max: ForumReplyReactionMaxAggregateOutputType | null
  }

  export type ForumReplyReactionMinAggregateOutputType = {
    id: string | null
    forumReplyId: string | null
    userId: string | null
    type: $Enums.ReactionType | null
  }

  export type ForumReplyReactionMaxAggregateOutputType = {
    id: string | null
    forumReplyId: string | null
    userId: string | null
    type: $Enums.ReactionType | null
  }

  export type ForumReplyReactionCountAggregateOutputType = {
    id: number
    forumReplyId: number
    userId: number
    type: number
    _all: number
  }


  export type ForumReplyReactionMinAggregateInputType = {
    id?: true
    forumReplyId?: true
    userId?: true
    type?: true
  }

  export type ForumReplyReactionMaxAggregateInputType = {
    id?: true
    forumReplyId?: true
    userId?: true
    type?: true
  }

  export type ForumReplyReactionCountAggregateInputType = {
    id?: true
    forumReplyId?: true
    userId?: true
    type?: true
    _all?: true
  }

  export type ForumReplyReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumReplyReaction to aggregate.
     */
    where?: ForumReplyReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplyReactions to fetch.
     */
    orderBy?: ForumReplyReactionOrderByWithRelationInput | ForumReplyReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumReplyReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplyReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplyReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumReplyReactions
    **/
    _count?: true | ForumReplyReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumReplyReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumReplyReactionMaxAggregateInputType
  }

  export type GetForumReplyReactionAggregateType<T extends ForumReplyReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateForumReplyReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumReplyReaction[P]>
      : GetScalarType<T[P], AggregateForumReplyReaction[P]>
  }




  export type ForumReplyReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumReplyReactionWhereInput
    orderBy?: ForumReplyReactionOrderByWithAggregationInput | ForumReplyReactionOrderByWithAggregationInput[]
    by: ForumReplyReactionScalarFieldEnum[] | ForumReplyReactionScalarFieldEnum
    having?: ForumReplyReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumReplyReactionCountAggregateInputType | true
    _min?: ForumReplyReactionMinAggregateInputType
    _max?: ForumReplyReactionMaxAggregateInputType
  }

  export type ForumReplyReactionGroupByOutputType = {
    id: string
    forumReplyId: string
    userId: string
    type: $Enums.ReactionType
    _count: ForumReplyReactionCountAggregateOutputType | null
    _min: ForumReplyReactionMinAggregateOutputType | null
    _max: ForumReplyReactionMaxAggregateOutputType | null
  }

  type GetForumReplyReactionGroupByPayload<T extends ForumReplyReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumReplyReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumReplyReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumReplyReactionGroupByOutputType[P]>
            : GetScalarType<T[P], ForumReplyReactionGroupByOutputType[P]>
        }
      >
    >


  export type ForumReplyReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    forumReplyId?: boolean
    userId?: boolean
    type?: boolean
    forumReply?: boolean | ForumReplyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumReplyReaction"]>

  export type ForumReplyReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    forumReplyId?: boolean
    userId?: boolean
    type?: boolean
    forumReply?: boolean | ForumReplyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumReplyReaction"]>

  export type ForumReplyReactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    forumReplyId?: boolean
    userId?: boolean
    type?: boolean
    forumReply?: boolean | ForumReplyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumReplyReaction"]>

  export type ForumReplyReactionSelectScalar = {
    id?: boolean
    forumReplyId?: boolean
    userId?: boolean
    type?: boolean
  }

  export type ForumReplyReactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "forumReplyId" | "userId" | "type", ExtArgs["result"]["forumReplyReaction"]>
  export type ForumReplyReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forumReply?: boolean | ForumReplyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ForumReplyReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forumReply?: boolean | ForumReplyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ForumReplyReactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forumReply?: boolean | ForumReplyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ForumReplyReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumReplyReaction"
    objects: {
      forumReply: Prisma.$ForumReplyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      forumReplyId: string
      userId: string
      type: $Enums.ReactionType
    }, ExtArgs["result"]["forumReplyReaction"]>
    composites: {}
  }

  type ForumReplyReactionGetPayload<S extends boolean | null | undefined | ForumReplyReactionDefaultArgs> = $Result.GetResult<Prisma.$ForumReplyReactionPayload, S>

  type ForumReplyReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ForumReplyReactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumReplyReactionCountAggregateInputType | true
    }

  export interface ForumReplyReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumReplyReaction'], meta: { name: 'ForumReplyReaction' } }
    /**
     * Find zero or one ForumReplyReaction that matches the filter.
     * @param {ForumReplyReactionFindUniqueArgs} args - Arguments to find a ForumReplyReaction
     * @example
     * // Get one ForumReplyReaction
     * const forumReplyReaction = await prisma.forumReplyReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumReplyReactionFindUniqueArgs>(args: SelectSubset<T, ForumReplyReactionFindUniqueArgs<ExtArgs>>): Prisma__ForumReplyReactionClient<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumReplyReaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ForumReplyReactionFindUniqueOrThrowArgs} args - Arguments to find a ForumReplyReaction
     * @example
     * // Get one ForumReplyReaction
     * const forumReplyReaction = await prisma.forumReplyReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumReplyReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumReplyReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumReplyReactionClient<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumReplyReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyReactionFindFirstArgs} args - Arguments to find a ForumReplyReaction
     * @example
     * // Get one ForumReplyReaction
     * const forumReplyReaction = await prisma.forumReplyReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumReplyReactionFindFirstArgs>(args?: SelectSubset<T, ForumReplyReactionFindFirstArgs<ExtArgs>>): Prisma__ForumReplyReactionClient<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumReplyReaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyReactionFindFirstOrThrowArgs} args - Arguments to find a ForumReplyReaction
     * @example
     * // Get one ForumReplyReaction
     * const forumReplyReaction = await prisma.forumReplyReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumReplyReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumReplyReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumReplyReactionClient<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumReplyReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumReplyReactions
     * const forumReplyReactions = await prisma.forumReplyReaction.findMany()
     * 
     * // Get first 10 ForumReplyReactions
     * const forumReplyReactions = await prisma.forumReplyReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumReplyReactionWithIdOnly = await prisma.forumReplyReaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumReplyReactionFindManyArgs>(args?: SelectSubset<T, ForumReplyReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumReplyReaction.
     * @param {ForumReplyReactionCreateArgs} args - Arguments to create a ForumReplyReaction.
     * @example
     * // Create one ForumReplyReaction
     * const ForumReplyReaction = await prisma.forumReplyReaction.create({
     *   data: {
     *     // ... data to create a ForumReplyReaction
     *   }
     * })
     * 
     */
    create<T extends ForumReplyReactionCreateArgs>(args: SelectSubset<T, ForumReplyReactionCreateArgs<ExtArgs>>): Prisma__ForumReplyReactionClient<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumReplyReactions.
     * @param {ForumReplyReactionCreateManyArgs} args - Arguments to create many ForumReplyReactions.
     * @example
     * // Create many ForumReplyReactions
     * const forumReplyReaction = await prisma.forumReplyReaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumReplyReactionCreateManyArgs>(args?: SelectSubset<T, ForumReplyReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumReplyReactions and returns the data saved in the database.
     * @param {ForumReplyReactionCreateManyAndReturnArgs} args - Arguments to create many ForumReplyReactions.
     * @example
     * // Create many ForumReplyReactions
     * const forumReplyReaction = await prisma.forumReplyReaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumReplyReactions and only return the `id`
     * const forumReplyReactionWithIdOnly = await prisma.forumReplyReaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumReplyReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumReplyReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumReplyReaction.
     * @param {ForumReplyReactionDeleteArgs} args - Arguments to delete one ForumReplyReaction.
     * @example
     * // Delete one ForumReplyReaction
     * const ForumReplyReaction = await prisma.forumReplyReaction.delete({
     *   where: {
     *     // ... filter to delete one ForumReplyReaction
     *   }
     * })
     * 
     */
    delete<T extends ForumReplyReactionDeleteArgs>(args: SelectSubset<T, ForumReplyReactionDeleteArgs<ExtArgs>>): Prisma__ForumReplyReactionClient<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumReplyReaction.
     * @param {ForumReplyReactionUpdateArgs} args - Arguments to update one ForumReplyReaction.
     * @example
     * // Update one ForumReplyReaction
     * const forumReplyReaction = await prisma.forumReplyReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumReplyReactionUpdateArgs>(args: SelectSubset<T, ForumReplyReactionUpdateArgs<ExtArgs>>): Prisma__ForumReplyReactionClient<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumReplyReactions.
     * @param {ForumReplyReactionDeleteManyArgs} args - Arguments to filter ForumReplyReactions to delete.
     * @example
     * // Delete a few ForumReplyReactions
     * const { count } = await prisma.forumReplyReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumReplyReactionDeleteManyArgs>(args?: SelectSubset<T, ForumReplyReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumReplyReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumReplyReactions
     * const forumReplyReaction = await prisma.forumReplyReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumReplyReactionUpdateManyArgs>(args: SelectSubset<T, ForumReplyReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumReplyReactions and returns the data updated in the database.
     * @param {ForumReplyReactionUpdateManyAndReturnArgs} args - Arguments to update many ForumReplyReactions.
     * @example
     * // Update many ForumReplyReactions
     * const forumReplyReaction = await prisma.forumReplyReaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumReplyReactions and only return the `id`
     * const forumReplyReactionWithIdOnly = await prisma.forumReplyReaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ForumReplyReactionUpdateManyAndReturnArgs>(args: SelectSubset<T, ForumReplyReactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumReplyReaction.
     * @param {ForumReplyReactionUpsertArgs} args - Arguments to update or create a ForumReplyReaction.
     * @example
     * // Update or create a ForumReplyReaction
     * const forumReplyReaction = await prisma.forumReplyReaction.upsert({
     *   create: {
     *     // ... data to create a ForumReplyReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumReplyReaction we want to update
     *   }
     * })
     */
    upsert<T extends ForumReplyReactionUpsertArgs>(args: SelectSubset<T, ForumReplyReactionUpsertArgs<ExtArgs>>): Prisma__ForumReplyReactionClient<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumReplyReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyReactionCountArgs} args - Arguments to filter ForumReplyReactions to count.
     * @example
     * // Count the number of ForumReplyReactions
     * const count = await prisma.forumReplyReaction.count({
     *   where: {
     *     // ... the filter for the ForumReplyReactions we want to count
     *   }
     * })
    **/
    count<T extends ForumReplyReactionCountArgs>(
      args?: Subset<T, ForumReplyReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumReplyReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumReplyReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumReplyReactionAggregateArgs>(args: Subset<T, ForumReplyReactionAggregateArgs>): Prisma.PrismaPromise<GetForumReplyReactionAggregateType<T>>

    /**
     * Group by ForumReplyReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumReplyReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumReplyReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumReplyReactionGroupByArgs['orderBy'] }
        : { orderBy?: ForumReplyReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumReplyReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumReplyReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumReplyReaction model
   */
  readonly fields: ForumReplyReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumReplyReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumReplyReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    forumReply<T extends ForumReplyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumReplyDefaultArgs<ExtArgs>>): Prisma__ForumReplyClient<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumReplyReaction model
   */
  interface ForumReplyReactionFieldRefs {
    readonly id: FieldRef<"ForumReplyReaction", 'String'>
    readonly forumReplyId: FieldRef<"ForumReplyReaction", 'String'>
    readonly userId: FieldRef<"ForumReplyReaction", 'String'>
    readonly type: FieldRef<"ForumReplyReaction", 'ReactionType'>
  }
    

  // Custom InputTypes
  /**
   * ForumReplyReaction findUnique
   */
  export type ForumReplyReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionInclude<ExtArgs> | null
    /**
     * Filter, which ForumReplyReaction to fetch.
     */
    where: ForumReplyReactionWhereUniqueInput
  }

  /**
   * ForumReplyReaction findUniqueOrThrow
   */
  export type ForumReplyReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionInclude<ExtArgs> | null
    /**
     * Filter, which ForumReplyReaction to fetch.
     */
    where: ForumReplyReactionWhereUniqueInput
  }

  /**
   * ForumReplyReaction findFirst
   */
  export type ForumReplyReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionInclude<ExtArgs> | null
    /**
     * Filter, which ForumReplyReaction to fetch.
     */
    where?: ForumReplyReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplyReactions to fetch.
     */
    orderBy?: ForumReplyReactionOrderByWithRelationInput | ForumReplyReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumReplyReactions.
     */
    cursor?: ForumReplyReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplyReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplyReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumReplyReactions.
     */
    distinct?: ForumReplyReactionScalarFieldEnum | ForumReplyReactionScalarFieldEnum[]
  }

  /**
   * ForumReplyReaction findFirstOrThrow
   */
  export type ForumReplyReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionInclude<ExtArgs> | null
    /**
     * Filter, which ForumReplyReaction to fetch.
     */
    where?: ForumReplyReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplyReactions to fetch.
     */
    orderBy?: ForumReplyReactionOrderByWithRelationInput | ForumReplyReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumReplyReactions.
     */
    cursor?: ForumReplyReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplyReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplyReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumReplyReactions.
     */
    distinct?: ForumReplyReactionScalarFieldEnum | ForumReplyReactionScalarFieldEnum[]
  }

  /**
   * ForumReplyReaction findMany
   */
  export type ForumReplyReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionInclude<ExtArgs> | null
    /**
     * Filter, which ForumReplyReactions to fetch.
     */
    where?: ForumReplyReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumReplyReactions to fetch.
     */
    orderBy?: ForumReplyReactionOrderByWithRelationInput | ForumReplyReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumReplyReactions.
     */
    cursor?: ForumReplyReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumReplyReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumReplyReactions.
     */
    skip?: number
    distinct?: ForumReplyReactionScalarFieldEnum | ForumReplyReactionScalarFieldEnum[]
  }

  /**
   * ForumReplyReaction create
   */
  export type ForumReplyReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumReplyReaction.
     */
    data: XOR<ForumReplyReactionCreateInput, ForumReplyReactionUncheckedCreateInput>
  }

  /**
   * ForumReplyReaction createMany
   */
  export type ForumReplyReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumReplyReactions.
     */
    data: ForumReplyReactionCreateManyInput | ForumReplyReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumReplyReaction createManyAndReturn
   */
  export type ForumReplyReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * The data used to create many ForumReplyReactions.
     */
    data: ForumReplyReactionCreateManyInput | ForumReplyReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumReplyReaction update
   */
  export type ForumReplyReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumReplyReaction.
     */
    data: XOR<ForumReplyReactionUpdateInput, ForumReplyReactionUncheckedUpdateInput>
    /**
     * Choose, which ForumReplyReaction to update.
     */
    where: ForumReplyReactionWhereUniqueInput
  }

  /**
   * ForumReplyReaction updateMany
   */
  export type ForumReplyReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumReplyReactions.
     */
    data: XOR<ForumReplyReactionUpdateManyMutationInput, ForumReplyReactionUncheckedUpdateManyInput>
    /**
     * Filter which ForumReplyReactions to update
     */
    where?: ForumReplyReactionWhereInput
    /**
     * Limit how many ForumReplyReactions to update.
     */
    limit?: number
  }

  /**
   * ForumReplyReaction updateManyAndReturn
   */
  export type ForumReplyReactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * The data used to update ForumReplyReactions.
     */
    data: XOR<ForumReplyReactionUpdateManyMutationInput, ForumReplyReactionUncheckedUpdateManyInput>
    /**
     * Filter which ForumReplyReactions to update
     */
    where?: ForumReplyReactionWhereInput
    /**
     * Limit how many ForumReplyReactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumReplyReaction upsert
   */
  export type ForumReplyReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumReplyReaction to update in case it exists.
     */
    where: ForumReplyReactionWhereUniqueInput
    /**
     * In case the ForumReplyReaction found by the `where` argument doesn't exist, create a new ForumReplyReaction with this data.
     */
    create: XOR<ForumReplyReactionCreateInput, ForumReplyReactionUncheckedCreateInput>
    /**
     * In case the ForumReplyReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumReplyReactionUpdateInput, ForumReplyReactionUncheckedUpdateInput>
  }

  /**
   * ForumReplyReaction delete
   */
  export type ForumReplyReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionInclude<ExtArgs> | null
    /**
     * Filter which ForumReplyReaction to delete.
     */
    where: ForumReplyReactionWhereUniqueInput
  }

  /**
   * ForumReplyReaction deleteMany
   */
  export type ForumReplyReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumReplyReactions to delete
     */
    where?: ForumReplyReactionWhereInput
    /**
     * Limit how many ForumReplyReactions to delete.
     */
    limit?: number
  }

  /**
   * ForumReplyReaction without action
   */
  export type ForumReplyReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionInclude<ExtArgs> | null
  }


  /**
   * Model ForumPostReaction
   */

  export type AggregateForumPostReaction = {
    _count: ForumPostReactionCountAggregateOutputType | null
    _min: ForumPostReactionMinAggregateOutputType | null
    _max: ForumPostReactionMaxAggregateOutputType | null
  }

  export type ForumPostReactionMinAggregateOutputType = {
    id: string | null
    forumPostId: string | null
    userId: string | null
    type: $Enums.ReactionType | null
  }

  export type ForumPostReactionMaxAggregateOutputType = {
    id: string | null
    forumPostId: string | null
    userId: string | null
    type: $Enums.ReactionType | null
  }

  export type ForumPostReactionCountAggregateOutputType = {
    id: number
    forumPostId: number
    userId: number
    type: number
    _all: number
  }


  export type ForumPostReactionMinAggregateInputType = {
    id?: true
    forumPostId?: true
    userId?: true
    type?: true
  }

  export type ForumPostReactionMaxAggregateInputType = {
    id?: true
    forumPostId?: true
    userId?: true
    type?: true
  }

  export type ForumPostReactionCountAggregateInputType = {
    id?: true
    forumPostId?: true
    userId?: true
    type?: true
    _all?: true
  }

  export type ForumPostReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPostReaction to aggregate.
     */
    where?: ForumPostReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPostReactions to fetch.
     */
    orderBy?: ForumPostReactionOrderByWithRelationInput | ForumPostReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumPostReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPostReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPostReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumPostReactions
    **/
    _count?: true | ForumPostReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumPostReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumPostReactionMaxAggregateInputType
  }

  export type GetForumPostReactionAggregateType<T extends ForumPostReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateForumPostReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumPostReaction[P]>
      : GetScalarType<T[P], AggregateForumPostReaction[P]>
  }




  export type ForumPostReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostReactionWhereInput
    orderBy?: ForumPostReactionOrderByWithAggregationInput | ForumPostReactionOrderByWithAggregationInput[]
    by: ForumPostReactionScalarFieldEnum[] | ForumPostReactionScalarFieldEnum
    having?: ForumPostReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumPostReactionCountAggregateInputType | true
    _min?: ForumPostReactionMinAggregateInputType
    _max?: ForumPostReactionMaxAggregateInputType
  }

  export type ForumPostReactionGroupByOutputType = {
    id: string
    forumPostId: string
    userId: string
    type: $Enums.ReactionType
    _count: ForumPostReactionCountAggregateOutputType | null
    _min: ForumPostReactionMinAggregateOutputType | null
    _max: ForumPostReactionMaxAggregateOutputType | null
  }

  type GetForumPostReactionGroupByPayload<T extends ForumPostReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumPostReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumPostReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumPostReactionGroupByOutputType[P]>
            : GetScalarType<T[P], ForumPostReactionGroupByOutputType[P]>
        }
      >
    >


  export type ForumPostReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    forumPostId?: boolean
    userId?: boolean
    type?: boolean
    forumPost?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPostReaction"]>

  export type ForumPostReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    forumPostId?: boolean
    userId?: boolean
    type?: boolean
    forumPost?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPostReaction"]>

  export type ForumPostReactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    forumPostId?: boolean
    userId?: boolean
    type?: boolean
    forumPost?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPostReaction"]>

  export type ForumPostReactionSelectScalar = {
    id?: boolean
    forumPostId?: boolean
    userId?: boolean
    type?: boolean
  }

  export type ForumPostReactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "forumPostId" | "userId" | "type", ExtArgs["result"]["forumPostReaction"]>
  export type ForumPostReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forumPost?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ForumPostReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forumPost?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ForumPostReactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    forumPost?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ForumPostReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumPostReaction"
    objects: {
      forumPost: Prisma.$ForumPostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      forumPostId: string
      userId: string
      type: $Enums.ReactionType
    }, ExtArgs["result"]["forumPostReaction"]>
    composites: {}
  }

  type ForumPostReactionGetPayload<S extends boolean | null | undefined | ForumPostReactionDefaultArgs> = $Result.GetResult<Prisma.$ForumPostReactionPayload, S>

  type ForumPostReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ForumPostReactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumPostReactionCountAggregateInputType | true
    }

  export interface ForumPostReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumPostReaction'], meta: { name: 'ForumPostReaction' } }
    /**
     * Find zero or one ForumPostReaction that matches the filter.
     * @param {ForumPostReactionFindUniqueArgs} args - Arguments to find a ForumPostReaction
     * @example
     * // Get one ForumPostReaction
     * const forumPostReaction = await prisma.forumPostReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumPostReactionFindUniqueArgs>(args: SelectSubset<T, ForumPostReactionFindUniqueArgs<ExtArgs>>): Prisma__ForumPostReactionClient<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumPostReaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ForumPostReactionFindUniqueOrThrowArgs} args - Arguments to find a ForumPostReaction
     * @example
     * // Get one ForumPostReaction
     * const forumPostReaction = await prisma.forumPostReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumPostReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumPostReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumPostReactionClient<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumPostReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostReactionFindFirstArgs} args - Arguments to find a ForumPostReaction
     * @example
     * // Get one ForumPostReaction
     * const forumPostReaction = await prisma.forumPostReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumPostReactionFindFirstArgs>(args?: SelectSubset<T, ForumPostReactionFindFirstArgs<ExtArgs>>): Prisma__ForumPostReactionClient<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumPostReaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostReactionFindFirstOrThrowArgs} args - Arguments to find a ForumPostReaction
     * @example
     * // Get one ForumPostReaction
     * const forumPostReaction = await prisma.forumPostReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumPostReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumPostReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumPostReactionClient<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumPostReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumPostReactions
     * const forumPostReactions = await prisma.forumPostReaction.findMany()
     * 
     * // Get first 10 ForumPostReactions
     * const forumPostReactions = await prisma.forumPostReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumPostReactionWithIdOnly = await prisma.forumPostReaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumPostReactionFindManyArgs>(args?: SelectSubset<T, ForumPostReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumPostReaction.
     * @param {ForumPostReactionCreateArgs} args - Arguments to create a ForumPostReaction.
     * @example
     * // Create one ForumPostReaction
     * const ForumPostReaction = await prisma.forumPostReaction.create({
     *   data: {
     *     // ... data to create a ForumPostReaction
     *   }
     * })
     * 
     */
    create<T extends ForumPostReactionCreateArgs>(args: SelectSubset<T, ForumPostReactionCreateArgs<ExtArgs>>): Prisma__ForumPostReactionClient<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumPostReactions.
     * @param {ForumPostReactionCreateManyArgs} args - Arguments to create many ForumPostReactions.
     * @example
     * // Create many ForumPostReactions
     * const forumPostReaction = await prisma.forumPostReaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumPostReactionCreateManyArgs>(args?: SelectSubset<T, ForumPostReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumPostReactions and returns the data saved in the database.
     * @param {ForumPostReactionCreateManyAndReturnArgs} args - Arguments to create many ForumPostReactions.
     * @example
     * // Create many ForumPostReactions
     * const forumPostReaction = await prisma.forumPostReaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumPostReactions and only return the `id`
     * const forumPostReactionWithIdOnly = await prisma.forumPostReaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumPostReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumPostReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumPostReaction.
     * @param {ForumPostReactionDeleteArgs} args - Arguments to delete one ForumPostReaction.
     * @example
     * // Delete one ForumPostReaction
     * const ForumPostReaction = await prisma.forumPostReaction.delete({
     *   where: {
     *     // ... filter to delete one ForumPostReaction
     *   }
     * })
     * 
     */
    delete<T extends ForumPostReactionDeleteArgs>(args: SelectSubset<T, ForumPostReactionDeleteArgs<ExtArgs>>): Prisma__ForumPostReactionClient<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumPostReaction.
     * @param {ForumPostReactionUpdateArgs} args - Arguments to update one ForumPostReaction.
     * @example
     * // Update one ForumPostReaction
     * const forumPostReaction = await prisma.forumPostReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumPostReactionUpdateArgs>(args: SelectSubset<T, ForumPostReactionUpdateArgs<ExtArgs>>): Prisma__ForumPostReactionClient<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumPostReactions.
     * @param {ForumPostReactionDeleteManyArgs} args - Arguments to filter ForumPostReactions to delete.
     * @example
     * // Delete a few ForumPostReactions
     * const { count } = await prisma.forumPostReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumPostReactionDeleteManyArgs>(args?: SelectSubset<T, ForumPostReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumPostReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumPostReactions
     * const forumPostReaction = await prisma.forumPostReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumPostReactionUpdateManyArgs>(args: SelectSubset<T, ForumPostReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumPostReactions and returns the data updated in the database.
     * @param {ForumPostReactionUpdateManyAndReturnArgs} args - Arguments to update many ForumPostReactions.
     * @example
     * // Update many ForumPostReactions
     * const forumPostReaction = await prisma.forumPostReaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumPostReactions and only return the `id`
     * const forumPostReactionWithIdOnly = await prisma.forumPostReaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ForumPostReactionUpdateManyAndReturnArgs>(args: SelectSubset<T, ForumPostReactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumPostReaction.
     * @param {ForumPostReactionUpsertArgs} args - Arguments to update or create a ForumPostReaction.
     * @example
     * // Update or create a ForumPostReaction
     * const forumPostReaction = await prisma.forumPostReaction.upsert({
     *   create: {
     *     // ... data to create a ForumPostReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumPostReaction we want to update
     *   }
     * })
     */
    upsert<T extends ForumPostReactionUpsertArgs>(args: SelectSubset<T, ForumPostReactionUpsertArgs<ExtArgs>>): Prisma__ForumPostReactionClient<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumPostReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostReactionCountArgs} args - Arguments to filter ForumPostReactions to count.
     * @example
     * // Count the number of ForumPostReactions
     * const count = await prisma.forumPostReaction.count({
     *   where: {
     *     // ... the filter for the ForumPostReactions we want to count
     *   }
     * })
    **/
    count<T extends ForumPostReactionCountArgs>(
      args?: Subset<T, ForumPostReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumPostReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumPostReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumPostReactionAggregateArgs>(args: Subset<T, ForumPostReactionAggregateArgs>): Prisma.PrismaPromise<GetForumPostReactionAggregateType<T>>

    /**
     * Group by ForumPostReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumPostReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumPostReactionGroupByArgs['orderBy'] }
        : { orderBy?: ForumPostReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumPostReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumPostReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumPostReaction model
   */
  readonly fields: ForumPostReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumPostReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumPostReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    forumPost<T extends ForumPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumPostDefaultArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumPostReaction model
   */
  interface ForumPostReactionFieldRefs {
    readonly id: FieldRef<"ForumPostReaction", 'String'>
    readonly forumPostId: FieldRef<"ForumPostReaction", 'String'>
    readonly userId: FieldRef<"ForumPostReaction", 'String'>
    readonly type: FieldRef<"ForumPostReaction", 'ReactionType'>
  }
    

  // Custom InputTypes
  /**
   * ForumPostReaction findUnique
   */
  export type ForumPostReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionInclude<ExtArgs> | null
    /**
     * Filter, which ForumPostReaction to fetch.
     */
    where: ForumPostReactionWhereUniqueInput
  }

  /**
   * ForumPostReaction findUniqueOrThrow
   */
  export type ForumPostReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionInclude<ExtArgs> | null
    /**
     * Filter, which ForumPostReaction to fetch.
     */
    where: ForumPostReactionWhereUniqueInput
  }

  /**
   * ForumPostReaction findFirst
   */
  export type ForumPostReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionInclude<ExtArgs> | null
    /**
     * Filter, which ForumPostReaction to fetch.
     */
    where?: ForumPostReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPostReactions to fetch.
     */
    orderBy?: ForumPostReactionOrderByWithRelationInput | ForumPostReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPostReactions.
     */
    cursor?: ForumPostReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPostReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPostReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPostReactions.
     */
    distinct?: ForumPostReactionScalarFieldEnum | ForumPostReactionScalarFieldEnum[]
  }

  /**
   * ForumPostReaction findFirstOrThrow
   */
  export type ForumPostReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionInclude<ExtArgs> | null
    /**
     * Filter, which ForumPostReaction to fetch.
     */
    where?: ForumPostReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPostReactions to fetch.
     */
    orderBy?: ForumPostReactionOrderByWithRelationInput | ForumPostReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPostReactions.
     */
    cursor?: ForumPostReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPostReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPostReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPostReactions.
     */
    distinct?: ForumPostReactionScalarFieldEnum | ForumPostReactionScalarFieldEnum[]
  }

  /**
   * ForumPostReaction findMany
   */
  export type ForumPostReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionInclude<ExtArgs> | null
    /**
     * Filter, which ForumPostReactions to fetch.
     */
    where?: ForumPostReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPostReactions to fetch.
     */
    orderBy?: ForumPostReactionOrderByWithRelationInput | ForumPostReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumPostReactions.
     */
    cursor?: ForumPostReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPostReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPostReactions.
     */
    skip?: number
    distinct?: ForumPostReactionScalarFieldEnum | ForumPostReactionScalarFieldEnum[]
  }

  /**
   * ForumPostReaction create
   */
  export type ForumPostReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumPostReaction.
     */
    data: XOR<ForumPostReactionCreateInput, ForumPostReactionUncheckedCreateInput>
  }

  /**
   * ForumPostReaction createMany
   */
  export type ForumPostReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumPostReactions.
     */
    data: ForumPostReactionCreateManyInput | ForumPostReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumPostReaction createManyAndReturn
   */
  export type ForumPostReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * The data used to create many ForumPostReactions.
     */
    data: ForumPostReactionCreateManyInput | ForumPostReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumPostReaction update
   */
  export type ForumPostReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumPostReaction.
     */
    data: XOR<ForumPostReactionUpdateInput, ForumPostReactionUncheckedUpdateInput>
    /**
     * Choose, which ForumPostReaction to update.
     */
    where: ForumPostReactionWhereUniqueInput
  }

  /**
   * ForumPostReaction updateMany
   */
  export type ForumPostReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumPostReactions.
     */
    data: XOR<ForumPostReactionUpdateManyMutationInput, ForumPostReactionUncheckedUpdateManyInput>
    /**
     * Filter which ForumPostReactions to update
     */
    where?: ForumPostReactionWhereInput
    /**
     * Limit how many ForumPostReactions to update.
     */
    limit?: number
  }

  /**
   * ForumPostReaction updateManyAndReturn
   */
  export type ForumPostReactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * The data used to update ForumPostReactions.
     */
    data: XOR<ForumPostReactionUpdateManyMutationInput, ForumPostReactionUncheckedUpdateManyInput>
    /**
     * Filter which ForumPostReactions to update
     */
    where?: ForumPostReactionWhereInput
    /**
     * Limit how many ForumPostReactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumPostReaction upsert
   */
  export type ForumPostReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumPostReaction to update in case it exists.
     */
    where: ForumPostReactionWhereUniqueInput
    /**
     * In case the ForumPostReaction found by the `where` argument doesn't exist, create a new ForumPostReaction with this data.
     */
    create: XOR<ForumPostReactionCreateInput, ForumPostReactionUncheckedCreateInput>
    /**
     * In case the ForumPostReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumPostReactionUpdateInput, ForumPostReactionUncheckedUpdateInput>
  }

  /**
   * ForumPostReaction delete
   */
  export type ForumPostReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionInclude<ExtArgs> | null
    /**
     * Filter which ForumPostReaction to delete.
     */
    where: ForumPostReactionWhereUniqueInput
  }

  /**
   * ForumPostReaction deleteMany
   */
  export type ForumPostReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPostReactions to delete
     */
    where?: ForumPostReactionWhereInput
    /**
     * Limit how many ForumPostReactions to delete.
     */
    limit?: number
  }

  /**
   * ForumPostReaction without action
   */
  export type ForumPostReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionInclude<ExtArgs> | null
  }


  /**
   * Model Article
   */

  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleAvgAggregateOutputType = {
    upVotes: number | null
    downVotes: number | null
    views: number | null
  }

  export type ArticleSumAggregateOutputType = {
    upVotes: number | null
    downVotes: number | null
    views: number | null
  }

  export type ArticleMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    bannerImg: string | null
    type: $Enums.ArticleType | null
    status: $Enums.ArticleStatus | null
    creatorId: string | null
    groupId: string | null
    upVotes: number | null
    downVotes: number | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    bannerImg: string | null
    type: $Enums.ArticleType | null
    status: $Enums.ArticleStatus | null
    creatorId: string | null
    groupId: string | null
    upVotes: number | null
    downVotes: number | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    bannerImg: number
    images: number
    tags: number
    type: number
    status: number
    creatorId: number
    groupId: number
    upVotes: number
    downVotes: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArticleAvgAggregateInputType = {
    upVotes?: true
    downVotes?: true
    views?: true
  }

  export type ArticleSumAggregateInputType = {
    upVotes?: true
    downVotes?: true
    views?: true
  }

  export type ArticleMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    bannerImg?: true
    type?: true
    status?: true
    creatorId?: true
    groupId?: true
    upVotes?: true
    downVotes?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    bannerImg?: true
    type?: true
    status?: true
    creatorId?: true
    groupId?: true
    upVotes?: true
    downVotes?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    bannerImg?: true
    images?: true
    tags?: true
    type?: true
    status?: true
    creatorId?: true
    groupId?: true
    upVotes?: true
    downVotes?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Article to aggregate.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Articles
    **/
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }




  export type ArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithAggregationInput | ArticleOrderByWithAggregationInput[]
    by: ArticleScalarFieldEnum[] | ArticleScalarFieldEnum
    having?: ArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _avg?: ArticleAvgAggregateInputType
    _sum?: ArticleSumAggregateInputType
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }

  export type ArticleGroupByOutputType = {
    id: string
    title: string
    description: string | null
    content: string
    bannerImg: string | null
    images: string[]
    tags: string[]
    type: $Enums.ArticleType
    status: $Enums.ArticleStatus
    creatorId: string
    groupId: string | null
    upVotes: number
    downVotes: number
    views: number
    createdAt: Date
    updatedAt: Date
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends ArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
        }
      >
    >


  export type ArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    bannerImg?: boolean
    images?: boolean
    tags?: boolean
    type?: boolean
    status?: boolean
    creatorId?: boolean
    groupId?: boolean
    upVotes?: boolean
    downVotes?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | Article$groupArgs<ExtArgs>
    votes?: boolean | Article$votesArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    bannerImg?: boolean
    images?: boolean
    tags?: boolean
    type?: boolean
    status?: boolean
    creatorId?: boolean
    groupId?: boolean
    upVotes?: boolean
    downVotes?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | Article$groupArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    bannerImg?: boolean
    images?: boolean
    tags?: boolean
    type?: boolean
    status?: boolean
    creatorId?: boolean
    groupId?: boolean
    upVotes?: boolean
    downVotes?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | Article$groupArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    bannerImg?: boolean
    images?: boolean
    tags?: boolean
    type?: boolean
    status?: boolean
    creatorId?: boolean
    groupId?: boolean
    upVotes?: boolean
    downVotes?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ArticleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "content" | "bannerImg" | "images" | "tags" | "type" | "status" | "creatorId" | "groupId" | "upVotes" | "downVotes" | "views" | "createdAt" | "updatedAt", ExtArgs["result"]["article"]>
  export type ArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | Article$groupArgs<ExtArgs>
    votes?: boolean | Article$votesArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | Article$groupArgs<ExtArgs>
  }
  export type ArticleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | Article$groupArgs<ExtArgs>
  }

  export type $ArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Article"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs> | null
      votes: Prisma.$VotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      content: string
      bannerImg: string | null
      images: string[]
      tags: string[]
      type: $Enums.ArticleType
      status: $Enums.ArticleStatus
      creatorId: string
      groupId: string | null
      upVotes: number
      downVotes: number
      views: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["article"]>
    composites: {}
  }

  type ArticleGetPayload<S extends boolean | null | undefined | ArticleDefaultArgs> = $Result.GetResult<Prisma.$ArticlePayload, S>

  type ArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArticleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArticleCountAggregateInputType | true
    }

  export interface ArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Article'], meta: { name: 'Article' } }
    /**
     * Find zero or one Article that matches the filter.
     * @param {ArticleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleFindUniqueArgs>(args: SelectSubset<T, ArticleFindUniqueArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Article that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArticleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, ArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleFindFirstArgs>(args?: SelectSubset<T, ArticleFindFirstArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Article that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, ArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleWithIdOnly = await prisma.article.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArticleFindManyArgs>(args?: SelectSubset<T, ArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Article.
     * @param {ArticleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     * 
     */
    create<T extends ArticleCreateArgs>(args: SelectSubset<T, ArticleCreateArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Articles.
     * @param {ArticleCreateManyArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArticleCreateManyArgs>(args?: SelectSubset<T, ArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Articles and returns the data saved in the database.
     * @param {ArticleCreateManyAndReturnArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Articles and only return the `id`
     * const articleWithIdOnly = await prisma.article.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, ArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Article.
     * @param {ArticleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     * 
     */
    delete<T extends ArticleDeleteArgs>(args: SelectSubset<T, ArticleDeleteArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Article.
     * @param {ArticleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArticleUpdateArgs>(args: SelectSubset<T, ArticleUpdateArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Articles.
     * @param {ArticleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArticleDeleteManyArgs>(args?: SelectSubset<T, ArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArticleUpdateManyArgs>(args: SelectSubset<T, ArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles and returns the data updated in the database.
     * @param {ArticleUpdateManyAndReturnArgs} args - Arguments to update many Articles.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Articles and only return the `id`
     * const articleWithIdOnly = await prisma.article.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArticleUpdateManyAndReturnArgs>(args: SelectSubset<T, ArticleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Article.
     * @param {ArticleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
     */
    upsert<T extends ArticleUpsertArgs>(args: SelectSubset<T, ArticleUpsertArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends ArticleCountArgs>(
      args?: Subset<T, ArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleAggregateArgs>(args: Subset<T, ArticleAggregateArgs>): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleGroupByArgs['orderBy'] }
        : { orderBy?: ArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Article model
   */
  readonly fields: ArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends Article$groupArgs<ExtArgs> = {}>(args?: Subset<T, Article$groupArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    votes<T extends Article$votesArgs<ExtArgs> = {}>(args?: Subset<T, Article$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Article model
   */
  interface ArticleFieldRefs {
    readonly id: FieldRef<"Article", 'String'>
    readonly title: FieldRef<"Article", 'String'>
    readonly description: FieldRef<"Article", 'String'>
    readonly content: FieldRef<"Article", 'String'>
    readonly bannerImg: FieldRef<"Article", 'String'>
    readonly images: FieldRef<"Article", 'String[]'>
    readonly tags: FieldRef<"Article", 'String[]'>
    readonly type: FieldRef<"Article", 'ArticleType'>
    readonly status: FieldRef<"Article", 'ArticleStatus'>
    readonly creatorId: FieldRef<"Article", 'String'>
    readonly groupId: FieldRef<"Article", 'String'>
    readonly upVotes: FieldRef<"Article", 'Int'>
    readonly downVotes: FieldRef<"Article", 'Int'>
    readonly views: FieldRef<"Article", 'Int'>
    readonly createdAt: FieldRef<"Article", 'DateTime'>
    readonly updatedAt: FieldRef<"Article", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Article findUnique
   */
  export type ArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findUniqueOrThrow
   */
  export type ArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findFirst
   */
  export type ArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article findFirstOrThrow
   */
  export type ArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article findMany
   */
  export type ArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Articles to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article create
   */
  export type ArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a Article.
     */
    data: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
  }

  /**
   * Article createMany
   */
  export type ArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Article createManyAndReturn
   */
  export type ArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Article update
   */
  export type ArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a Article.
     */
    data: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
    /**
     * Choose, which Article to update.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article updateMany
   */
  export type ArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
    /**
     * Limit how many Articles to update.
     */
    limit?: number
  }

  /**
   * Article updateManyAndReturn
   */
  export type ArticleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
    /**
     * Limit how many Articles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Article upsert
   */
  export type ArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the Article to update in case it exists.
     */
    where: ArticleWhereUniqueInput
    /**
     * In case the Article found by the `where` argument doesn't exist, create a new Article with this data.
     */
    create: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
    /**
     * In case the Article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
  }

  /**
   * Article delete
   */
  export type ArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter which Article to delete.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article deleteMany
   */
  export type ArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Articles to delete
     */
    where?: ArticleWhereInput
    /**
     * Limit how many Articles to delete.
     */
    limit?: number
  }

  /**
   * Article.group
   */
  export type Article$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
  }

  /**
   * Article.votes
   */
  export type Article$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Article without action
   */
  export type ArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionToken: string | null
    refreshToken: string | null
    expires: Date | null
    lastActivity: Date | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionToken: string | null
    refreshToken: string | null
    expires: Date | null
    lastActivity: Date | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    sessionToken: number
    refreshToken: number
    expires: number
    lastActivity: number
    userAgent: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    sessionToken?: true
    refreshToken?: true
    expires?: true
    lastActivity?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionToken?: true
    refreshToken?: true
    expires?: true
    lastActivity?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    sessionToken?: true
    refreshToken?: true
    expires?: true
    lastActivity?: true
    userAgent?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    sessionToken: string
    refreshToken: string | null
    expires: Date
    lastActivity: Date | null
    userAgent: string | null
    ipAddress: string | null
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionToken?: boolean
    refreshToken?: boolean
    expires?: boolean
    lastActivity?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionToken?: boolean
    refreshToken?: boolean
    expires?: boolean
    lastActivity?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionToken?: boolean
    refreshToken?: boolean
    expires?: boolean
    lastActivity?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionToken?: boolean
    refreshToken?: boolean
    expires?: boolean
    lastActivity?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sessionToken" | "refreshToken" | "expires" | "lastActivity" | "userAgent" | "ipAddress" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sessionToken: string
      refreshToken: string | null
      expires: Date
      lastActivity: Date | null
      userAgent: string | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly refreshToken: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly lastActivity: FieldRef<"Session", 'DateTime'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    isRead: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead: boolean
    data: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "type" | "isRead" | "data" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: $Enums.NotificationType
      isRead: boolean
      data: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model FavCourse
   */

  export type AggregateFavCourse = {
    _count: FavCourseCountAggregateOutputType | null
    _min: FavCourseMinAggregateOutputType | null
    _max: FavCourseMaxAggregateOutputType | null
  }

  export type FavCourseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    universityId: string | null
    universityName: string | null
    courseName: string | null
    courseId: string | null
    createdAt: Date | null
  }

  export type FavCourseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    universityId: string | null
    universityName: string | null
    courseName: string | null
    courseId: string | null
    createdAt: Date | null
  }

  export type FavCourseCountAggregateOutputType = {
    id: number
    userId: number
    universityId: number
    universityName: number
    courseName: number
    courseId: number
    createdAt: number
    _all: number
  }


  export type FavCourseMinAggregateInputType = {
    id?: true
    userId?: true
    universityId?: true
    universityName?: true
    courseName?: true
    courseId?: true
    createdAt?: true
  }

  export type FavCourseMaxAggregateInputType = {
    id?: true
    userId?: true
    universityId?: true
    universityName?: true
    courseName?: true
    courseId?: true
    createdAt?: true
  }

  export type FavCourseCountAggregateInputType = {
    id?: true
    userId?: true
    universityId?: true
    universityName?: true
    courseName?: true
    courseId?: true
    createdAt?: true
    _all?: true
  }

  export type FavCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavCourse to aggregate.
     */
    where?: FavCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavCourses to fetch.
     */
    orderBy?: FavCourseOrderByWithRelationInput | FavCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FavCourses
    **/
    _count?: true | FavCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavCourseMaxAggregateInputType
  }

  export type GetFavCourseAggregateType<T extends FavCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateFavCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavCourse[P]>
      : GetScalarType<T[P], AggregateFavCourse[P]>
  }




  export type FavCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavCourseWhereInput
    orderBy?: FavCourseOrderByWithAggregationInput | FavCourseOrderByWithAggregationInput[]
    by: FavCourseScalarFieldEnum[] | FavCourseScalarFieldEnum
    having?: FavCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavCourseCountAggregateInputType | true
    _min?: FavCourseMinAggregateInputType
    _max?: FavCourseMaxAggregateInputType
  }

  export type FavCourseGroupByOutputType = {
    id: string
    userId: string
    universityId: string | null
    universityName: string | null
    courseName: string | null
    courseId: string
    createdAt: Date
    _count: FavCourseCountAggregateOutputType | null
    _min: FavCourseMinAggregateOutputType | null
    _max: FavCourseMaxAggregateOutputType | null
  }

  type GetFavCourseGroupByPayload<T extends FavCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavCourseGroupByOutputType[P]>
            : GetScalarType<T[P], FavCourseGroupByOutputType[P]>
        }
      >
    >


  export type FavCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    universityId?: boolean
    universityName?: boolean
    courseName?: boolean
    courseId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favCourse"]>

  export type FavCourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    universityId?: boolean
    universityName?: boolean
    courseName?: boolean
    courseId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favCourse"]>

  export type FavCourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    universityId?: boolean
    universityName?: boolean
    courseName?: boolean
    courseId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favCourse"]>

  export type FavCourseSelectScalar = {
    id?: boolean
    userId?: boolean
    universityId?: boolean
    universityName?: boolean
    courseName?: boolean
    courseId?: boolean
    createdAt?: boolean
  }

  export type FavCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "universityId" | "universityName" | "courseName" | "courseId" | "createdAt", ExtArgs["result"]["favCourse"]>
  export type FavCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type FavCourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type FavCourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $FavCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FavCourse"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      universityId: string | null
      universityName: string | null
      courseName: string | null
      courseId: string
      createdAt: Date
    }, ExtArgs["result"]["favCourse"]>
    composites: {}
  }

  type FavCourseGetPayload<S extends boolean | null | undefined | FavCourseDefaultArgs> = $Result.GetResult<Prisma.$FavCoursePayload, S>

  type FavCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavCourseCountAggregateInputType | true
    }

  export interface FavCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FavCourse'], meta: { name: 'FavCourse' } }
    /**
     * Find zero or one FavCourse that matches the filter.
     * @param {FavCourseFindUniqueArgs} args - Arguments to find a FavCourse
     * @example
     * // Get one FavCourse
     * const favCourse = await prisma.favCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavCourseFindUniqueArgs>(args: SelectSubset<T, FavCourseFindUniqueArgs<ExtArgs>>): Prisma__FavCourseClient<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FavCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavCourseFindUniqueOrThrowArgs} args - Arguments to find a FavCourse
     * @example
     * // Get one FavCourse
     * const favCourse = await prisma.favCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, FavCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavCourseClient<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FavCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavCourseFindFirstArgs} args - Arguments to find a FavCourse
     * @example
     * // Get one FavCourse
     * const favCourse = await prisma.favCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavCourseFindFirstArgs>(args?: SelectSubset<T, FavCourseFindFirstArgs<ExtArgs>>): Prisma__FavCourseClient<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FavCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavCourseFindFirstOrThrowArgs} args - Arguments to find a FavCourse
     * @example
     * // Get one FavCourse
     * const favCourse = await prisma.favCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, FavCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavCourseClient<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FavCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FavCourses
     * const favCourses = await prisma.favCourse.findMany()
     * 
     * // Get first 10 FavCourses
     * const favCourses = await prisma.favCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favCourseWithIdOnly = await prisma.favCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavCourseFindManyArgs>(args?: SelectSubset<T, FavCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FavCourse.
     * @param {FavCourseCreateArgs} args - Arguments to create a FavCourse.
     * @example
     * // Create one FavCourse
     * const FavCourse = await prisma.favCourse.create({
     *   data: {
     *     // ... data to create a FavCourse
     *   }
     * })
     * 
     */
    create<T extends FavCourseCreateArgs>(args: SelectSubset<T, FavCourseCreateArgs<ExtArgs>>): Prisma__FavCourseClient<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FavCourses.
     * @param {FavCourseCreateManyArgs} args - Arguments to create many FavCourses.
     * @example
     * // Create many FavCourses
     * const favCourse = await prisma.favCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavCourseCreateManyArgs>(args?: SelectSubset<T, FavCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FavCourses and returns the data saved in the database.
     * @param {FavCourseCreateManyAndReturnArgs} args - Arguments to create many FavCourses.
     * @example
     * // Create many FavCourses
     * const favCourse = await prisma.favCourse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FavCourses and only return the `id`
     * const favCourseWithIdOnly = await prisma.favCourse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavCourseCreateManyAndReturnArgs>(args?: SelectSubset<T, FavCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FavCourse.
     * @param {FavCourseDeleteArgs} args - Arguments to delete one FavCourse.
     * @example
     * // Delete one FavCourse
     * const FavCourse = await prisma.favCourse.delete({
     *   where: {
     *     // ... filter to delete one FavCourse
     *   }
     * })
     * 
     */
    delete<T extends FavCourseDeleteArgs>(args: SelectSubset<T, FavCourseDeleteArgs<ExtArgs>>): Prisma__FavCourseClient<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FavCourse.
     * @param {FavCourseUpdateArgs} args - Arguments to update one FavCourse.
     * @example
     * // Update one FavCourse
     * const favCourse = await prisma.favCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavCourseUpdateArgs>(args: SelectSubset<T, FavCourseUpdateArgs<ExtArgs>>): Prisma__FavCourseClient<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FavCourses.
     * @param {FavCourseDeleteManyArgs} args - Arguments to filter FavCourses to delete.
     * @example
     * // Delete a few FavCourses
     * const { count } = await prisma.favCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavCourseDeleteManyArgs>(args?: SelectSubset<T, FavCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FavCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FavCourses
     * const favCourse = await prisma.favCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavCourseUpdateManyArgs>(args: SelectSubset<T, FavCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FavCourses and returns the data updated in the database.
     * @param {FavCourseUpdateManyAndReturnArgs} args - Arguments to update many FavCourses.
     * @example
     * // Update many FavCourses
     * const favCourse = await prisma.favCourse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FavCourses and only return the `id`
     * const favCourseWithIdOnly = await prisma.favCourse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavCourseUpdateManyAndReturnArgs>(args: SelectSubset<T, FavCourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FavCourse.
     * @param {FavCourseUpsertArgs} args - Arguments to update or create a FavCourse.
     * @example
     * // Update or create a FavCourse
     * const favCourse = await prisma.favCourse.upsert({
     *   create: {
     *     // ... data to create a FavCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FavCourse we want to update
     *   }
     * })
     */
    upsert<T extends FavCourseUpsertArgs>(args: SelectSubset<T, FavCourseUpsertArgs<ExtArgs>>): Prisma__FavCourseClient<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FavCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavCourseCountArgs} args - Arguments to filter FavCourses to count.
     * @example
     * // Count the number of FavCourses
     * const count = await prisma.favCourse.count({
     *   where: {
     *     // ... the filter for the FavCourses we want to count
     *   }
     * })
    **/
    count<T extends FavCourseCountArgs>(
      args?: Subset<T, FavCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FavCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavCourseAggregateArgs>(args: Subset<T, FavCourseAggregateArgs>): Prisma.PrismaPromise<GetFavCourseAggregateType<T>>

    /**
     * Group by FavCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavCourseGroupByArgs['orderBy'] }
        : { orderBy?: FavCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FavCourse model
   */
  readonly fields: FavCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FavCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FavCourse model
   */
  interface FavCourseFieldRefs {
    readonly id: FieldRef<"FavCourse", 'String'>
    readonly userId: FieldRef<"FavCourse", 'String'>
    readonly universityId: FieldRef<"FavCourse", 'String'>
    readonly universityName: FieldRef<"FavCourse", 'String'>
    readonly courseName: FieldRef<"FavCourse", 'String'>
    readonly courseId: FieldRef<"FavCourse", 'String'>
    readonly createdAt: FieldRef<"FavCourse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FavCourse findUnique
   */
  export type FavCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseInclude<ExtArgs> | null
    /**
     * Filter, which FavCourse to fetch.
     */
    where: FavCourseWhereUniqueInput
  }

  /**
   * FavCourse findUniqueOrThrow
   */
  export type FavCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseInclude<ExtArgs> | null
    /**
     * Filter, which FavCourse to fetch.
     */
    where: FavCourseWhereUniqueInput
  }

  /**
   * FavCourse findFirst
   */
  export type FavCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseInclude<ExtArgs> | null
    /**
     * Filter, which FavCourse to fetch.
     */
    where?: FavCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavCourses to fetch.
     */
    orderBy?: FavCourseOrderByWithRelationInput | FavCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavCourses.
     */
    cursor?: FavCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavCourses.
     */
    distinct?: FavCourseScalarFieldEnum | FavCourseScalarFieldEnum[]
  }

  /**
   * FavCourse findFirstOrThrow
   */
  export type FavCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseInclude<ExtArgs> | null
    /**
     * Filter, which FavCourse to fetch.
     */
    where?: FavCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavCourses to fetch.
     */
    orderBy?: FavCourseOrderByWithRelationInput | FavCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavCourses.
     */
    cursor?: FavCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavCourses.
     */
    distinct?: FavCourseScalarFieldEnum | FavCourseScalarFieldEnum[]
  }

  /**
   * FavCourse findMany
   */
  export type FavCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseInclude<ExtArgs> | null
    /**
     * Filter, which FavCourses to fetch.
     */
    where?: FavCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavCourses to fetch.
     */
    orderBy?: FavCourseOrderByWithRelationInput | FavCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FavCourses.
     */
    cursor?: FavCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavCourses.
     */
    skip?: number
    distinct?: FavCourseScalarFieldEnum | FavCourseScalarFieldEnum[]
  }

  /**
   * FavCourse create
   */
  export type FavCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a FavCourse.
     */
    data: XOR<FavCourseCreateInput, FavCourseUncheckedCreateInput>
  }

  /**
   * FavCourse createMany
   */
  export type FavCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FavCourses.
     */
    data: FavCourseCreateManyInput | FavCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FavCourse createManyAndReturn
   */
  export type FavCourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * The data used to create many FavCourses.
     */
    data: FavCourseCreateManyInput | FavCourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FavCourse update
   */
  export type FavCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a FavCourse.
     */
    data: XOR<FavCourseUpdateInput, FavCourseUncheckedUpdateInput>
    /**
     * Choose, which FavCourse to update.
     */
    where: FavCourseWhereUniqueInput
  }

  /**
   * FavCourse updateMany
   */
  export type FavCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FavCourses.
     */
    data: XOR<FavCourseUpdateManyMutationInput, FavCourseUncheckedUpdateManyInput>
    /**
     * Filter which FavCourses to update
     */
    where?: FavCourseWhereInput
    /**
     * Limit how many FavCourses to update.
     */
    limit?: number
  }

  /**
   * FavCourse updateManyAndReturn
   */
  export type FavCourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * The data used to update FavCourses.
     */
    data: XOR<FavCourseUpdateManyMutationInput, FavCourseUncheckedUpdateManyInput>
    /**
     * Filter which FavCourses to update
     */
    where?: FavCourseWhereInput
    /**
     * Limit how many FavCourses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FavCourse upsert
   */
  export type FavCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the FavCourse to update in case it exists.
     */
    where: FavCourseWhereUniqueInput
    /**
     * In case the FavCourse found by the `where` argument doesn't exist, create a new FavCourse with this data.
     */
    create: XOR<FavCourseCreateInput, FavCourseUncheckedCreateInput>
    /**
     * In case the FavCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavCourseUpdateInput, FavCourseUncheckedUpdateInput>
  }

  /**
   * FavCourse delete
   */
  export type FavCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseInclude<ExtArgs> | null
    /**
     * Filter which FavCourse to delete.
     */
    where: FavCourseWhereUniqueInput
  }

  /**
   * FavCourse deleteMany
   */
  export type FavCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavCourses to delete
     */
    where?: FavCourseWhereInput
    /**
     * Limit how many FavCourses to delete.
     */
    limit?: number
  }

  /**
   * FavCourse without action
   */
  export type FavCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    otpRetryCount: number | null
    followersCount: number | null
    followingCount: number | null
    graduationYear: number | null
    loginAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    otpRetryCount: number | null
    followersCount: number | null
    followingCount: number | null
    graduationYear: number | null
    loginAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    countryCode: string | null
    phoneNumber: string | null
    name: string | null
    header: string | null
    bio: string | null
    avatarUrl: string | null
    banner: string | null
    role: $Enums.UserRole | null
    emailVerified: Date | null
    image: string | null
    googleId: string | null
    googleAccessToken: string | null
    googleRefreshToken: string | null
    googleTokenExpiry: Date | null
    resetPasswordToken: string | null
    resetPasswordExpiry: Date | null
    lastPasswordChangeAt: Date | null
    isVerified: boolean | null
    isPhoneVerified: boolean | null
    isEmailVerified: boolean | null
    otpRetryCount: number | null
    otpLastSentAt: Date | null
    otpBlockedUntil: Date | null
    followersCount: number | null
    followingCount: number | null
    universityId: string | null
    department: string | null
    program: string | null
    graduationYear: number | null
    lastLoginAt: Date | null
    loginAttempts: number | null
    isLocked: boolean | null
    lockUntil: Date | null
    isLandlordVerified: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    countryCode: string | null
    phoneNumber: string | null
    name: string | null
    header: string | null
    bio: string | null
    avatarUrl: string | null
    banner: string | null
    role: $Enums.UserRole | null
    emailVerified: Date | null
    image: string | null
    googleId: string | null
    googleAccessToken: string | null
    googleRefreshToken: string | null
    googleTokenExpiry: Date | null
    resetPasswordToken: string | null
    resetPasswordExpiry: Date | null
    lastPasswordChangeAt: Date | null
    isVerified: boolean | null
    isPhoneVerified: boolean | null
    isEmailVerified: boolean | null
    otpRetryCount: number | null
    otpLastSentAt: Date | null
    otpBlockedUntil: Date | null
    followersCount: number | null
    followingCount: number | null
    universityId: string | null
    department: string | null
    program: string | null
    graduationYear: number | null
    lastLoginAt: Date | null
    loginAttempts: number | null
    isLocked: boolean | null
    lockUntil: Date | null
    isLandlordVerified: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    countryCode: number
    phoneNumber: number
    name: number
    header: number
    bio: number
    avatarUrl: number
    banner: number
    role: number
    emailVerified: number
    image: number
    googleId: number
    googleAccessToken: number
    googleRefreshToken: number
    googleTokenExpiry: number
    resetPasswordToken: number
    resetPasswordExpiry: number
    lastPasswordChangeAt: number
    isVerified: number
    isPhoneVerified: number
    isEmailVerified: number
    otpRetryCount: number
    otpLastSentAt: number
    otpBlockedUntil: number
    followersCount: number
    followingCount: number
    universityId: number
    department: number
    program: number
    graduationYear: number
    lastLoginAt: number
    loginAttempts: number
    isLocked: number
    lockUntil: number
    isLandlordVerified: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    otpRetryCount?: true
    followersCount?: true
    followingCount?: true
    graduationYear?: true
    loginAttempts?: true
  }

  export type UserSumAggregateInputType = {
    otpRetryCount?: true
    followersCount?: true
    followingCount?: true
    graduationYear?: true
    loginAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    countryCode?: true
    phoneNumber?: true
    name?: true
    header?: true
    bio?: true
    avatarUrl?: true
    banner?: true
    role?: true
    emailVerified?: true
    image?: true
    googleId?: true
    googleAccessToken?: true
    googleRefreshToken?: true
    googleTokenExpiry?: true
    resetPasswordToken?: true
    resetPasswordExpiry?: true
    lastPasswordChangeAt?: true
    isVerified?: true
    isPhoneVerified?: true
    isEmailVerified?: true
    otpRetryCount?: true
    otpLastSentAt?: true
    otpBlockedUntil?: true
    followersCount?: true
    followingCount?: true
    universityId?: true
    department?: true
    program?: true
    graduationYear?: true
    lastLoginAt?: true
    loginAttempts?: true
    isLocked?: true
    lockUntil?: true
    isLandlordVerified?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    countryCode?: true
    phoneNumber?: true
    name?: true
    header?: true
    bio?: true
    avatarUrl?: true
    banner?: true
    role?: true
    emailVerified?: true
    image?: true
    googleId?: true
    googleAccessToken?: true
    googleRefreshToken?: true
    googleTokenExpiry?: true
    resetPasswordToken?: true
    resetPasswordExpiry?: true
    lastPasswordChangeAt?: true
    isVerified?: true
    isPhoneVerified?: true
    isEmailVerified?: true
    otpRetryCount?: true
    otpLastSentAt?: true
    otpBlockedUntil?: true
    followersCount?: true
    followingCount?: true
    universityId?: true
    department?: true
    program?: true
    graduationYear?: true
    lastLoginAt?: true
    loginAttempts?: true
    isLocked?: true
    lockUntil?: true
    isLandlordVerified?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    countryCode?: true
    phoneNumber?: true
    name?: true
    header?: true
    bio?: true
    avatarUrl?: true
    banner?: true
    role?: true
    emailVerified?: true
    image?: true
    googleId?: true
    googleAccessToken?: true
    googleRefreshToken?: true
    googleTokenExpiry?: true
    resetPasswordToken?: true
    resetPasswordExpiry?: true
    lastPasswordChangeAt?: true
    isVerified?: true
    isPhoneVerified?: true
    isEmailVerified?: true
    otpRetryCount?: true
    otpLastSentAt?: true
    otpBlockedUntil?: true
    followersCount?: true
    followingCount?: true
    universityId?: true
    department?: true
    program?: true
    graduationYear?: true
    lastLoginAt?: true
    loginAttempts?: true
    isLocked?: true
    lockUntil?: true
    isLandlordVerified?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    password: string | null
    countryCode: string | null
    phoneNumber: string | null
    name: string
    header: string | null
    bio: string | null
    avatarUrl: string | null
    banner: string | null
    role: $Enums.UserRole
    emailVerified: Date | null
    image: string | null
    googleId: string | null
    googleAccessToken: string | null
    googleRefreshToken: string | null
    googleTokenExpiry: Date | null
    resetPasswordToken: string | null
    resetPasswordExpiry: Date | null
    lastPasswordChangeAt: Date | null
    isVerified: boolean
    isPhoneVerified: boolean
    isEmailVerified: boolean
    otpRetryCount: number
    otpLastSentAt: Date | null
    otpBlockedUntil: Date | null
    followersCount: number
    followingCount: number
    universityId: string | null
    department: string | null
    program: string | null
    graduationYear: number | null
    lastLoginAt: Date | null
    loginAttempts: number
    isLocked: boolean
    lockUntil: Date | null
    isLandlordVerified: boolean
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    countryCode?: boolean
    phoneNumber?: boolean
    name?: boolean
    header?: boolean
    bio?: boolean
    avatarUrl?: boolean
    banner?: boolean
    role?: boolean
    emailVerified?: boolean
    image?: boolean
    googleId?: boolean
    googleAccessToken?: boolean
    googleRefreshToken?: boolean
    googleTokenExpiry?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpiry?: boolean
    lastPasswordChangeAt?: boolean
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: boolean
    otpLastSentAt?: boolean
    otpBlockedUntil?: boolean
    followersCount?: boolean
    followingCount?: boolean
    universityId?: boolean
    department?: boolean
    program?: boolean
    graduationYear?: boolean
    lastLoginAt?: boolean
    loginAttempts?: boolean
    isLocked?: boolean
    lockUntil?: boolean
    isLandlordVerified?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    favCourses?: boolean | User$favCoursesArgs<ExtArgs>
    quizAnswers?: boolean | User$quizAnswersArgs<ExtArgs>
    createdForums?: boolean | User$createdForumsArgs<ExtArgs>
    createdForumTopics?: boolean | User$createdForumTopicsArgs<ExtArgs>
    forumReplies?: boolean | User$forumRepliesArgs<ExtArgs>
    forumPosts?: boolean | User$forumPostsArgs<ExtArgs>
    forumReplyReactions?: boolean | User$forumReplyReactionsArgs<ExtArgs>
    forumPostReactions?: boolean | User$forumPostReactionsArgs<ExtArgs>
    university?: boolean | User$universityArgs<ExtArgs>
    loanApplications?: boolean | User$loanApplicationsArgs<ExtArgs>
    accommodationRatings?: boolean | User$accommodationRatingsArgs<ExtArgs>
    applications?: boolean | User$applicationsArgs<ExtArgs>
    tokens?: boolean | User$tokensArgs<ExtArgs>
    accommodations?: boolean | User$accommodationsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    otps?: boolean | User$otpsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    createdGroups?: boolean | User$createdGroupsArgs<ExtArgs>
    adminOf?: boolean | User$adminOfArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    hostedEvents?: boolean | User$hostedEventsArgs<ExtArgs>
    articles?: boolean | User$articlesArgs<ExtArgs>
    accommodationReviews?: boolean | User$accommodationReviewsArgs<ExtArgs>
    likedAccommodations?: boolean | User$likedAccommodationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    countryCode?: boolean
    phoneNumber?: boolean
    name?: boolean
    header?: boolean
    bio?: boolean
    avatarUrl?: boolean
    banner?: boolean
    role?: boolean
    emailVerified?: boolean
    image?: boolean
    googleId?: boolean
    googleAccessToken?: boolean
    googleRefreshToken?: boolean
    googleTokenExpiry?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpiry?: boolean
    lastPasswordChangeAt?: boolean
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: boolean
    otpLastSentAt?: boolean
    otpBlockedUntil?: boolean
    followersCount?: boolean
    followingCount?: boolean
    universityId?: boolean
    department?: boolean
    program?: boolean
    graduationYear?: boolean
    lastLoginAt?: boolean
    loginAttempts?: boolean
    isLocked?: boolean
    lockUntil?: boolean
    isLandlordVerified?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    university?: boolean | User$universityArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    countryCode?: boolean
    phoneNumber?: boolean
    name?: boolean
    header?: boolean
    bio?: boolean
    avatarUrl?: boolean
    banner?: boolean
    role?: boolean
    emailVerified?: boolean
    image?: boolean
    googleId?: boolean
    googleAccessToken?: boolean
    googleRefreshToken?: boolean
    googleTokenExpiry?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpiry?: boolean
    lastPasswordChangeAt?: boolean
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: boolean
    otpLastSentAt?: boolean
    otpBlockedUntil?: boolean
    followersCount?: boolean
    followingCount?: boolean
    universityId?: boolean
    department?: boolean
    program?: boolean
    graduationYear?: boolean
    lastLoginAt?: boolean
    loginAttempts?: boolean
    isLocked?: boolean
    lockUntil?: boolean
    isLandlordVerified?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    university?: boolean | User$universityArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    countryCode?: boolean
    phoneNumber?: boolean
    name?: boolean
    header?: boolean
    bio?: boolean
    avatarUrl?: boolean
    banner?: boolean
    role?: boolean
    emailVerified?: boolean
    image?: boolean
    googleId?: boolean
    googleAccessToken?: boolean
    googleRefreshToken?: boolean
    googleTokenExpiry?: boolean
    resetPasswordToken?: boolean
    resetPasswordExpiry?: boolean
    lastPasswordChangeAt?: boolean
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: boolean
    otpLastSentAt?: boolean
    otpBlockedUntil?: boolean
    followersCount?: boolean
    followingCount?: boolean
    universityId?: boolean
    department?: boolean
    program?: boolean
    graduationYear?: boolean
    lastLoginAt?: boolean
    loginAttempts?: boolean
    isLocked?: boolean
    lockUntil?: boolean
    isLandlordVerified?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "countryCode" | "phoneNumber" | "name" | "header" | "bio" | "avatarUrl" | "banner" | "role" | "emailVerified" | "image" | "googleId" | "googleAccessToken" | "googleRefreshToken" | "googleTokenExpiry" | "resetPasswordToken" | "resetPasswordExpiry" | "lastPasswordChangeAt" | "isVerified" | "isPhoneVerified" | "isEmailVerified" | "otpRetryCount" | "otpLastSentAt" | "otpBlockedUntil" | "followersCount" | "followingCount" | "universityId" | "department" | "program" | "graduationYear" | "lastLoginAt" | "loginAttempts" | "isLocked" | "lockUntil" | "isLandlordVerified" | "lastLogin" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    favCourses?: boolean | User$favCoursesArgs<ExtArgs>
    quizAnswers?: boolean | User$quizAnswersArgs<ExtArgs>
    createdForums?: boolean | User$createdForumsArgs<ExtArgs>
    createdForumTopics?: boolean | User$createdForumTopicsArgs<ExtArgs>
    forumReplies?: boolean | User$forumRepliesArgs<ExtArgs>
    forumPosts?: boolean | User$forumPostsArgs<ExtArgs>
    forumReplyReactions?: boolean | User$forumReplyReactionsArgs<ExtArgs>
    forumPostReactions?: boolean | User$forumPostReactionsArgs<ExtArgs>
    university?: boolean | User$universityArgs<ExtArgs>
    loanApplications?: boolean | User$loanApplicationsArgs<ExtArgs>
    accommodationRatings?: boolean | User$accommodationRatingsArgs<ExtArgs>
    applications?: boolean | User$applicationsArgs<ExtArgs>
    tokens?: boolean | User$tokensArgs<ExtArgs>
    accommodations?: boolean | User$accommodationsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    otps?: boolean | User$otpsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    createdGroups?: boolean | User$createdGroupsArgs<ExtArgs>
    adminOf?: boolean | User$adminOfArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    hostedEvents?: boolean | User$hostedEventsArgs<ExtArgs>
    articles?: boolean | User$articlesArgs<ExtArgs>
    accommodationReviews?: boolean | User$accommodationReviewsArgs<ExtArgs>
    likedAccommodations?: boolean | User$likedAccommodationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | User$universityArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    university?: boolean | User$universityArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      favCourses: Prisma.$FavCoursePayload<ExtArgs>[]
      quizAnswers: Prisma.$QuizAnswerPayload<ExtArgs>[]
      createdForums: Prisma.$ForumPayload<ExtArgs>[]
      createdForumTopics: Prisma.$ForumTopicPayload<ExtArgs>[]
      forumReplies: Prisma.$ForumReplyPayload<ExtArgs>[]
      forumPosts: Prisma.$ForumPostPayload<ExtArgs>[]
      forumReplyReactions: Prisma.$ForumReplyReactionPayload<ExtArgs>[]
      forumPostReactions: Prisma.$ForumPostReactionPayload<ExtArgs>[]
      university: Prisma.$UniversityPayload<ExtArgs> | null
      loanApplications: Prisma.$LoanApplicationPayload<ExtArgs>[]
      accommodationRatings: Prisma.$AccommodationRatingPayload<ExtArgs>[]
      applications: Prisma.$UniversityApplicationsPayload<ExtArgs>[]
      tokens: Prisma.$TokenPayload<ExtArgs>[]
      accommodations: Prisma.$AccommodationPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      otps: Prisma.$OTPPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      followers: Prisma.$FollowPayload<ExtArgs>[]
      following: Prisma.$FollowPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      createdGroups: Prisma.$GroupPayload<ExtArgs>[]
      adminOf: Prisma.$GroupPayload<ExtArgs>[]
      groupMemberships: Prisma.$GroupMemberPayload<ExtArgs>[]
      hostedEvents: Prisma.$EventPayload<ExtArgs>[]
      articles: Prisma.$ArticlePayload<ExtArgs>[]
      accommodationReviews: Prisma.$AccommodationReviewPayload<ExtArgs>[]
      likedAccommodations: Prisma.$LikedAccommodationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      password: string | null
      countryCode: string | null
      phoneNumber: string | null
      name: string
      header: string | null
      bio: string | null
      avatarUrl: string | null
      banner: string | null
      role: $Enums.UserRole
      emailVerified: Date | null
      image: string | null
      googleId: string | null
      googleAccessToken: string | null
      googleRefreshToken: string | null
      googleTokenExpiry: Date | null
      resetPasswordToken: string | null
      resetPasswordExpiry: Date | null
      lastPasswordChangeAt: Date | null
      isVerified: boolean
      isPhoneVerified: boolean
      isEmailVerified: boolean
      otpRetryCount: number
      otpLastSentAt: Date | null
      otpBlockedUntil: Date | null
      followersCount: number
      followingCount: number
      universityId: string | null
      department: string | null
      program: string | null
      graduationYear: number | null
      lastLoginAt: Date | null
      loginAttempts: number
      isLocked: boolean
      lockUntil: Date | null
      isLandlordVerified: boolean
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    favCourses<T extends User$favCoursesArgs<ExtArgs> = {}>(args?: Subset<T, User$favCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizAnswers<T extends User$quizAnswersArgs<ExtArgs> = {}>(args?: Subset<T, User$quizAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdForums<T extends User$createdForumsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdForumsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdForumTopics<T extends User$createdForumTopicsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdForumTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    forumReplies<T extends User$forumRepliesArgs<ExtArgs> = {}>(args?: Subset<T, User$forumRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    forumPosts<T extends User$forumPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$forumPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    forumReplyReactions<T extends User$forumReplyReactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$forumReplyReactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumReplyReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    forumPostReactions<T extends User$forumPostReactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$forumPostReactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    university<T extends User$universityArgs<ExtArgs> = {}>(args?: Subset<T, User$universityArgs<ExtArgs>>): Prisma__UniversityClient<$Result.GetResult<Prisma.$UniversityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    loanApplications<T extends User$loanApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$loanApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoanApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accommodationRatings<T extends User$accommodationRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$accommodationRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applications<T extends User$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UniversityApplicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tokens<T extends User$tokensArgs<ExtArgs> = {}>(args?: Subset<T, User$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accommodations<T extends User$accommodationsArgs<ExtArgs> = {}>(args?: Subset<T, User$accommodationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    otps<T extends User$otpsArgs<ExtArgs> = {}>(args?: Subset<T, User$otpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdGroups<T extends User$createdGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminOf<T extends User$adminOfArgs<ExtArgs> = {}>(args?: Subset<T, User$adminOfArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupMemberships<T extends User$groupMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hostedEvents<T extends User$hostedEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$hostedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    articles<T extends User$articlesArgs<ExtArgs> = {}>(args?: Subset<T, User$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accommodationReviews<T extends User$accommodationReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$accommodationReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccommodationReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedAccommodations<T extends User$likedAccommodationsArgs<ExtArgs> = {}>(args?: Subset<T, User$likedAccommodationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly countryCode: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly header: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly banner: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly googleAccessToken: FieldRef<"User", 'String'>
    readonly googleRefreshToken: FieldRef<"User", 'String'>
    readonly googleTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly resetPasswordToken: FieldRef<"User", 'String'>
    readonly resetPasswordExpiry: FieldRef<"User", 'DateTime'>
    readonly lastPasswordChangeAt: FieldRef<"User", 'DateTime'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly isPhoneVerified: FieldRef<"User", 'Boolean'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly otpRetryCount: FieldRef<"User", 'Int'>
    readonly otpLastSentAt: FieldRef<"User", 'DateTime'>
    readonly otpBlockedUntil: FieldRef<"User", 'DateTime'>
    readonly followersCount: FieldRef<"User", 'Int'>
    readonly followingCount: FieldRef<"User", 'Int'>
    readonly universityId: FieldRef<"User", 'String'>
    readonly department: FieldRef<"User", 'String'>
    readonly program: FieldRef<"User", 'String'>
    readonly graduationYear: FieldRef<"User", 'Int'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly loginAttempts: FieldRef<"User", 'Int'>
    readonly isLocked: FieldRef<"User", 'Boolean'>
    readonly lockUntil: FieldRef<"User", 'DateTime'>
    readonly isLandlordVerified: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.favCourses
   */
  export type User$favCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavCourse
     */
    select?: FavCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavCourse
     */
    omit?: FavCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavCourseInclude<ExtArgs> | null
    where?: FavCourseWhereInput
    orderBy?: FavCourseOrderByWithRelationInput | FavCourseOrderByWithRelationInput[]
    cursor?: FavCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavCourseScalarFieldEnum | FavCourseScalarFieldEnum[]
  }

  /**
   * User.quizAnswers
   */
  export type User$quizAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    where?: QuizAnswerWhereInput
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    cursor?: QuizAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * User.createdForums
   */
  export type User$createdForumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Forum
     */
    select?: ForumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Forum
     */
    omit?: ForumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumInclude<ExtArgs> | null
    where?: ForumWhereInput
    orderBy?: ForumOrderByWithRelationInput | ForumOrderByWithRelationInput[]
    cursor?: ForumWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumScalarFieldEnum | ForumScalarFieldEnum[]
  }

  /**
   * User.createdForumTopics
   */
  export type User$createdForumTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumTopic
     */
    omit?: ForumTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    where?: ForumTopicWhereInput
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    cursor?: ForumTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * User.forumReplies
   */
  export type User$forumRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReply
     */
    select?: ForumReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReply
     */
    omit?: ForumReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyInclude<ExtArgs> | null
    where?: ForumReplyWhereInput
    orderBy?: ForumReplyOrderByWithRelationInput | ForumReplyOrderByWithRelationInput[]
    cursor?: ForumReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumReplyScalarFieldEnum | ForumReplyScalarFieldEnum[]
  }

  /**
   * User.forumPosts
   */
  export type User$forumPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    cursor?: ForumPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * User.forumReplyReactions
   */
  export type User$forumReplyReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumReplyReaction
     */
    select?: ForumReplyReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumReplyReaction
     */
    omit?: ForumReplyReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumReplyReactionInclude<ExtArgs> | null
    where?: ForumReplyReactionWhereInput
    orderBy?: ForumReplyReactionOrderByWithRelationInput | ForumReplyReactionOrderByWithRelationInput[]
    cursor?: ForumReplyReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumReplyReactionScalarFieldEnum | ForumReplyReactionScalarFieldEnum[]
  }

  /**
   * User.forumPostReactions
   */
  export type User$forumPostReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostReaction
     */
    select?: ForumPostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPostReaction
     */
    omit?: ForumPostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostReactionInclude<ExtArgs> | null
    where?: ForumPostReactionWhereInput
    orderBy?: ForumPostReactionOrderByWithRelationInput | ForumPostReactionOrderByWithRelationInput[]
    cursor?: ForumPostReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumPostReactionScalarFieldEnum | ForumPostReactionScalarFieldEnum[]
  }

  /**
   * User.university
   */
  export type User$universityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the University
     */
    select?: UniversitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the University
     */
    omit?: UniversityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityInclude<ExtArgs> | null
    where?: UniversityWhereInput
  }

  /**
   * User.loanApplications
   */
  export type User$loanApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoanApplication
     */
    select?: LoanApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoanApplication
     */
    omit?: LoanApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoanApplicationInclude<ExtArgs> | null
    where?: LoanApplicationWhereInput
    orderBy?: LoanApplicationOrderByWithRelationInput | LoanApplicationOrderByWithRelationInput[]
    cursor?: LoanApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoanApplicationScalarFieldEnum | LoanApplicationScalarFieldEnum[]
  }

  /**
   * User.accommodationRatings
   */
  export type User$accommodationRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationRating
     */
    select?: AccommodationRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationRating
     */
    omit?: AccommodationRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationRatingInclude<ExtArgs> | null
    where?: AccommodationRatingWhereInput
    orderBy?: AccommodationRatingOrderByWithRelationInput | AccommodationRatingOrderByWithRelationInput[]
    cursor?: AccommodationRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccommodationRatingScalarFieldEnum | AccommodationRatingScalarFieldEnum[]
  }

  /**
   * User.applications
   */
  export type User$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UniversityApplications
     */
    select?: UniversityApplicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UniversityApplications
     */
    omit?: UniversityApplicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UniversityApplicationsInclude<ExtArgs> | null
    where?: UniversityApplicationsWhereInput
    orderBy?: UniversityApplicationsOrderByWithRelationInput | UniversityApplicationsOrderByWithRelationInput[]
    cursor?: UniversityApplicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UniversityApplicationsScalarFieldEnum | UniversityApplicationsScalarFieldEnum[]
  }

  /**
   * User.tokens
   */
  export type User$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * User.accommodations
   */
  export type User$accommodationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accommodation
     */
    select?: AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Accommodation
     */
    omit?: AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationInclude<ExtArgs> | null
    where?: AccommodationWhereInput
    orderBy?: AccommodationOrderByWithRelationInput | AccommodationOrderByWithRelationInput[]
    cursor?: AccommodationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccommodationScalarFieldEnum | AccommodationScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.otps
   */
  export type User$otpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    where?: OTPWhereInput
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    cursor?: OTPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.createdGroups
   */
  export type User$createdGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * User.adminOf
   */
  export type User$adminOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * User.groupMemberships
   */
  export type User$groupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * User.hostedEvents
   */
  export type User$hostedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User.articles
   */
  export type User$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * User.accommodationReviews
   */
  export type User$accommodationReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccommodationReview
     */
    select?: AccommodationReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccommodationReview
     */
    omit?: AccommodationReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccommodationReviewInclude<ExtArgs> | null
    where?: AccommodationReviewWhereInput
    orderBy?: AccommodationReviewOrderByWithRelationInput | AccommodationReviewOrderByWithRelationInput[]
    cursor?: AccommodationReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccommodationReviewScalarFieldEnum | AccommodationReviewScalarFieldEnum[]
  }

  /**
   * User.likedAccommodations
   */
  export type User$likedAccommodationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsInclude<ExtArgs> | null
    where?: LikedAccommodationsWhereInput
    orderBy?: LikedAccommodationsOrderByWithRelationInput | LikedAccommodationsOrderByWithRelationInput[]
    cursor?: LikedAccommodationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikedAccommodationsScalarFieldEnum | LikedAccommodationsScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model QuizAnswer
   */

  export type AggregateQuizAnswer = {
    _count: QuizAnswerCountAggregateOutputType | null
    _avg: QuizAnswerAvgAggregateOutputType | null
    _sum: QuizAnswerSumAggregateOutputType | null
    _min: QuizAnswerMinAggregateOutputType | null
    _max: QuizAnswerMaxAggregateOutputType | null
  }

  export type QuizAnswerAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type QuizAnswerSumAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type QuizAnswerMinAggregateOutputType = {
    id: number | null
    userId: string | null
    questionId: number | null
    answer: string | null
  }

  export type QuizAnswerMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    questionId: number | null
    answer: string | null
  }

  export type QuizAnswerCountAggregateOutputType = {
    id: number
    userId: number
    questionId: number
    answer: number
    _all: number
  }


  export type QuizAnswerAvgAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type QuizAnswerSumAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type QuizAnswerMinAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    answer?: true
  }

  export type QuizAnswerMaxAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    answer?: true
  }

  export type QuizAnswerCountAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    answer?: true
    _all?: true
  }

  export type QuizAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAnswer to aggregate.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAnswers
    **/
    _count?: true | QuizAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAnswerMaxAggregateInputType
  }

  export type GetQuizAnswerAggregateType<T extends QuizAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAnswer[P]>
      : GetScalarType<T[P], AggregateQuizAnswer[P]>
  }




  export type QuizAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAnswerWhereInput
    orderBy?: QuizAnswerOrderByWithAggregationInput | QuizAnswerOrderByWithAggregationInput[]
    by: QuizAnswerScalarFieldEnum[] | QuizAnswerScalarFieldEnum
    having?: QuizAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAnswerCountAggregateInputType | true
    _avg?: QuizAnswerAvgAggregateInputType
    _sum?: QuizAnswerSumAggregateInputType
    _min?: QuizAnswerMinAggregateInputType
    _max?: QuizAnswerMaxAggregateInputType
  }

  export type QuizAnswerGroupByOutputType = {
    id: number
    userId: string
    questionId: number
    answer: string
    _count: QuizAnswerCountAggregateOutputType | null
    _avg: QuizAnswerAvgAggregateOutputType | null
    _sum: QuizAnswerSumAggregateOutputType | null
    _min: QuizAnswerMinAggregateOutputType | null
    _max: QuizAnswerMaxAggregateOutputType | null
  }

  type GetQuizAnswerGroupByPayload<T extends QuizAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAnswerGroupByOutputType[P]>
        }
      >
    >


  export type QuizAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionId?: boolean
    answer?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAnswer"]>

  export type QuizAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionId?: boolean
    answer?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAnswer"]>

  export type QuizAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionId?: boolean
    answer?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAnswer"]>

  export type QuizAnswerSelectScalar = {
    id?: boolean
    userId?: boolean
    questionId?: boolean
    answer?: boolean
  }

  export type QuizAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "questionId" | "answer", ExtArgs["result"]["quizAnswer"]>
  export type QuizAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuizAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuizAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuizAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAnswer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      questionId: number
      answer: string
    }, ExtArgs["result"]["quizAnswer"]>
    composites: {}
  }

  type QuizAnswerGetPayload<S extends boolean | null | undefined | QuizAnswerDefaultArgs> = $Result.GetResult<Prisma.$QuizAnswerPayload, S>

  type QuizAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizAnswerCountAggregateInputType | true
    }

  export interface QuizAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAnswer'], meta: { name: 'QuizAnswer' } }
    /**
     * Find zero or one QuizAnswer that matches the filter.
     * @param {QuizAnswerFindUniqueArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizAnswerFindUniqueArgs>(args: SelectSubset<T, QuizAnswerFindUniqueArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizAnswerFindUniqueOrThrowArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerFindFirstArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizAnswerFindFirstArgs>(args?: SelectSubset<T, QuizAnswerFindFirstArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerFindFirstOrThrowArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAnswers
     * const quizAnswers = await prisma.quizAnswer.findMany()
     * 
     * // Get first 10 QuizAnswers
     * const quizAnswers = await prisma.quizAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizAnswerWithIdOnly = await prisma.quizAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizAnswerFindManyArgs>(args?: SelectSubset<T, QuizAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizAnswer.
     * @param {QuizAnswerCreateArgs} args - Arguments to create a QuizAnswer.
     * @example
     * // Create one QuizAnswer
     * const QuizAnswer = await prisma.quizAnswer.create({
     *   data: {
     *     // ... data to create a QuizAnswer
     *   }
     * })
     * 
     */
    create<T extends QuizAnswerCreateArgs>(args: SelectSubset<T, QuizAnswerCreateArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizAnswers.
     * @param {QuizAnswerCreateManyArgs} args - Arguments to create many QuizAnswers.
     * @example
     * // Create many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizAnswerCreateManyArgs>(args?: SelectSubset<T, QuizAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizAnswers and returns the data saved in the database.
     * @param {QuizAnswerCreateManyAndReturnArgs} args - Arguments to create many QuizAnswers.
     * @example
     * // Create many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizAnswers and only return the `id`
     * const quizAnswerWithIdOnly = await prisma.quizAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizAnswer.
     * @param {QuizAnswerDeleteArgs} args - Arguments to delete one QuizAnswer.
     * @example
     * // Delete one QuizAnswer
     * const QuizAnswer = await prisma.quizAnswer.delete({
     *   where: {
     *     // ... filter to delete one QuizAnswer
     *   }
     * })
     * 
     */
    delete<T extends QuizAnswerDeleteArgs>(args: SelectSubset<T, QuizAnswerDeleteArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizAnswer.
     * @param {QuizAnswerUpdateArgs} args - Arguments to update one QuizAnswer.
     * @example
     * // Update one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizAnswerUpdateArgs>(args: SelectSubset<T, QuizAnswerUpdateArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizAnswers.
     * @param {QuizAnswerDeleteManyArgs} args - Arguments to filter QuizAnswers to delete.
     * @example
     * // Delete a few QuizAnswers
     * const { count } = await prisma.quizAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizAnswerDeleteManyArgs>(args?: SelectSubset<T, QuizAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizAnswerUpdateManyArgs>(args: SelectSubset<T, QuizAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAnswers and returns the data updated in the database.
     * @param {QuizAnswerUpdateManyAndReturnArgs} args - Arguments to update many QuizAnswers.
     * @example
     * // Update many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizAnswers and only return the `id`
     * const quizAnswerWithIdOnly = await prisma.quizAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizAnswer.
     * @param {QuizAnswerUpsertArgs} args - Arguments to update or create a QuizAnswer.
     * @example
     * // Update or create a QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.upsert({
     *   create: {
     *     // ... data to create a QuizAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAnswer we want to update
     *   }
     * })
     */
    upsert<T extends QuizAnswerUpsertArgs>(args: SelectSubset<T, QuizAnswerUpsertArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerCountArgs} args - Arguments to filter QuizAnswers to count.
     * @example
     * // Count the number of QuizAnswers
     * const count = await prisma.quizAnswer.count({
     *   where: {
     *     // ... the filter for the QuizAnswers we want to count
     *   }
     * })
    **/
    count<T extends QuizAnswerCountArgs>(
      args?: Subset<T, QuizAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAnswerAggregateArgs>(args: Subset<T, QuizAnswerAggregateArgs>): Prisma.PrismaPromise<GetQuizAnswerAggregateType<T>>

    /**
     * Group by QuizAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAnswerGroupByArgs['orderBy'] }
        : { orderBy?: QuizAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAnswer model
   */
  readonly fields: QuizAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizAnswer model
   */
  interface QuizAnswerFieldRefs {
    readonly id: FieldRef<"QuizAnswer", 'Int'>
    readonly userId: FieldRef<"QuizAnswer", 'String'>
    readonly questionId: FieldRef<"QuizAnswer", 'Int'>
    readonly answer: FieldRef<"QuizAnswer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuizAnswer findUnique
   */
  export type QuizAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer findUniqueOrThrow
   */
  export type QuizAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer findFirst
   */
  export type QuizAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAnswers.
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAnswers.
     */
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAnswer findFirstOrThrow
   */
  export type QuizAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAnswers.
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAnswers.
     */
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAnswer findMany
   */
  export type QuizAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswers to fetch.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAnswers.
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAnswer create
   */
  export type QuizAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAnswer.
     */
    data: XOR<QuizAnswerCreateInput, QuizAnswerUncheckedCreateInput>
  }

  /**
   * QuizAnswer createMany
   */
  export type QuizAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAnswers.
     */
    data: QuizAnswerCreateManyInput | QuizAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAnswer createManyAndReturn
   */
  export type QuizAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many QuizAnswers.
     */
    data: QuizAnswerCreateManyInput | QuizAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAnswer update
   */
  export type QuizAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAnswer.
     */
    data: XOR<QuizAnswerUpdateInput, QuizAnswerUncheckedUpdateInput>
    /**
     * Choose, which QuizAnswer to update.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer updateMany
   */
  export type QuizAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAnswers.
     */
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuizAnswers to update
     */
    where?: QuizAnswerWhereInput
    /**
     * Limit how many QuizAnswers to update.
     */
    limit?: number
  }

  /**
   * QuizAnswer updateManyAndReturn
   */
  export type QuizAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * The data used to update QuizAnswers.
     */
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuizAnswers to update
     */
    where?: QuizAnswerWhereInput
    /**
     * Limit how many QuizAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAnswer upsert
   */
  export type QuizAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAnswer to update in case it exists.
     */
    where: QuizAnswerWhereUniqueInput
    /**
     * In case the QuizAnswer found by the `where` argument doesn't exist, create a new QuizAnswer with this data.
     */
    create: XOR<QuizAnswerCreateInput, QuizAnswerUncheckedCreateInput>
    /**
     * In case the QuizAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAnswerUpdateInput, QuizAnswerUncheckedUpdateInput>
  }

  /**
   * QuizAnswer delete
   */
  export type QuizAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter which QuizAnswer to delete.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer deleteMany
   */
  export type QuizAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAnswers to delete
     */
    where?: QuizAnswerWhereInput
    /**
     * Limit how many QuizAnswers to delete.
     */
    limit?: number
  }

  /**
   * QuizAnswer without action
   */
  export type QuizAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
  }


  /**
   * Model LikedAccommodations
   */

  export type AggregateLikedAccommodations = {
    _count: LikedAccommodationsCountAggregateOutputType | null
    _min: LikedAccommodationsMinAggregateOutputType | null
    _max: LikedAccommodationsMaxAggregateOutputType | null
  }

  export type LikedAccommodationsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accommodationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LikedAccommodationsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accommodationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LikedAccommodationsCountAggregateOutputType = {
    id: number
    userId: number
    accommodationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LikedAccommodationsMinAggregateInputType = {
    id?: true
    userId?: true
    accommodationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LikedAccommodationsMaxAggregateInputType = {
    id?: true
    userId?: true
    accommodationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LikedAccommodationsCountAggregateInputType = {
    id?: true
    userId?: true
    accommodationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LikedAccommodationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikedAccommodations to aggregate.
     */
    where?: LikedAccommodationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikedAccommodations to fetch.
     */
    orderBy?: LikedAccommodationsOrderByWithRelationInput | LikedAccommodationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikedAccommodationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikedAccommodations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikedAccommodations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LikedAccommodations
    **/
    _count?: true | LikedAccommodationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikedAccommodationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikedAccommodationsMaxAggregateInputType
  }

  export type GetLikedAccommodationsAggregateType<T extends LikedAccommodationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLikedAccommodations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLikedAccommodations[P]>
      : GetScalarType<T[P], AggregateLikedAccommodations[P]>
  }




  export type LikedAccommodationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikedAccommodationsWhereInput
    orderBy?: LikedAccommodationsOrderByWithAggregationInput | LikedAccommodationsOrderByWithAggregationInput[]
    by: LikedAccommodationsScalarFieldEnum[] | LikedAccommodationsScalarFieldEnum
    having?: LikedAccommodationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikedAccommodationsCountAggregateInputType | true
    _min?: LikedAccommodationsMinAggregateInputType
    _max?: LikedAccommodationsMaxAggregateInputType
  }

  export type LikedAccommodationsGroupByOutputType = {
    id: string
    userId: string
    accommodationId: string
    createdAt: Date
    updatedAt: Date
    _count: LikedAccommodationsCountAggregateOutputType | null
    _min: LikedAccommodationsMinAggregateOutputType | null
    _max: LikedAccommodationsMaxAggregateOutputType | null
  }

  type GetLikedAccommodationsGroupByPayload<T extends LikedAccommodationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikedAccommodationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikedAccommodationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikedAccommodationsGroupByOutputType[P]>
            : GetScalarType<T[P], LikedAccommodationsGroupByOutputType[P]>
        }
      >
    >


  export type LikedAccommodationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accommodationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likedAccommodations"]>

  export type LikedAccommodationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accommodationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likedAccommodations"]>

  export type LikedAccommodationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accommodationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likedAccommodations"]>

  export type LikedAccommodationsSelectScalar = {
    id?: boolean
    userId?: boolean
    accommodationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LikedAccommodationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accommodationId" | "createdAt" | "updatedAt", ExtArgs["result"]["likedAccommodations"]>
  export type LikedAccommodationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }
  export type LikedAccommodationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }
  export type LikedAccommodationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    accommodation?: boolean | AccommodationDefaultArgs<ExtArgs>
  }

  export type $LikedAccommodationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LikedAccommodations"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      accommodation: Prisma.$AccommodationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accommodationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["likedAccommodations"]>
    composites: {}
  }

  type LikedAccommodationsGetPayload<S extends boolean | null | undefined | LikedAccommodationsDefaultArgs> = $Result.GetResult<Prisma.$LikedAccommodationsPayload, S>

  type LikedAccommodationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikedAccommodationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikedAccommodationsCountAggregateInputType | true
    }

  export interface LikedAccommodationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LikedAccommodations'], meta: { name: 'LikedAccommodations' } }
    /**
     * Find zero or one LikedAccommodations that matches the filter.
     * @param {LikedAccommodationsFindUniqueArgs} args - Arguments to find a LikedAccommodations
     * @example
     * // Get one LikedAccommodations
     * const likedAccommodations = await prisma.likedAccommodations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikedAccommodationsFindUniqueArgs>(args: SelectSubset<T, LikedAccommodationsFindUniqueArgs<ExtArgs>>): Prisma__LikedAccommodationsClient<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LikedAccommodations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikedAccommodationsFindUniqueOrThrowArgs} args - Arguments to find a LikedAccommodations
     * @example
     * // Get one LikedAccommodations
     * const likedAccommodations = await prisma.likedAccommodations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikedAccommodationsFindUniqueOrThrowArgs>(args: SelectSubset<T, LikedAccommodationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikedAccommodationsClient<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LikedAccommodations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedAccommodationsFindFirstArgs} args - Arguments to find a LikedAccommodations
     * @example
     * // Get one LikedAccommodations
     * const likedAccommodations = await prisma.likedAccommodations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikedAccommodationsFindFirstArgs>(args?: SelectSubset<T, LikedAccommodationsFindFirstArgs<ExtArgs>>): Prisma__LikedAccommodationsClient<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LikedAccommodations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedAccommodationsFindFirstOrThrowArgs} args - Arguments to find a LikedAccommodations
     * @example
     * // Get one LikedAccommodations
     * const likedAccommodations = await prisma.likedAccommodations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikedAccommodationsFindFirstOrThrowArgs>(args?: SelectSubset<T, LikedAccommodationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikedAccommodationsClient<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LikedAccommodations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedAccommodationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LikedAccommodations
     * const likedAccommodations = await prisma.likedAccommodations.findMany()
     * 
     * // Get first 10 LikedAccommodations
     * const likedAccommodations = await prisma.likedAccommodations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likedAccommodationsWithIdOnly = await prisma.likedAccommodations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikedAccommodationsFindManyArgs>(args?: SelectSubset<T, LikedAccommodationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LikedAccommodations.
     * @param {LikedAccommodationsCreateArgs} args - Arguments to create a LikedAccommodations.
     * @example
     * // Create one LikedAccommodations
     * const LikedAccommodations = await prisma.likedAccommodations.create({
     *   data: {
     *     // ... data to create a LikedAccommodations
     *   }
     * })
     * 
     */
    create<T extends LikedAccommodationsCreateArgs>(args: SelectSubset<T, LikedAccommodationsCreateArgs<ExtArgs>>): Prisma__LikedAccommodationsClient<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LikedAccommodations.
     * @param {LikedAccommodationsCreateManyArgs} args - Arguments to create many LikedAccommodations.
     * @example
     * // Create many LikedAccommodations
     * const likedAccommodations = await prisma.likedAccommodations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikedAccommodationsCreateManyArgs>(args?: SelectSubset<T, LikedAccommodationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LikedAccommodations and returns the data saved in the database.
     * @param {LikedAccommodationsCreateManyAndReturnArgs} args - Arguments to create many LikedAccommodations.
     * @example
     * // Create many LikedAccommodations
     * const likedAccommodations = await prisma.likedAccommodations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LikedAccommodations and only return the `id`
     * const likedAccommodationsWithIdOnly = await prisma.likedAccommodations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikedAccommodationsCreateManyAndReturnArgs>(args?: SelectSubset<T, LikedAccommodationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LikedAccommodations.
     * @param {LikedAccommodationsDeleteArgs} args - Arguments to delete one LikedAccommodations.
     * @example
     * // Delete one LikedAccommodations
     * const LikedAccommodations = await prisma.likedAccommodations.delete({
     *   where: {
     *     // ... filter to delete one LikedAccommodations
     *   }
     * })
     * 
     */
    delete<T extends LikedAccommodationsDeleteArgs>(args: SelectSubset<T, LikedAccommodationsDeleteArgs<ExtArgs>>): Prisma__LikedAccommodationsClient<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LikedAccommodations.
     * @param {LikedAccommodationsUpdateArgs} args - Arguments to update one LikedAccommodations.
     * @example
     * // Update one LikedAccommodations
     * const likedAccommodations = await prisma.likedAccommodations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikedAccommodationsUpdateArgs>(args: SelectSubset<T, LikedAccommodationsUpdateArgs<ExtArgs>>): Prisma__LikedAccommodationsClient<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LikedAccommodations.
     * @param {LikedAccommodationsDeleteManyArgs} args - Arguments to filter LikedAccommodations to delete.
     * @example
     * // Delete a few LikedAccommodations
     * const { count } = await prisma.likedAccommodations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikedAccommodationsDeleteManyArgs>(args?: SelectSubset<T, LikedAccommodationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikedAccommodations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedAccommodationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LikedAccommodations
     * const likedAccommodations = await prisma.likedAccommodations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikedAccommodationsUpdateManyArgs>(args: SelectSubset<T, LikedAccommodationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikedAccommodations and returns the data updated in the database.
     * @param {LikedAccommodationsUpdateManyAndReturnArgs} args - Arguments to update many LikedAccommodations.
     * @example
     * // Update many LikedAccommodations
     * const likedAccommodations = await prisma.likedAccommodations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LikedAccommodations and only return the `id`
     * const likedAccommodationsWithIdOnly = await prisma.likedAccommodations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LikedAccommodationsUpdateManyAndReturnArgs>(args: SelectSubset<T, LikedAccommodationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LikedAccommodations.
     * @param {LikedAccommodationsUpsertArgs} args - Arguments to update or create a LikedAccommodations.
     * @example
     * // Update or create a LikedAccommodations
     * const likedAccommodations = await prisma.likedAccommodations.upsert({
     *   create: {
     *     // ... data to create a LikedAccommodations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LikedAccommodations we want to update
     *   }
     * })
     */
    upsert<T extends LikedAccommodationsUpsertArgs>(args: SelectSubset<T, LikedAccommodationsUpsertArgs<ExtArgs>>): Prisma__LikedAccommodationsClient<$Result.GetResult<Prisma.$LikedAccommodationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LikedAccommodations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedAccommodationsCountArgs} args - Arguments to filter LikedAccommodations to count.
     * @example
     * // Count the number of LikedAccommodations
     * const count = await prisma.likedAccommodations.count({
     *   where: {
     *     // ... the filter for the LikedAccommodations we want to count
     *   }
     * })
    **/
    count<T extends LikedAccommodationsCountArgs>(
      args?: Subset<T, LikedAccommodationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikedAccommodationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LikedAccommodations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedAccommodationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikedAccommodationsAggregateArgs>(args: Subset<T, LikedAccommodationsAggregateArgs>): Prisma.PrismaPromise<GetLikedAccommodationsAggregateType<T>>

    /**
     * Group by LikedAccommodations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikedAccommodationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikedAccommodationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikedAccommodationsGroupByArgs['orderBy'] }
        : { orderBy?: LikedAccommodationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikedAccommodationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikedAccommodationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LikedAccommodations model
   */
  readonly fields: LikedAccommodationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LikedAccommodations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikedAccommodationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    accommodation<T extends AccommodationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccommodationDefaultArgs<ExtArgs>>): Prisma__AccommodationClient<$Result.GetResult<Prisma.$AccommodationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LikedAccommodations model
   */
  interface LikedAccommodationsFieldRefs {
    readonly id: FieldRef<"LikedAccommodations", 'String'>
    readonly userId: FieldRef<"LikedAccommodations", 'String'>
    readonly accommodationId: FieldRef<"LikedAccommodations", 'String'>
    readonly createdAt: FieldRef<"LikedAccommodations", 'DateTime'>
    readonly updatedAt: FieldRef<"LikedAccommodations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LikedAccommodations findUnique
   */
  export type LikedAccommodationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsInclude<ExtArgs> | null
    /**
     * Filter, which LikedAccommodations to fetch.
     */
    where: LikedAccommodationsWhereUniqueInput
  }

  /**
   * LikedAccommodations findUniqueOrThrow
   */
  export type LikedAccommodationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsInclude<ExtArgs> | null
    /**
     * Filter, which LikedAccommodations to fetch.
     */
    where: LikedAccommodationsWhereUniqueInput
  }

  /**
   * LikedAccommodations findFirst
   */
  export type LikedAccommodationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsInclude<ExtArgs> | null
    /**
     * Filter, which LikedAccommodations to fetch.
     */
    where?: LikedAccommodationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikedAccommodations to fetch.
     */
    orderBy?: LikedAccommodationsOrderByWithRelationInput | LikedAccommodationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikedAccommodations.
     */
    cursor?: LikedAccommodationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikedAccommodations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikedAccommodations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikedAccommodations.
     */
    distinct?: LikedAccommodationsScalarFieldEnum | LikedAccommodationsScalarFieldEnum[]
  }

  /**
   * LikedAccommodations findFirstOrThrow
   */
  export type LikedAccommodationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsInclude<ExtArgs> | null
    /**
     * Filter, which LikedAccommodations to fetch.
     */
    where?: LikedAccommodationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikedAccommodations to fetch.
     */
    orderBy?: LikedAccommodationsOrderByWithRelationInput | LikedAccommodationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikedAccommodations.
     */
    cursor?: LikedAccommodationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikedAccommodations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikedAccommodations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikedAccommodations.
     */
    distinct?: LikedAccommodationsScalarFieldEnum | LikedAccommodationsScalarFieldEnum[]
  }

  /**
   * LikedAccommodations findMany
   */
  export type LikedAccommodationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsInclude<ExtArgs> | null
    /**
     * Filter, which LikedAccommodations to fetch.
     */
    where?: LikedAccommodationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikedAccommodations to fetch.
     */
    orderBy?: LikedAccommodationsOrderByWithRelationInput | LikedAccommodationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LikedAccommodations.
     */
    cursor?: LikedAccommodationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikedAccommodations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikedAccommodations.
     */
    skip?: number
    distinct?: LikedAccommodationsScalarFieldEnum | LikedAccommodationsScalarFieldEnum[]
  }

  /**
   * LikedAccommodations create
   */
  export type LikedAccommodationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsInclude<ExtArgs> | null
    /**
     * The data needed to create a LikedAccommodations.
     */
    data: XOR<LikedAccommodationsCreateInput, LikedAccommodationsUncheckedCreateInput>
  }

  /**
   * LikedAccommodations createMany
   */
  export type LikedAccommodationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LikedAccommodations.
     */
    data: LikedAccommodationsCreateManyInput | LikedAccommodationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LikedAccommodations createManyAndReturn
   */
  export type LikedAccommodationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * The data used to create many LikedAccommodations.
     */
    data: LikedAccommodationsCreateManyInput | LikedAccommodationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikedAccommodations update
   */
  export type LikedAccommodationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsInclude<ExtArgs> | null
    /**
     * The data needed to update a LikedAccommodations.
     */
    data: XOR<LikedAccommodationsUpdateInput, LikedAccommodationsUncheckedUpdateInput>
    /**
     * Choose, which LikedAccommodations to update.
     */
    where: LikedAccommodationsWhereUniqueInput
  }

  /**
   * LikedAccommodations updateMany
   */
  export type LikedAccommodationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LikedAccommodations.
     */
    data: XOR<LikedAccommodationsUpdateManyMutationInput, LikedAccommodationsUncheckedUpdateManyInput>
    /**
     * Filter which LikedAccommodations to update
     */
    where?: LikedAccommodationsWhereInput
    /**
     * Limit how many LikedAccommodations to update.
     */
    limit?: number
  }

  /**
   * LikedAccommodations updateManyAndReturn
   */
  export type LikedAccommodationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * The data used to update LikedAccommodations.
     */
    data: XOR<LikedAccommodationsUpdateManyMutationInput, LikedAccommodationsUncheckedUpdateManyInput>
    /**
     * Filter which LikedAccommodations to update
     */
    where?: LikedAccommodationsWhereInput
    /**
     * Limit how many LikedAccommodations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikedAccommodations upsert
   */
  export type LikedAccommodationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsInclude<ExtArgs> | null
    /**
     * The filter to search for the LikedAccommodations to update in case it exists.
     */
    where: LikedAccommodationsWhereUniqueInput
    /**
     * In case the LikedAccommodations found by the `where` argument doesn't exist, create a new LikedAccommodations with this data.
     */
    create: XOR<LikedAccommodationsCreateInput, LikedAccommodationsUncheckedCreateInput>
    /**
     * In case the LikedAccommodations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikedAccommodationsUpdateInput, LikedAccommodationsUncheckedUpdateInput>
  }

  /**
   * LikedAccommodations delete
   */
  export type LikedAccommodationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsInclude<ExtArgs> | null
    /**
     * Filter which LikedAccommodations to delete.
     */
    where: LikedAccommodationsWhereUniqueInput
  }

  /**
   * LikedAccommodations deleteMany
   */
  export type LikedAccommodationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikedAccommodations to delete
     */
    where?: LikedAccommodationsWhereInput
    /**
     * Limit how many LikedAccommodations to delete.
     */
    limit?: number
  }

  /**
   * LikedAccommodations without action
   */
  export type LikedAccommodationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikedAccommodations
     */
    select?: LikedAccommodationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikedAccommodations
     */
    omit?: LikedAccommodationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikedAccommodationsInclude<ExtArgs> | null
  }


  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    type: $Enums.TokenType | null
    userId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type TokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    type: $Enums.TokenType | null
    userId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    token: number
    type: number
    userId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type TokenMinAggregateInputType = {
    id?: true
    token?: true
    type?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    token?: true
    type?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    token?: true
    type?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: string
    token: string
    type: $Enums.TokenType
    userId: string
    createdAt: Date
    expiresAt: Date
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    type?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    type?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    type?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    token?: boolean
    type?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type TokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "type" | "userId" | "createdAt" | "expiresAt", ExtArgs["result"]["token"]>
  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      type: $Enums.TokenType
      userId: string
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens and returns the data updated in the database.
     * @param {TokenUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TokenUpdateManyAndReturnArgs>(args: SelectSubset<T, TokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'String'>
    readonly token: FieldRef<"Token", 'String'>
    readonly type: FieldRef<"Token", 'TokenType'>
    readonly userId: FieldRef<"Token", 'String'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
    readonly expiresAt: FieldRef<"Token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token createManyAndReturn
   */
  export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
  }

  /**
   * Token updateManyAndReturn
   */
  export type TokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to delete.
     */
    limit?: number
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
  }


  /**
   * Model OTP
   */

  export type AggregateOTP = {
    _count: OTPCountAggregateOutputType | null
    _avg: OTPAvgAggregateOutputType | null
    _sum: OTPSumAggregateOutputType | null
    _min: OTPMinAggregateOutputType | null
    _max: OTPMaxAggregateOutputType | null
  }

  export type OTPAvgAggregateOutputType = {
    attempts: number | null
  }

  export type OTPSumAggregateOutputType = {
    attempts: number | null
  }

  export type OTPMinAggregateOutputType = {
    id: string | null
    userId: string | null
    otpCode: string | null
    type: $Enums.OTPType | null
    purpose: $Enums.OTPPurpose | null
    verified: boolean | null
    attempts: number | null
    expiresAt: Date | null
    verifiedAt: Date | null
    invalidated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OTPMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    otpCode: string | null
    type: $Enums.OTPType | null
    purpose: $Enums.OTPPurpose | null
    verified: boolean | null
    attempts: number | null
    expiresAt: Date | null
    verifiedAt: Date | null
    invalidated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OTPCountAggregateOutputType = {
    id: number
    userId: number
    otpCode: number
    type: number
    purpose: number
    verified: number
    attempts: number
    expiresAt: number
    verifiedAt: number
    invalidated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OTPAvgAggregateInputType = {
    attempts?: true
  }

  export type OTPSumAggregateInputType = {
    attempts?: true
  }

  export type OTPMinAggregateInputType = {
    id?: true
    userId?: true
    otpCode?: true
    type?: true
    purpose?: true
    verified?: true
    attempts?: true
    expiresAt?: true
    verifiedAt?: true
    invalidated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OTPMaxAggregateInputType = {
    id?: true
    userId?: true
    otpCode?: true
    type?: true
    purpose?: true
    verified?: true
    attempts?: true
    expiresAt?: true
    verifiedAt?: true
    invalidated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OTPCountAggregateInputType = {
    id?: true
    userId?: true
    otpCode?: true
    type?: true
    purpose?: true
    verified?: true
    attempts?: true
    expiresAt?: true
    verifiedAt?: true
    invalidated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OTPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTP to aggregate.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OTPS
    **/
    _count?: true | OTPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OTPAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OTPSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OTPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OTPMaxAggregateInputType
  }

  export type GetOTPAggregateType<T extends OTPAggregateArgs> = {
        [P in keyof T & keyof AggregateOTP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOTP[P]>
      : GetScalarType<T[P], AggregateOTP[P]>
  }




  export type OTPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTPWhereInput
    orderBy?: OTPOrderByWithAggregationInput | OTPOrderByWithAggregationInput[]
    by: OTPScalarFieldEnum[] | OTPScalarFieldEnum
    having?: OTPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OTPCountAggregateInputType | true
    _avg?: OTPAvgAggregateInputType
    _sum?: OTPSumAggregateInputType
    _min?: OTPMinAggregateInputType
    _max?: OTPMaxAggregateInputType
  }

  export type OTPGroupByOutputType = {
    id: string
    userId: string
    otpCode: string
    type: $Enums.OTPType
    purpose: $Enums.OTPPurpose
    verified: boolean
    attempts: number
    expiresAt: Date
    verifiedAt: Date | null
    invalidated: boolean
    createdAt: Date
    updatedAt: Date
    _count: OTPCountAggregateOutputType | null
    _avg: OTPAvgAggregateOutputType | null
    _sum: OTPSumAggregateOutputType | null
    _min: OTPMinAggregateOutputType | null
    _max: OTPMaxAggregateOutputType | null
  }

  type GetOTPGroupByPayload<T extends OTPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OTPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OTPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OTPGroupByOutputType[P]>
            : GetScalarType<T[P], OTPGroupByOutputType[P]>
        }
      >
    >


  export type OTPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otpCode?: boolean
    type?: boolean
    purpose?: boolean
    verified?: boolean
    attempts?: boolean
    expiresAt?: boolean
    verifiedAt?: boolean
    invalidated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otpCode?: boolean
    type?: boolean
    purpose?: boolean
    verified?: boolean
    attempts?: boolean
    expiresAt?: boolean
    verifiedAt?: boolean
    invalidated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otpCode?: boolean
    type?: boolean
    purpose?: boolean
    verified?: boolean
    attempts?: boolean
    expiresAt?: boolean
    verifiedAt?: boolean
    invalidated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oTP"]>

  export type OTPSelectScalar = {
    id?: boolean
    userId?: boolean
    otpCode?: boolean
    type?: boolean
    purpose?: boolean
    verified?: boolean
    attempts?: boolean
    expiresAt?: boolean
    verifiedAt?: boolean
    invalidated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OTPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "otpCode" | "type" | "purpose" | "verified" | "attempts" | "expiresAt" | "verifiedAt" | "invalidated" | "createdAt" | "updatedAt", ExtArgs["result"]["oTP"]>
  export type OTPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OTPIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OTPIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OTPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OTP"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      otpCode: string
      type: $Enums.OTPType
      purpose: $Enums.OTPPurpose
      verified: boolean
      attempts: number
      expiresAt: Date
      verifiedAt: Date | null
      invalidated: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["oTP"]>
    composites: {}
  }

  type OTPGetPayload<S extends boolean | null | undefined | OTPDefaultArgs> = $Result.GetResult<Prisma.$OTPPayload, S>

  type OTPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OTPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OTPCountAggregateInputType | true
    }

  export interface OTPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OTP'], meta: { name: 'OTP' } }
    /**
     * Find zero or one OTP that matches the filter.
     * @param {OTPFindUniqueArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OTPFindUniqueArgs>(args: SelectSubset<T, OTPFindUniqueArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OTP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OTPFindUniqueOrThrowArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OTPFindUniqueOrThrowArgs>(args: SelectSubset<T, OTPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OTP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindFirstArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OTPFindFirstArgs>(args?: SelectSubset<T, OTPFindFirstArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OTP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindFirstOrThrowArgs} args - Arguments to find a OTP
     * @example
     * // Get one OTP
     * const oTP = await prisma.oTP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OTPFindFirstOrThrowArgs>(args?: SelectSubset<T, OTPFindFirstOrThrowArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OTPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OTPS
     * const oTPS = await prisma.oTP.findMany()
     * 
     * // Get first 10 OTPS
     * const oTPS = await prisma.oTP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oTPWithIdOnly = await prisma.oTP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OTPFindManyArgs>(args?: SelectSubset<T, OTPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OTP.
     * @param {OTPCreateArgs} args - Arguments to create a OTP.
     * @example
     * // Create one OTP
     * const OTP = await prisma.oTP.create({
     *   data: {
     *     // ... data to create a OTP
     *   }
     * })
     * 
     */
    create<T extends OTPCreateArgs>(args: SelectSubset<T, OTPCreateArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OTPS.
     * @param {OTPCreateManyArgs} args - Arguments to create many OTPS.
     * @example
     * // Create many OTPS
     * const oTP = await prisma.oTP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OTPCreateManyArgs>(args?: SelectSubset<T, OTPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OTPS and returns the data saved in the database.
     * @param {OTPCreateManyAndReturnArgs} args - Arguments to create many OTPS.
     * @example
     * // Create many OTPS
     * const oTP = await prisma.oTP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OTPS and only return the `id`
     * const oTPWithIdOnly = await prisma.oTP.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OTPCreateManyAndReturnArgs>(args?: SelectSubset<T, OTPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OTP.
     * @param {OTPDeleteArgs} args - Arguments to delete one OTP.
     * @example
     * // Delete one OTP
     * const OTP = await prisma.oTP.delete({
     *   where: {
     *     // ... filter to delete one OTP
     *   }
     * })
     * 
     */
    delete<T extends OTPDeleteArgs>(args: SelectSubset<T, OTPDeleteArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OTP.
     * @param {OTPUpdateArgs} args - Arguments to update one OTP.
     * @example
     * // Update one OTP
     * const oTP = await prisma.oTP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OTPUpdateArgs>(args: SelectSubset<T, OTPUpdateArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OTPS.
     * @param {OTPDeleteManyArgs} args - Arguments to filter OTPS to delete.
     * @example
     * // Delete a few OTPS
     * const { count } = await prisma.oTP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OTPDeleteManyArgs>(args?: SelectSubset<T, OTPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OTPS
     * const oTP = await prisma.oTP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OTPUpdateManyArgs>(args: SelectSubset<T, OTPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTPS and returns the data updated in the database.
     * @param {OTPUpdateManyAndReturnArgs} args - Arguments to update many OTPS.
     * @example
     * // Update many OTPS
     * const oTP = await prisma.oTP.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OTPS and only return the `id`
     * const oTPWithIdOnly = await prisma.oTP.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OTPUpdateManyAndReturnArgs>(args: SelectSubset<T, OTPUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OTP.
     * @param {OTPUpsertArgs} args - Arguments to update or create a OTP.
     * @example
     * // Update or create a OTP
     * const oTP = await prisma.oTP.upsert({
     *   create: {
     *     // ... data to create a OTP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OTP we want to update
     *   }
     * })
     */
    upsert<T extends OTPUpsertArgs>(args: SelectSubset<T, OTPUpsertArgs<ExtArgs>>): Prisma__OTPClient<$Result.GetResult<Prisma.$OTPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OTPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPCountArgs} args - Arguments to filter OTPS to count.
     * @example
     * // Count the number of OTPS
     * const count = await prisma.oTP.count({
     *   where: {
     *     // ... the filter for the OTPS we want to count
     *   }
     * })
    **/
    count<T extends OTPCountArgs>(
      args?: Subset<T, OTPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OTPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OTPAggregateArgs>(args: Subset<T, OTPAggregateArgs>): Prisma.PrismaPromise<GetOTPAggregateType<T>>

    /**
     * Group by OTP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OTPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OTPGroupByArgs['orderBy'] }
        : { orderBy?: OTPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OTPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOTPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OTP model
   */
  readonly fields: OTPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OTP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OTPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OTP model
   */
  interface OTPFieldRefs {
    readonly id: FieldRef<"OTP", 'String'>
    readonly userId: FieldRef<"OTP", 'String'>
    readonly otpCode: FieldRef<"OTP", 'String'>
    readonly type: FieldRef<"OTP", 'OTPType'>
    readonly purpose: FieldRef<"OTP", 'OTPPurpose'>
    readonly verified: FieldRef<"OTP", 'Boolean'>
    readonly attempts: FieldRef<"OTP", 'Int'>
    readonly expiresAt: FieldRef<"OTP", 'DateTime'>
    readonly verifiedAt: FieldRef<"OTP", 'DateTime'>
    readonly invalidated: FieldRef<"OTP", 'Boolean'>
    readonly createdAt: FieldRef<"OTP", 'DateTime'>
    readonly updatedAt: FieldRef<"OTP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OTP findUnique
   */
  export type OTPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP findUniqueOrThrow
   */
  export type OTPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP findFirst
   */
  export type OTPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPS.
     */
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP findFirstOrThrow
   */
  export type OTPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * Filter, which OTP to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTPS.
     */
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP findMany
   */
  export type OTPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * Filter, which OTPS to fetch.
     */
    where?: OTPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTPS to fetch.
     */
    orderBy?: OTPOrderByWithRelationInput | OTPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OTPS.
     */
    cursor?: OTPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTPS.
     */
    skip?: number
    distinct?: OTPScalarFieldEnum | OTPScalarFieldEnum[]
  }

  /**
   * OTP create
   */
  export type OTPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * The data needed to create a OTP.
     */
    data: XOR<OTPCreateInput, OTPUncheckedCreateInput>
  }

  /**
   * OTP createMany
   */
  export type OTPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OTPS.
     */
    data: OTPCreateManyInput | OTPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OTP createManyAndReturn
   */
  export type OTPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The data used to create many OTPS.
     */
    data: OTPCreateManyInput | OTPCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OTP update
   */
  export type OTPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * The data needed to update a OTP.
     */
    data: XOR<OTPUpdateInput, OTPUncheckedUpdateInput>
    /**
     * Choose, which OTP to update.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP updateMany
   */
  export type OTPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OTPS.
     */
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyInput>
    /**
     * Filter which OTPS to update
     */
    where?: OTPWhereInput
    /**
     * Limit how many OTPS to update.
     */
    limit?: number
  }

  /**
   * OTP updateManyAndReturn
   */
  export type OTPUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * The data used to update OTPS.
     */
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyInput>
    /**
     * Filter which OTPS to update
     */
    where?: OTPWhereInput
    /**
     * Limit how many OTPS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OTP upsert
   */
  export type OTPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * The filter to search for the OTP to update in case it exists.
     */
    where: OTPWhereUniqueInput
    /**
     * In case the OTP found by the `where` argument doesn't exist, create a new OTP with this data.
     */
    create: XOR<OTPCreateInput, OTPUncheckedCreateInput>
    /**
     * In case the OTP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OTPUpdateInput, OTPUncheckedUpdateInput>
  }

  /**
   * OTP delete
   */
  export type OTPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
    /**
     * Filter which OTP to delete.
     */
    where: OTPWhereUniqueInput
  }

  /**
   * OTP deleteMany
   */
  export type OTPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTPS to delete
     */
    where?: OTPWhereInput
    /**
     * Limit how many OTPS to delete.
     */
    limit?: number
  }

  /**
   * OTP without action
   */
  export type OTPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OTP
     */
    select?: OTPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OTP
     */
    omit?: OTPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTPInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Blog
   */

  export type AggregateBlog = {
    _count: BlogCountAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  export type BlogMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    summary: string | null
    coverImage: string | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    summary: string | null
    coverImage: string | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    summary: number
    coverImage: number
    published: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    summary?: true
    coverImage?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    summary?: true
    coverImage?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    summary?: true
    coverImage?: true
    published?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blog to aggregate.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blogs
    **/
    _count?: true | BlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogMaxAggregateInputType
  }

  export type GetBlogAggregateType<T extends BlogAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog[P]>
      : GetScalarType<T[P], AggregateBlog[P]>
  }




  export type BlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithAggregationInput | BlogOrderByWithAggregationInput[]
    by: BlogScalarFieldEnum[] | BlogScalarFieldEnum
    having?: BlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCountAggregateInputType | true
    _min?: BlogMinAggregateInputType
    _max?: BlogMaxAggregateInputType
  }

  export type BlogGroupByOutputType = {
    id: string
    title: string
    slug: string
    summary: string
    coverImage: string | null
    published: boolean
    createdAt: Date
    updatedAt: Date
    _count: BlogCountAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  type GetBlogGroupByPayload<T extends BlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogGroupByOutputType[P]>
            : GetScalarType<T[P], BlogGroupByOutputType[P]>
        }
      >
    >


  export type BlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    summary?: boolean
    coverImage?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contentBlocks?: boolean | Blog$contentBlocksArgs<ExtArgs>
    _count?: boolean | BlogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    summary?: boolean
    coverImage?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    summary?: boolean
    coverImage?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    summary?: boolean
    coverImage?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "summary" | "coverImage" | "published" | "createdAt" | "updatedAt", ExtArgs["result"]["blog"]>
  export type BlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentBlocks?: boolean | Blog$contentBlocksArgs<ExtArgs>
    _count?: boolean | BlogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BlogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blog"
    objects: {
      contentBlocks: Prisma.$ContentBlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      summary: string
      coverImage: string | null
      published: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blog"]>
    composites: {}
  }

  type BlogGetPayload<S extends boolean | null | undefined | BlogDefaultArgs> = $Result.GetResult<Prisma.$BlogPayload, S>

  type BlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogCountAggregateInputType | true
    }

  export interface BlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blog'], meta: { name: 'Blog' } }
    /**
     * Find zero or one Blog that matches the filter.
     * @param {BlogFindUniqueArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogFindUniqueArgs>(args: SelectSubset<T, BlogFindUniqueArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogFindUniqueOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogFindFirstArgs>(args?: SelectSubset<T, BlogFindFirstArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blog.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogWithIdOnly = await prisma.blog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogFindManyArgs>(args?: SelectSubset<T, BlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blog.
     * @param {BlogCreateArgs} args - Arguments to create a Blog.
     * @example
     * // Create one Blog
     * const Blog = await prisma.blog.create({
     *   data: {
     *     // ... data to create a Blog
     *   }
     * })
     * 
     */
    create<T extends BlogCreateArgs>(args: SelectSubset<T, BlogCreateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blogs.
     * @param {BlogCreateManyArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blog = await prisma.blog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogCreateManyArgs>(args?: SelectSubset<T, BlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blogs and returns the data saved in the database.
     * @param {BlogCreateManyAndReturnArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blog = await prisma.blog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blogs and only return the `id`
     * const blogWithIdOnly = await prisma.blog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blog.
     * @param {BlogDeleteArgs} args - Arguments to delete one Blog.
     * @example
     * // Delete one Blog
     * const Blog = await prisma.blog.delete({
     *   where: {
     *     // ... filter to delete one Blog
     *   }
     * })
     * 
     */
    delete<T extends BlogDeleteArgs>(args: SelectSubset<T, BlogDeleteArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blog.
     * @param {BlogUpdateArgs} args - Arguments to update one Blog.
     * @example
     * // Update one Blog
     * const blog = await prisma.blog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogUpdateArgs>(args: SelectSubset<T, BlogUpdateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blogs.
     * @param {BlogDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogDeleteManyArgs>(args?: SelectSubset<T, BlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogUpdateManyArgs>(args: SelectSubset<T, BlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs and returns the data updated in the database.
     * @param {BlogUpdateManyAndReturnArgs} args - Arguments to update many Blogs.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blogs and only return the `id`
     * const blogWithIdOnly = await prisma.blog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blog.
     * @param {BlogUpsertArgs} args - Arguments to update or create a Blog.
     * @example
     * // Update or create a Blog
     * const blog = await prisma.blog.upsert({
     *   create: {
     *     // ... data to create a Blog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog we want to update
     *   }
     * })
     */
    upsert<T extends BlogUpsertArgs>(args: SelectSubset<T, BlogUpsertArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blog.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends BlogCountArgs>(
      args?: Subset<T, BlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogAggregateArgs>(args: Subset<T, BlogAggregateArgs>): Prisma.PrismaPromise<GetBlogAggregateType<T>>

    /**
     * Group by Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogGroupByArgs['orderBy'] }
        : { orderBy?: BlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blog model
   */
  readonly fields: BlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contentBlocks<T extends Blog$contentBlocksArgs<ExtArgs> = {}>(args?: Subset<T, Blog$contentBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Blog model
   */
  interface BlogFieldRefs {
    readonly id: FieldRef<"Blog", 'String'>
    readonly title: FieldRef<"Blog", 'String'>
    readonly slug: FieldRef<"Blog", 'String'>
    readonly summary: FieldRef<"Blog", 'String'>
    readonly coverImage: FieldRef<"Blog", 'String'>
    readonly published: FieldRef<"Blog", 'Boolean'>
    readonly createdAt: FieldRef<"Blog", 'DateTime'>
    readonly updatedAt: FieldRef<"Blog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Blog findUnique
   */
  export type BlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findUniqueOrThrow
   */
  export type BlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findFirst
   */
  export type BlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findFirstOrThrow
   */
  export type BlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findMany
   */
  export type BlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog create
   */
  export type BlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The data needed to create a Blog.
     */
    data: XOR<BlogCreateInput, BlogUncheckedCreateInput>
  }

  /**
   * Blog createMany
   */
  export type BlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blogs.
     */
    data: BlogCreateManyInput | BlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blog createManyAndReturn
   */
  export type BlogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The data used to create many Blogs.
     */
    data: BlogCreateManyInput | BlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blog update
   */
  export type BlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The data needed to update a Blog.
     */
    data: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
    /**
     * Choose, which Blog to update.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog updateMany
   */
  export type BlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to update.
     */
    limit?: number
  }

  /**
   * Blog updateManyAndReturn
   */
  export type BlogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to update.
     */
    limit?: number
  }

  /**
   * Blog upsert
   */
  export type BlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The filter to search for the Blog to update in case it exists.
     */
    where: BlogWhereUniqueInput
    /**
     * In case the Blog found by the `where` argument doesn't exist, create a new Blog with this data.
     */
    create: XOR<BlogCreateInput, BlogUncheckedCreateInput>
    /**
     * In case the Blog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
  }

  /**
   * Blog delete
   */
  export type BlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter which Blog to delete.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog deleteMany
   */
  export type BlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blogs to delete
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to delete.
     */
    limit?: number
  }

  /**
   * Blog.contentBlocks
   */
  export type Blog$contentBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    where?: ContentBlockWhereInput
    orderBy?: ContentBlockOrderByWithRelationInput | ContentBlockOrderByWithRelationInput[]
    cursor?: ContentBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentBlockScalarFieldEnum | ContentBlockScalarFieldEnum[]
  }

  /**
   * Blog without action
   */
  export type BlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
  }


  /**
   * Model ContentBlock
   */

  export type AggregateContentBlock = {
    _count: ContentBlockCountAggregateOutputType | null
    _avg: ContentBlockAvgAggregateOutputType | null
    _sum: ContentBlockSumAggregateOutputType | null
    _min: ContentBlockMinAggregateOutputType | null
    _max: ContentBlockMaxAggregateOutputType | null
  }

  export type ContentBlockAvgAggregateOutputType = {
    order: number | null
  }

  export type ContentBlockSumAggregateOutputType = {
    order: number | null
  }

  export type ContentBlockMinAggregateOutputType = {
    id: string | null
    type: string | null
    content: string | null
    order: number | null
    blogId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentBlockMaxAggregateOutputType = {
    id: string | null
    type: string | null
    content: string | null
    order: number | null
    blogId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentBlockCountAggregateOutputType = {
    id: number
    type: number
    content: number
    order: number
    blogId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentBlockAvgAggregateInputType = {
    order?: true
  }

  export type ContentBlockSumAggregateInputType = {
    order?: true
  }

  export type ContentBlockMinAggregateInputType = {
    id?: true
    type?: true
    content?: true
    order?: true
    blogId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentBlockMaxAggregateInputType = {
    id?: true
    type?: true
    content?: true
    order?: true
    blogId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentBlockCountAggregateInputType = {
    id?: true
    type?: true
    content?: true
    order?: true
    blogId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentBlock to aggregate.
     */
    where?: ContentBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentBlocks to fetch.
     */
    orderBy?: ContentBlockOrderByWithRelationInput | ContentBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentBlocks
    **/
    _count?: true | ContentBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentBlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentBlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentBlockMaxAggregateInputType
  }

  export type GetContentBlockAggregateType<T extends ContentBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateContentBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentBlock[P]>
      : GetScalarType<T[P], AggregateContentBlock[P]>
  }




  export type ContentBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentBlockWhereInput
    orderBy?: ContentBlockOrderByWithAggregationInput | ContentBlockOrderByWithAggregationInput[]
    by: ContentBlockScalarFieldEnum[] | ContentBlockScalarFieldEnum
    having?: ContentBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentBlockCountAggregateInputType | true
    _avg?: ContentBlockAvgAggregateInputType
    _sum?: ContentBlockSumAggregateInputType
    _min?: ContentBlockMinAggregateInputType
    _max?: ContentBlockMaxAggregateInputType
  }

  export type ContentBlockGroupByOutputType = {
    id: string
    type: string
    content: string
    order: number
    blogId: string
    createdAt: Date
    updatedAt: Date
    _count: ContentBlockCountAggregateOutputType | null
    _avg: ContentBlockAvgAggregateOutputType | null
    _sum: ContentBlockSumAggregateOutputType | null
    _min: ContentBlockMinAggregateOutputType | null
    _max: ContentBlockMaxAggregateOutputType | null
  }

  type GetContentBlockGroupByPayload<T extends ContentBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentBlockGroupByOutputType[P]>
            : GetScalarType<T[P], ContentBlockGroupByOutputType[P]>
        }
      >
    >


  export type ContentBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    blogId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentBlock"]>

  export type ContentBlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    blogId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentBlock"]>

  export type ContentBlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    blogId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentBlock"]>

  export type ContentBlockSelectScalar = {
    id?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    blogId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContentBlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "content" | "order" | "blogId" | "createdAt" | "updatedAt", ExtArgs["result"]["contentBlock"]>
  export type ContentBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }
  export type ContentBlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }
  export type ContentBlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }

  export type $ContentBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentBlock"
    objects: {
      blog: Prisma.$BlogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      content: string
      order: number
      blogId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contentBlock"]>
    composites: {}
  }

  type ContentBlockGetPayload<S extends boolean | null | undefined | ContentBlockDefaultArgs> = $Result.GetResult<Prisma.$ContentBlockPayload, S>

  type ContentBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentBlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentBlockCountAggregateInputType | true
    }

  export interface ContentBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentBlock'], meta: { name: 'ContentBlock' } }
    /**
     * Find zero or one ContentBlock that matches the filter.
     * @param {ContentBlockFindUniqueArgs} args - Arguments to find a ContentBlock
     * @example
     * // Get one ContentBlock
     * const contentBlock = await prisma.contentBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentBlockFindUniqueArgs>(args: SelectSubset<T, ContentBlockFindUniqueArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentBlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentBlockFindUniqueOrThrowArgs} args - Arguments to find a ContentBlock
     * @example
     * // Get one ContentBlock
     * const contentBlock = await prisma.contentBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockFindFirstArgs} args - Arguments to find a ContentBlock
     * @example
     * // Get one ContentBlock
     * const contentBlock = await prisma.contentBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentBlockFindFirstArgs>(args?: SelectSubset<T, ContentBlockFindFirstArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockFindFirstOrThrowArgs} args - Arguments to find a ContentBlock
     * @example
     * // Get one ContentBlock
     * const contentBlock = await prisma.contentBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentBlocks
     * const contentBlocks = await prisma.contentBlock.findMany()
     * 
     * // Get first 10 ContentBlocks
     * const contentBlocks = await prisma.contentBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentBlockWithIdOnly = await prisma.contentBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentBlockFindManyArgs>(args?: SelectSubset<T, ContentBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentBlock.
     * @param {ContentBlockCreateArgs} args - Arguments to create a ContentBlock.
     * @example
     * // Create one ContentBlock
     * const ContentBlock = await prisma.contentBlock.create({
     *   data: {
     *     // ... data to create a ContentBlock
     *   }
     * })
     * 
     */
    create<T extends ContentBlockCreateArgs>(args: SelectSubset<T, ContentBlockCreateArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentBlocks.
     * @param {ContentBlockCreateManyArgs} args - Arguments to create many ContentBlocks.
     * @example
     * // Create many ContentBlocks
     * const contentBlock = await prisma.contentBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentBlockCreateManyArgs>(args?: SelectSubset<T, ContentBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentBlocks and returns the data saved in the database.
     * @param {ContentBlockCreateManyAndReturnArgs} args - Arguments to create many ContentBlocks.
     * @example
     * // Create many ContentBlocks
     * const contentBlock = await prisma.contentBlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentBlocks and only return the `id`
     * const contentBlockWithIdOnly = await prisma.contentBlock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentBlockCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentBlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentBlock.
     * @param {ContentBlockDeleteArgs} args - Arguments to delete one ContentBlock.
     * @example
     * // Delete one ContentBlock
     * const ContentBlock = await prisma.contentBlock.delete({
     *   where: {
     *     // ... filter to delete one ContentBlock
     *   }
     * })
     * 
     */
    delete<T extends ContentBlockDeleteArgs>(args: SelectSubset<T, ContentBlockDeleteArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentBlock.
     * @param {ContentBlockUpdateArgs} args - Arguments to update one ContentBlock.
     * @example
     * // Update one ContentBlock
     * const contentBlock = await prisma.contentBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentBlockUpdateArgs>(args: SelectSubset<T, ContentBlockUpdateArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentBlocks.
     * @param {ContentBlockDeleteManyArgs} args - Arguments to filter ContentBlocks to delete.
     * @example
     * // Delete a few ContentBlocks
     * const { count } = await prisma.contentBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentBlockDeleteManyArgs>(args?: SelectSubset<T, ContentBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentBlocks
     * const contentBlock = await prisma.contentBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentBlockUpdateManyArgs>(args: SelectSubset<T, ContentBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentBlocks and returns the data updated in the database.
     * @param {ContentBlockUpdateManyAndReturnArgs} args - Arguments to update many ContentBlocks.
     * @example
     * // Update many ContentBlocks
     * const contentBlock = await prisma.contentBlock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentBlocks and only return the `id`
     * const contentBlockWithIdOnly = await prisma.contentBlock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentBlockUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentBlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentBlock.
     * @param {ContentBlockUpsertArgs} args - Arguments to update or create a ContentBlock.
     * @example
     * // Update or create a ContentBlock
     * const contentBlock = await prisma.contentBlock.upsert({
     *   create: {
     *     // ... data to create a ContentBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentBlock we want to update
     *   }
     * })
     */
    upsert<T extends ContentBlockUpsertArgs>(args: SelectSubset<T, ContentBlockUpsertArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockCountArgs} args - Arguments to filter ContentBlocks to count.
     * @example
     * // Count the number of ContentBlocks
     * const count = await prisma.contentBlock.count({
     *   where: {
     *     // ... the filter for the ContentBlocks we want to count
     *   }
     * })
    **/
    count<T extends ContentBlockCountArgs>(
      args?: Subset<T, ContentBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentBlockAggregateArgs>(args: Subset<T, ContentBlockAggregateArgs>): Prisma.PrismaPromise<GetContentBlockAggregateType<T>>

    /**
     * Group by ContentBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentBlockGroupByArgs['orderBy'] }
        : { orderBy?: ContentBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentBlock model
   */
  readonly fields: ContentBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blog<T extends BlogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogDefaultArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentBlock model
   */
  interface ContentBlockFieldRefs {
    readonly id: FieldRef<"ContentBlock", 'String'>
    readonly type: FieldRef<"ContentBlock", 'String'>
    readonly content: FieldRef<"ContentBlock", 'String'>
    readonly order: FieldRef<"ContentBlock", 'Int'>
    readonly blogId: FieldRef<"ContentBlock", 'String'>
    readonly createdAt: FieldRef<"ContentBlock", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentBlock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentBlock findUnique
   */
  export type ContentBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which ContentBlock to fetch.
     */
    where: ContentBlockWhereUniqueInput
  }

  /**
   * ContentBlock findUniqueOrThrow
   */
  export type ContentBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which ContentBlock to fetch.
     */
    where: ContentBlockWhereUniqueInput
  }

  /**
   * ContentBlock findFirst
   */
  export type ContentBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which ContentBlock to fetch.
     */
    where?: ContentBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentBlocks to fetch.
     */
    orderBy?: ContentBlockOrderByWithRelationInput | ContentBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentBlocks.
     */
    cursor?: ContentBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentBlocks.
     */
    distinct?: ContentBlockScalarFieldEnum | ContentBlockScalarFieldEnum[]
  }

  /**
   * ContentBlock findFirstOrThrow
   */
  export type ContentBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which ContentBlock to fetch.
     */
    where?: ContentBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentBlocks to fetch.
     */
    orderBy?: ContentBlockOrderByWithRelationInput | ContentBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentBlocks.
     */
    cursor?: ContentBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentBlocks.
     */
    distinct?: ContentBlockScalarFieldEnum | ContentBlockScalarFieldEnum[]
  }

  /**
   * ContentBlock findMany
   */
  export type ContentBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which ContentBlocks to fetch.
     */
    where?: ContentBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentBlocks to fetch.
     */
    orderBy?: ContentBlockOrderByWithRelationInput | ContentBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentBlocks.
     */
    cursor?: ContentBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentBlocks.
     */
    skip?: number
    distinct?: ContentBlockScalarFieldEnum | ContentBlockScalarFieldEnum[]
  }

  /**
   * ContentBlock create
   */
  export type ContentBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentBlock.
     */
    data: XOR<ContentBlockCreateInput, ContentBlockUncheckedCreateInput>
  }

  /**
   * ContentBlock createMany
   */
  export type ContentBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentBlocks.
     */
    data: ContentBlockCreateManyInput | ContentBlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentBlock createManyAndReturn
   */
  export type ContentBlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * The data used to create many ContentBlocks.
     */
    data: ContentBlockCreateManyInput | ContentBlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentBlock update
   */
  export type ContentBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentBlock.
     */
    data: XOR<ContentBlockUpdateInput, ContentBlockUncheckedUpdateInput>
    /**
     * Choose, which ContentBlock to update.
     */
    where: ContentBlockWhereUniqueInput
  }

  /**
   * ContentBlock updateMany
   */
  export type ContentBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentBlocks.
     */
    data: XOR<ContentBlockUpdateManyMutationInput, ContentBlockUncheckedUpdateManyInput>
    /**
     * Filter which ContentBlocks to update
     */
    where?: ContentBlockWhereInput
    /**
     * Limit how many ContentBlocks to update.
     */
    limit?: number
  }

  /**
   * ContentBlock updateManyAndReturn
   */
  export type ContentBlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * The data used to update ContentBlocks.
     */
    data: XOR<ContentBlockUpdateManyMutationInput, ContentBlockUncheckedUpdateManyInput>
    /**
     * Filter which ContentBlocks to update
     */
    where?: ContentBlockWhereInput
    /**
     * Limit how many ContentBlocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentBlock upsert
   */
  export type ContentBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentBlock to update in case it exists.
     */
    where: ContentBlockWhereUniqueInput
    /**
     * In case the ContentBlock found by the `where` argument doesn't exist, create a new ContentBlock with this data.
     */
    create: XOR<ContentBlockCreateInput, ContentBlockUncheckedCreateInput>
    /**
     * In case the ContentBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentBlockUpdateInput, ContentBlockUncheckedUpdateInput>
  }

  /**
   * ContentBlock delete
   */
  export type ContentBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * Filter which ContentBlock to delete.
     */
    where: ContentBlockWhereUniqueInput
  }

  /**
   * ContentBlock deleteMany
   */
  export type ContentBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentBlocks to delete
     */
    where?: ContentBlockWhereInput
    /**
     * Limit how many ContentBlocks to delete.
     */
    limit?: number
  }

  /**
   * ContentBlock without action
   */
  export type ContentBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    details: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    details: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    details?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    details?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entityType: string
    entityId: string
    details: string
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "details" | "createdAt", ExtArgs["result"]["auditLog"]>

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entityType: string
      entityId: string
      details: string
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccommodationRatingScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    review: 'review',
    userId: 'userId',
    accommodationId: 'accommodationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccommodationRatingScalarFieldEnum = (typeof AccommodationRatingScalarFieldEnum)[keyof typeof AccommodationRatingScalarFieldEnum]


  export const CareerOutcomeScalarFieldEnum: {
    id: 'id',
    iconName: 'iconName',
    iconImage: 'iconImage',
    title: 'title',
    value: 'value',
    description: 'description',
    details: 'details',
    color: 'color',
    bgColor: 'bgColor',
    universityId: 'universityId'
  };

  export type CareerOutcomeScalarFieldEnum = (typeof CareerOutcomeScalarFieldEnum)[keyof typeof CareerOutcomeScalarFieldEnum]


  export const FaqScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    universityId: 'universityId'
  };

  export type FaqScalarFieldEnum = (typeof FaqScalarFieldEnum)[keyof typeof FaqScalarFieldEnum]


  export const UniversityScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    description: 'description',
    location: 'location',
    country: 'country',
    website: 'website',
    established: 'established',
    banner: 'banner',
    logoUrl: 'logoUrl',
    youtubeLink: 'youtubeLink',
    imageUrls: 'imageUrls',
    facilities: 'facilities',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UniversityScalarFieldEnum = (typeof UniversityScalarFieldEnum)[keyof typeof UniversityScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    fees: 'fees',
    duration: 'duration',
    degreeType: 'degreeType',
    ieltsScore: 'ieltsScore',
    ranking: 'ranking',
    intake: 'intake',
    websiteLink: 'websiteLink',
    universityId: 'universityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const UniversityApplicationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    universityId: 'universityId',
    courseId: 'courseId',
    status: 'status',
    appliedAt: 'appliedAt',
    loanRequired: 'loanRequired',
    documents: 'documents',
    additionalNotes: 'additionalNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UniversityApplicationsScalarFieldEnum = (typeof UniversityApplicationsScalarFieldEnum)[keyof typeof UniversityApplicationsScalarFieldEnum]


  export const AccommodationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    address: 'address',
    city: 'city',
    country: 'country',
    banner: 'banner',
    includeBills: 'includeBills',
    deposit: 'deposit',
    furnishing: 'furnishing',
    bathrooms: 'bathrooms',
    bedrooms: 'bedrooms',
    size: 'size',
    amenities: 'amenities',
    rules: 'rules',
    images: 'images',
    availableFrom: 'availableFrom',
    minTerm: 'minTerm',
    maxTerm: 'maxTerm',
    isAvailable: 'isAvailable',
    landlordId: 'landlordId',
    averageRating: 'averageRating',
    totalRatings: 'totalRatings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccommodationScalarFieldEnum = (typeof AccommodationScalarFieldEnum)[keyof typeof AccommodationScalarFieldEnum]


  export const PricingPlanScalarFieldEnum: {
    id: 'id',
    accommodationId: 'accommodationId',
    type: 'type',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PricingPlanScalarFieldEnum = (typeof PricingPlanScalarFieldEnum)[keyof typeof PricingPlanScalarFieldEnum]


  export const AccommodationApplicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accommodationId: 'accommodationId',
    interestedFrom: 'interestedFrom',
    interestedTill: 'interestedTill',
    numberOfOccupants: 'numberOfOccupants',
    additionalNotes: 'additionalNotes',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type AccommodationApplicationScalarFieldEnum = (typeof AccommodationApplicationScalarFieldEnum)[keyof typeof AccommodationApplicationScalarFieldEnum]


  export const AccommodationReviewScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    review: 'review',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    accommodationId: 'accommodationId',
    userId: 'userId'
  };

  export type AccommodationReviewScalarFieldEnum = (typeof AccommodationReviewScalarFieldEnum)[keyof typeof AccommodationReviewScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    attachments: 'attachments',
    isRead: 'isRead',
    senderId: 'senderId',
    receiverId: 'receiverId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followingId: 'followingId',
    createdAt: 'createdAt'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const LoanScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    amount: 'amount',
    interestRate: 'interestRate',
    duration: 'duration',
    eligibilityCriteria: 'eligibilityCriteria',
    documents: 'documents',
    deadline: 'deadline',
    maxApplications: 'maxApplications',
    isActive: 'isActive',
    universityId: 'universityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoanScalarFieldEnum = (typeof LoanScalarFieldEnum)[keyof typeof LoanScalarFieldEnum]


  export const LoanApplicationScalarFieldEnum: {
    id: 'id',
    status: 'status',
    documents: 'documents',
    academicInfo: 'academicInfo',
    financialInfo: 'financialInfo',
    notes: 'notes',
    loanId: 'loanId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoanApplicationScalarFieldEnum = (typeof LoanApplicationScalarFieldEnum)[keyof typeof LoanApplicationScalarFieldEnum]


  export const VoteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    articleId: 'articleId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoteScalarFieldEnum = (typeof VoteScalarFieldEnum)[keyof typeof VoteScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    banner: 'banner',
    logo: 'logo',
    description: 'description',
    privacy: 'privacy',
    followersCount: 'followersCount',
    postsCount: 'postsCount',
    createdById: 'createdById',
    isPinned: 'isPinned',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const GroupMemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type GroupMemberScalarFieldEnum = (typeof GroupMemberScalarFieldEnum)[keyof typeof GroupMemberScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    image: 'image',
    location: 'location',
    eventType: 'eventType',
    registrationType: 'registrationType',
    totalSlots: 'totalSlots',
    registeredSlots: 'registeredSlots',
    waitlistSlots: 'waitlistSlots',
    ticketPrice: 'ticketPrice',
    currency: 'currency',
    address: 'address',
    virtualLink: 'virtualLink',
    contactById: 'contactById',
    groupId: 'groupId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventRegistrationScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    status: 'status',
    additionalInfo: 'additionalInfo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventRegistrationScalarFieldEnum = (typeof EventRegistrationScalarFieldEnum)[keyof typeof EventRegistrationScalarFieldEnum]


  export const ForumScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    groupId: 'groupId',
    type: 'type',
    privacy: 'privacy',
    attachments: 'attachments',
    creatorId: 'creatorId',
    viewCount: 'viewCount',
    topicCount: 'topicCount',
    replyCount: 'replyCount',
    lastReplyAt: 'lastReplyAt',
    isLocked: 'isLocked',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumScalarFieldEnum = (typeof ForumScalarFieldEnum)[keyof typeof ForumScalarFieldEnum]


  export const ForumTopicScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    forumId: 'forumId',
    creatorId: 'creatorId',
    type: 'type',
    isPinned: 'isPinned',
    isClosed: 'isClosed',
    viewCount: 'viewCount',
    replyCount: 'replyCount',
    lastReplyAt: 'lastReplyAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumTopicScalarFieldEnum = (typeof ForumTopicScalarFieldEnum)[keyof typeof ForumTopicScalarFieldEnum]


  export const ForumReplyScalarFieldEnum: {
    id: 'id',
    forumId: 'forumId',
    topicId: 'topicId',
    userId: 'userId',
    content: 'content',
    attachments: 'attachments',
    likes: 'likes',
    parentReplyId: 'parentReplyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumReplyScalarFieldEnum = (typeof ForumReplyScalarFieldEnum)[keyof typeof ForumReplyScalarFieldEnum]


  export const ForumPostScalarFieldEnum: {
    id: 'id',
    content: 'content',
    topicId: 'topicId',
    creatorId: 'creatorId',
    likes: 'likes',
    parentPostId: 'parentPostId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumPostScalarFieldEnum = (typeof ForumPostScalarFieldEnum)[keyof typeof ForumPostScalarFieldEnum]


  export const ForumReplyReactionScalarFieldEnum: {
    id: 'id',
    forumReplyId: 'forumReplyId',
    userId: 'userId',
    type: 'type'
  };

  export type ForumReplyReactionScalarFieldEnum = (typeof ForumReplyReactionScalarFieldEnum)[keyof typeof ForumReplyReactionScalarFieldEnum]


  export const ForumPostReactionScalarFieldEnum: {
    id: 'id',
    forumPostId: 'forumPostId',
    userId: 'userId',
    type: 'type'
  };

  export type ForumPostReactionScalarFieldEnum = (typeof ForumPostReactionScalarFieldEnum)[keyof typeof ForumPostReactionScalarFieldEnum]


  export const ArticleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    bannerImg: 'bannerImg',
    images: 'images',
    tags: 'tags',
    type: 'type',
    status: 'status',
    creatorId: 'creatorId',
    groupId: 'groupId',
    upVotes: 'upVotes',
    downVotes: 'downVotes',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionToken: 'sessionToken',
    refreshToken: 'refreshToken',
    expires: 'expires',
    lastActivity: 'lastActivity',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const FavCourseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    universityId: 'universityId',
    universityName: 'universityName',
    courseName: 'courseName',
    courseId: 'courseId',
    createdAt: 'createdAt'
  };

  export type FavCourseScalarFieldEnum = (typeof FavCourseScalarFieldEnum)[keyof typeof FavCourseScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    countryCode: 'countryCode',
    phoneNumber: 'phoneNumber',
    name: 'name',
    header: 'header',
    bio: 'bio',
    avatarUrl: 'avatarUrl',
    banner: 'banner',
    role: 'role',
    emailVerified: 'emailVerified',
    image: 'image',
    googleId: 'googleId',
    googleAccessToken: 'googleAccessToken',
    googleRefreshToken: 'googleRefreshToken',
    googleTokenExpiry: 'googleTokenExpiry',
    resetPasswordToken: 'resetPasswordToken',
    resetPasswordExpiry: 'resetPasswordExpiry',
    lastPasswordChangeAt: 'lastPasswordChangeAt',
    isVerified: 'isVerified',
    isPhoneVerified: 'isPhoneVerified',
    isEmailVerified: 'isEmailVerified',
    otpRetryCount: 'otpRetryCount',
    otpLastSentAt: 'otpLastSentAt',
    otpBlockedUntil: 'otpBlockedUntil',
    followersCount: 'followersCount',
    followingCount: 'followingCount',
    universityId: 'universityId',
    department: 'department',
    program: 'program',
    graduationYear: 'graduationYear',
    lastLoginAt: 'lastLoginAt',
    loginAttempts: 'loginAttempts',
    isLocked: 'isLocked',
    lockUntil: 'lockUntil',
    isLandlordVerified: 'isLandlordVerified',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const QuizAnswerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    questionId: 'questionId',
    answer: 'answer'
  };

  export type QuizAnswerScalarFieldEnum = (typeof QuizAnswerScalarFieldEnum)[keyof typeof QuizAnswerScalarFieldEnum]


  export const LikedAccommodationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accommodationId: 'accommodationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LikedAccommodationsScalarFieldEnum = (typeof LikedAccommodationsScalarFieldEnum)[keyof typeof LikedAccommodationsScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    type: 'type',
    userId: 'userId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const OTPScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    otpCode: 'otpCode',
    type: 'type',
    purpose: 'purpose',
    verified: 'verified',
    attempts: 'attempts',
    expiresAt: 'expiresAt',
    verifiedAt: 'verifiedAt',
    invalidated: 'invalidated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OTPScalarFieldEnum = (typeof OTPScalarFieldEnum)[keyof typeof OTPScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const BlogScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    summary: 'summary',
    coverImage: 'coverImage',
    published: 'published',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogScalarFieldEnum = (typeof BlogScalarFieldEnum)[keyof typeof BlogScalarFieldEnum]


  export const ContentBlockScalarFieldEnum: {
    id: 'id',
    type: 'type',
    content: 'content',
    order: 'order',
    blogId: 'blogId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentBlockScalarFieldEnum = (typeof ContentBlockScalarFieldEnum)[keyof typeof ContentBlockScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AccommodationType'
   */
  export type EnumAccommodationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccommodationType'>
    


  /**
   * Reference to a field of type 'AccommodationType[]'
   */
  export type ListEnumAccommodationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccommodationType[]'>
    


  /**
   * Reference to a field of type 'FurnishingType'
   */
  export type EnumFurnishingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FurnishingType'>
    


  /**
   * Reference to a field of type 'FurnishingType[]'
   */
  export type ListEnumFurnishingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FurnishingType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'VoteType'
   */
  export type EnumVoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteType'>
    


  /**
   * Reference to a field of type 'VoteType[]'
   */
  export type ListEnumVoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteType[]'>
    


  /**
   * Reference to a field of type 'GroupPrivacy'
   */
  export type EnumGroupPrivacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupPrivacy'>
    


  /**
   * Reference to a field of type 'GroupPrivacy[]'
   */
  export type ListEnumGroupPrivacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupPrivacy[]'>
    


  /**
   * Reference to a field of type 'GroupMemberRole'
   */
  export type EnumGroupMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupMemberRole'>
    


  /**
   * Reference to a field of type 'GroupMemberRole[]'
   */
  export type ListEnumGroupMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupMemberRole[]'>
    


  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


  /**
   * Reference to a field of type 'EventType[]'
   */
  export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


  /**
   * Reference to a field of type 'RegistrationType'
   */
  export type EnumRegistrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RegistrationType'>
    


  /**
   * Reference to a field of type 'RegistrationType[]'
   */
  export type ListEnumRegistrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RegistrationType[]'>
    


  /**
   * Reference to a field of type 'EventStatus'
   */
  export type EnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventStatus'>
    


  /**
   * Reference to a field of type 'EventStatus[]'
   */
  export type ListEnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventStatus[]'>
    


  /**
   * Reference to a field of type 'EventRegistrationStatus'
   */
  export type EnumEventRegistrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRegistrationStatus'>
    


  /**
   * Reference to a field of type 'EventRegistrationStatus[]'
   */
  export type ListEnumEventRegistrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventRegistrationStatus[]'>
    


  /**
   * Reference to a field of type 'ForumType'
   */
  export type EnumForumTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ForumType'>
    


  /**
   * Reference to a field of type 'ForumType[]'
   */
  export type ListEnumForumTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ForumType[]'>
    


  /**
   * Reference to a field of type 'ForumPrivacy'
   */
  export type EnumForumPrivacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ForumPrivacy'>
    


  /**
   * Reference to a field of type 'ForumPrivacy[]'
   */
  export type ListEnumForumPrivacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ForumPrivacy[]'>
    


  /**
   * Reference to a field of type 'TopicType'
   */
  export type EnumTopicTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TopicType'>
    


  /**
   * Reference to a field of type 'TopicType[]'
   */
  export type ListEnumTopicTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TopicType[]'>
    


  /**
   * Reference to a field of type 'TopicStatus'
   */
  export type EnumTopicStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TopicStatus'>
    


  /**
   * Reference to a field of type 'TopicStatus[]'
   */
  export type ListEnumTopicStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TopicStatus[]'>
    


  /**
   * Reference to a field of type 'ReactionType'
   */
  export type EnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType'>
    


  /**
   * Reference to a field of type 'ReactionType[]'
   */
  export type ListEnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType[]'>
    


  /**
   * Reference to a field of type 'ArticleType'
   */
  export type EnumArticleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArticleType'>
    


  /**
   * Reference to a field of type 'ArticleType[]'
   */
  export type ListEnumArticleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArticleType[]'>
    


  /**
   * Reference to a field of type 'ArticleStatus'
   */
  export type EnumArticleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArticleStatus'>
    


  /**
   * Reference to a field of type 'ArticleStatus[]'
   */
  export type ListEnumArticleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArticleStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'TokenType'
   */
  export type EnumTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenType'>
    


  /**
   * Reference to a field of type 'TokenType[]'
   */
  export type ListEnumTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenType[]'>
    


  /**
   * Reference to a field of type 'OTPType'
   */
  export type EnumOTPTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OTPType'>
    


  /**
   * Reference to a field of type 'OTPType[]'
   */
  export type ListEnumOTPTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OTPType[]'>
    


  /**
   * Reference to a field of type 'OTPPurpose'
   */
  export type EnumOTPPurposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OTPPurpose'>
    


  /**
   * Reference to a field of type 'OTPPurpose[]'
   */
  export type ListEnumOTPPurposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OTPPurpose[]'>
    
  /**
   * Deep Input Types
   */


  export type AccommodationRatingWhereInput = {
    AND?: AccommodationRatingWhereInput | AccommodationRatingWhereInput[]
    OR?: AccommodationRatingWhereInput[]
    NOT?: AccommodationRatingWhereInput | AccommodationRatingWhereInput[]
    id?: StringFilter<"AccommodationRating"> | string
    rating?: FloatFilter<"AccommodationRating"> | number
    review?: StringNullableFilter<"AccommodationRating"> | string | null
    userId?: StringFilter<"AccommodationRating"> | string
    accommodationId?: StringFilter<"AccommodationRating"> | string
    createdAt?: DateTimeFilter<"AccommodationRating"> | Date | string
    updatedAt?: DateTimeFilter<"AccommodationRating"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    accommodation?: XOR<AccommodationScalarRelationFilter, AccommodationWhereInput>
  }

  export type AccommodationRatingOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    accommodation?: AccommodationOrderByWithRelationInput
  }

  export type AccommodationRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_accommodationId?: AccommodationRatingUserIdAccommodationIdCompoundUniqueInput
    AND?: AccommodationRatingWhereInput | AccommodationRatingWhereInput[]
    OR?: AccommodationRatingWhereInput[]
    NOT?: AccommodationRatingWhereInput | AccommodationRatingWhereInput[]
    rating?: FloatFilter<"AccommodationRating"> | number
    review?: StringNullableFilter<"AccommodationRating"> | string | null
    userId?: StringFilter<"AccommodationRating"> | string
    accommodationId?: StringFilter<"AccommodationRating"> | string
    createdAt?: DateTimeFilter<"AccommodationRating"> | Date | string
    updatedAt?: DateTimeFilter<"AccommodationRating"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    accommodation?: XOR<AccommodationScalarRelationFilter, AccommodationWhereInput>
  }, "id" | "userId_accommodationId">

  export type AccommodationRatingOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccommodationRatingCountOrderByAggregateInput
    _avg?: AccommodationRatingAvgOrderByAggregateInput
    _max?: AccommodationRatingMaxOrderByAggregateInput
    _min?: AccommodationRatingMinOrderByAggregateInput
    _sum?: AccommodationRatingSumOrderByAggregateInput
  }

  export type AccommodationRatingScalarWhereWithAggregatesInput = {
    AND?: AccommodationRatingScalarWhereWithAggregatesInput | AccommodationRatingScalarWhereWithAggregatesInput[]
    OR?: AccommodationRatingScalarWhereWithAggregatesInput[]
    NOT?: AccommodationRatingScalarWhereWithAggregatesInput | AccommodationRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccommodationRating"> | string
    rating?: FloatWithAggregatesFilter<"AccommodationRating"> | number
    review?: StringNullableWithAggregatesFilter<"AccommodationRating"> | string | null
    userId?: StringWithAggregatesFilter<"AccommodationRating"> | string
    accommodationId?: StringWithAggregatesFilter<"AccommodationRating"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AccommodationRating"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AccommodationRating"> | Date | string
  }

  export type CareerOutcomeWhereInput = {
    AND?: CareerOutcomeWhereInput | CareerOutcomeWhereInput[]
    OR?: CareerOutcomeWhereInput[]
    NOT?: CareerOutcomeWhereInput | CareerOutcomeWhereInput[]
    id?: StringFilter<"CareerOutcome"> | string
    iconName?: StringFilter<"CareerOutcome"> | string
    iconImage?: StringFilter<"CareerOutcome"> | string
    title?: StringFilter<"CareerOutcome"> | string
    value?: StringFilter<"CareerOutcome"> | string
    description?: StringFilter<"CareerOutcome"> | string
    details?: StringFilter<"CareerOutcome"> | string
    color?: StringFilter<"CareerOutcome"> | string
    bgColor?: StringFilter<"CareerOutcome"> | string
    universityId?: StringFilter<"CareerOutcome"> | string
    university?: XOR<UniversityScalarRelationFilter, UniversityWhereInput>
  }

  export type CareerOutcomeOrderByWithRelationInput = {
    id?: SortOrder
    iconName?: SortOrder
    iconImage?: SortOrder
    title?: SortOrder
    value?: SortOrder
    description?: SortOrder
    details?: SortOrder
    color?: SortOrder
    bgColor?: SortOrder
    universityId?: SortOrder
    university?: UniversityOrderByWithRelationInput
  }

  export type CareerOutcomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CareerOutcomeWhereInput | CareerOutcomeWhereInput[]
    OR?: CareerOutcomeWhereInput[]
    NOT?: CareerOutcomeWhereInput | CareerOutcomeWhereInput[]
    iconName?: StringFilter<"CareerOutcome"> | string
    iconImage?: StringFilter<"CareerOutcome"> | string
    title?: StringFilter<"CareerOutcome"> | string
    value?: StringFilter<"CareerOutcome"> | string
    description?: StringFilter<"CareerOutcome"> | string
    details?: StringFilter<"CareerOutcome"> | string
    color?: StringFilter<"CareerOutcome"> | string
    bgColor?: StringFilter<"CareerOutcome"> | string
    universityId?: StringFilter<"CareerOutcome"> | string
    university?: XOR<UniversityScalarRelationFilter, UniversityWhereInput>
  }, "id">

  export type CareerOutcomeOrderByWithAggregationInput = {
    id?: SortOrder
    iconName?: SortOrder
    iconImage?: SortOrder
    title?: SortOrder
    value?: SortOrder
    description?: SortOrder
    details?: SortOrder
    color?: SortOrder
    bgColor?: SortOrder
    universityId?: SortOrder
    _count?: CareerOutcomeCountOrderByAggregateInput
    _max?: CareerOutcomeMaxOrderByAggregateInput
    _min?: CareerOutcomeMinOrderByAggregateInput
  }

  export type CareerOutcomeScalarWhereWithAggregatesInput = {
    AND?: CareerOutcomeScalarWhereWithAggregatesInput | CareerOutcomeScalarWhereWithAggregatesInput[]
    OR?: CareerOutcomeScalarWhereWithAggregatesInput[]
    NOT?: CareerOutcomeScalarWhereWithAggregatesInput | CareerOutcomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CareerOutcome"> | string
    iconName?: StringWithAggregatesFilter<"CareerOutcome"> | string
    iconImage?: StringWithAggregatesFilter<"CareerOutcome"> | string
    title?: StringWithAggregatesFilter<"CareerOutcome"> | string
    value?: StringWithAggregatesFilter<"CareerOutcome"> | string
    description?: StringWithAggregatesFilter<"CareerOutcome"> | string
    details?: StringWithAggregatesFilter<"CareerOutcome"> | string
    color?: StringWithAggregatesFilter<"CareerOutcome"> | string
    bgColor?: StringWithAggregatesFilter<"CareerOutcome"> | string
    universityId?: StringWithAggregatesFilter<"CareerOutcome"> | string
  }

  export type FaqWhereInput = {
    AND?: FaqWhereInput | FaqWhereInput[]
    OR?: FaqWhereInput[]
    NOT?: FaqWhereInput | FaqWhereInput[]
    id?: StringFilter<"Faq"> | string
    question?: StringFilter<"Faq"> | string
    answer?: StringFilter<"Faq"> | string
    universityId?: StringFilter<"Faq"> | string
    university?: XOR<UniversityScalarRelationFilter, UniversityWhereInput>
  }

  export type FaqOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    universityId?: SortOrder
    university?: UniversityOrderByWithRelationInput
  }

  export type FaqWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FaqWhereInput | FaqWhereInput[]
    OR?: FaqWhereInput[]
    NOT?: FaqWhereInput | FaqWhereInput[]
    question?: StringFilter<"Faq"> | string
    answer?: StringFilter<"Faq"> | string
    universityId?: StringFilter<"Faq"> | string
    university?: XOR<UniversityScalarRelationFilter, UniversityWhereInput>
  }, "id">

  export type FaqOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    universityId?: SortOrder
    _count?: FaqCountOrderByAggregateInput
    _max?: FaqMaxOrderByAggregateInput
    _min?: FaqMinOrderByAggregateInput
  }

  export type FaqScalarWhereWithAggregatesInput = {
    AND?: FaqScalarWhereWithAggregatesInput | FaqScalarWhereWithAggregatesInput[]
    OR?: FaqScalarWhereWithAggregatesInput[]
    NOT?: FaqScalarWhereWithAggregatesInput | FaqScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Faq"> | string
    question?: StringWithAggregatesFilter<"Faq"> | string
    answer?: StringWithAggregatesFilter<"Faq"> | string
    universityId?: StringWithAggregatesFilter<"Faq"> | string
  }

  export type UniversityWhereInput = {
    AND?: UniversityWhereInput | UniversityWhereInput[]
    OR?: UniversityWhereInput[]
    NOT?: UniversityWhereInput | UniversityWhereInput[]
    id?: StringFilter<"University"> | string
    slug?: StringNullableFilter<"University"> | string | null
    name?: StringFilter<"University"> | string
    description?: StringFilter<"University"> | string
    location?: StringFilter<"University"> | string
    country?: StringFilter<"University"> | string
    website?: StringFilter<"University"> | string
    established?: DateTimeFilter<"University"> | Date | string
    banner?: StringFilter<"University"> | string
    logoUrl?: StringNullableFilter<"University"> | string | null
    youtubeLink?: StringNullableFilter<"University"> | string | null
    imageUrls?: StringNullableListFilter<"University">
    facilities?: StringNullableListFilter<"University">
    createdAt?: DateTimeFilter<"University"> | Date | string
    updatedAt?: DateTimeFilter<"University"> | Date | string
    careerOutcomes?: CareerOutcomeListRelationFilter
    faqs?: FaqListRelationFilter
    applications?: UniversityApplicationsListRelationFilter
    loans?: LoanListRelationFilter
    users?: UserListRelationFilter
    courses?: CourseListRelationFilter
  }

  export type UniversityOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    country?: SortOrder
    website?: SortOrder
    established?: SortOrder
    banner?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    youtubeLink?: SortOrderInput | SortOrder
    imageUrls?: SortOrder
    facilities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    careerOutcomes?: CareerOutcomeOrderByRelationAggregateInput
    faqs?: FaqOrderByRelationAggregateInput
    applications?: UniversityApplicationsOrderByRelationAggregateInput
    loans?: LoanOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
  }

  export type UniversityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: UniversityWhereInput | UniversityWhereInput[]
    OR?: UniversityWhereInput[]
    NOT?: UniversityWhereInput | UniversityWhereInput[]
    name?: StringFilter<"University"> | string
    description?: StringFilter<"University"> | string
    location?: StringFilter<"University"> | string
    country?: StringFilter<"University"> | string
    website?: StringFilter<"University"> | string
    established?: DateTimeFilter<"University"> | Date | string
    banner?: StringFilter<"University"> | string
    logoUrl?: StringNullableFilter<"University"> | string | null
    youtubeLink?: StringNullableFilter<"University"> | string | null
    imageUrls?: StringNullableListFilter<"University">
    facilities?: StringNullableListFilter<"University">
    createdAt?: DateTimeFilter<"University"> | Date | string
    updatedAt?: DateTimeFilter<"University"> | Date | string
    careerOutcomes?: CareerOutcomeListRelationFilter
    faqs?: FaqListRelationFilter
    applications?: UniversityApplicationsListRelationFilter
    loans?: LoanListRelationFilter
    users?: UserListRelationFilter
    courses?: CourseListRelationFilter
  }, "id" | "slug">

  export type UniversityOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    country?: SortOrder
    website?: SortOrder
    established?: SortOrder
    banner?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    youtubeLink?: SortOrderInput | SortOrder
    imageUrls?: SortOrder
    facilities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UniversityCountOrderByAggregateInput
    _max?: UniversityMaxOrderByAggregateInput
    _min?: UniversityMinOrderByAggregateInput
  }

  export type UniversityScalarWhereWithAggregatesInput = {
    AND?: UniversityScalarWhereWithAggregatesInput | UniversityScalarWhereWithAggregatesInput[]
    OR?: UniversityScalarWhereWithAggregatesInput[]
    NOT?: UniversityScalarWhereWithAggregatesInput | UniversityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"University"> | string
    slug?: StringNullableWithAggregatesFilter<"University"> | string | null
    name?: StringWithAggregatesFilter<"University"> | string
    description?: StringWithAggregatesFilter<"University"> | string
    location?: StringWithAggregatesFilter<"University"> | string
    country?: StringWithAggregatesFilter<"University"> | string
    website?: StringWithAggregatesFilter<"University"> | string
    established?: DateTimeWithAggregatesFilter<"University"> | Date | string
    banner?: StringWithAggregatesFilter<"University"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"University"> | string | null
    youtubeLink?: StringNullableWithAggregatesFilter<"University"> | string | null
    imageUrls?: StringNullableListFilter<"University">
    facilities?: StringNullableListFilter<"University">
    createdAt?: DateTimeWithAggregatesFilter<"University"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"University"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    image?: StringNullableFilter<"Course"> | string | null
    fees?: StringNullableFilter<"Course"> | string | null
    duration?: StringNullableFilter<"Course"> | string | null
    degreeType?: StringNullableFilter<"Course"> | string | null
    ieltsScore?: StringNullableFilter<"Course"> | string | null
    ranking?: StringNullableFilter<"Course"> | string | null
    intake?: StringNullableListFilter<"Course">
    websiteLink?: StringNullableFilter<"Course"> | string | null
    universityId?: StringFilter<"Course"> | string
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    applications?: UniversityApplicationsListRelationFilter
    favByUsers?: FavCourseListRelationFilter
    university?: XOR<UniversityScalarRelationFilter, UniversityWhereInput>
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    fees?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    degreeType?: SortOrderInput | SortOrder
    ieltsScore?: SortOrderInput | SortOrder
    ranking?: SortOrderInput | SortOrder
    intake?: SortOrder
    websiteLink?: SortOrderInput | SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applications?: UniversityApplicationsOrderByRelationAggregateInput
    favByUsers?: FavCourseOrderByRelationAggregateInput
    university?: UniversityOrderByWithRelationInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    name?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    image?: StringNullableFilter<"Course"> | string | null
    fees?: StringNullableFilter<"Course"> | string | null
    duration?: StringNullableFilter<"Course"> | string | null
    degreeType?: StringNullableFilter<"Course"> | string | null
    ieltsScore?: StringNullableFilter<"Course"> | string | null
    ranking?: StringNullableFilter<"Course"> | string | null
    intake?: StringNullableListFilter<"Course">
    websiteLink?: StringNullableFilter<"Course"> | string | null
    universityId?: StringFilter<"Course"> | string
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    applications?: UniversityApplicationsListRelationFilter
    favByUsers?: FavCourseListRelationFilter
    university?: XOR<UniversityScalarRelationFilter, UniversityWhereInput>
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    fees?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    degreeType?: SortOrderInput | SortOrder
    ieltsScore?: SortOrderInput | SortOrder
    ranking?: SortOrderInput | SortOrder
    intake?: SortOrder
    websiteLink?: SortOrderInput | SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    name?: StringWithAggregatesFilter<"Course"> | string
    description?: StringNullableWithAggregatesFilter<"Course"> | string | null
    image?: StringNullableWithAggregatesFilter<"Course"> | string | null
    fees?: StringNullableWithAggregatesFilter<"Course"> | string | null
    duration?: StringNullableWithAggregatesFilter<"Course"> | string | null
    degreeType?: StringNullableWithAggregatesFilter<"Course"> | string | null
    ieltsScore?: StringNullableWithAggregatesFilter<"Course"> | string | null
    ranking?: StringNullableWithAggregatesFilter<"Course"> | string | null
    intake?: StringNullableListFilter<"Course">
    websiteLink?: StringNullableWithAggregatesFilter<"Course"> | string | null
    universityId?: StringWithAggregatesFilter<"Course"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type UniversityApplicationsWhereInput = {
    AND?: UniversityApplicationsWhereInput | UniversityApplicationsWhereInput[]
    OR?: UniversityApplicationsWhereInput[]
    NOT?: UniversityApplicationsWhereInput | UniversityApplicationsWhereInput[]
    id?: StringFilter<"UniversityApplications"> | string
    userId?: StringFilter<"UniversityApplications"> | string
    universityId?: StringFilter<"UniversityApplications"> | string
    courseId?: StringFilter<"UniversityApplications"> | string
    status?: EnumApplicationStatusFilter<"UniversityApplications"> | $Enums.ApplicationStatus
    appliedAt?: DateTimeFilter<"UniversityApplications"> | Date | string
    loanRequired?: BoolFilter<"UniversityApplications"> | boolean
    documents?: StringNullableListFilter<"UniversityApplications">
    additionalNotes?: StringNullableFilter<"UniversityApplications"> | string | null
    createdAt?: DateTimeFilter<"UniversityApplications"> | Date | string
    updatedAt?: DateTimeFilter<"UniversityApplications"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    university?: XOR<UniversityScalarRelationFilter, UniversityWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type UniversityApplicationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    universityId?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    loanRequired?: SortOrder
    documents?: SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    university?: UniversityOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type UniversityApplicationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UniversityApplicationsWhereInput | UniversityApplicationsWhereInput[]
    OR?: UniversityApplicationsWhereInput[]
    NOT?: UniversityApplicationsWhereInput | UniversityApplicationsWhereInput[]
    userId?: StringFilter<"UniversityApplications"> | string
    universityId?: StringFilter<"UniversityApplications"> | string
    courseId?: StringFilter<"UniversityApplications"> | string
    status?: EnumApplicationStatusFilter<"UniversityApplications"> | $Enums.ApplicationStatus
    appliedAt?: DateTimeFilter<"UniversityApplications"> | Date | string
    loanRequired?: BoolFilter<"UniversityApplications"> | boolean
    documents?: StringNullableListFilter<"UniversityApplications">
    additionalNotes?: StringNullableFilter<"UniversityApplications"> | string | null
    createdAt?: DateTimeFilter<"UniversityApplications"> | Date | string
    updatedAt?: DateTimeFilter<"UniversityApplications"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    university?: XOR<UniversityScalarRelationFilter, UniversityWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id">

  export type UniversityApplicationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    universityId?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    loanRequired?: SortOrder
    documents?: SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UniversityApplicationsCountOrderByAggregateInput
    _max?: UniversityApplicationsMaxOrderByAggregateInput
    _min?: UniversityApplicationsMinOrderByAggregateInput
  }

  export type UniversityApplicationsScalarWhereWithAggregatesInput = {
    AND?: UniversityApplicationsScalarWhereWithAggregatesInput | UniversityApplicationsScalarWhereWithAggregatesInput[]
    OR?: UniversityApplicationsScalarWhereWithAggregatesInput[]
    NOT?: UniversityApplicationsScalarWhereWithAggregatesInput | UniversityApplicationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UniversityApplications"> | string
    userId?: StringWithAggregatesFilter<"UniversityApplications"> | string
    universityId?: StringWithAggregatesFilter<"UniversityApplications"> | string
    courseId?: StringWithAggregatesFilter<"UniversityApplications"> | string
    status?: EnumApplicationStatusWithAggregatesFilter<"UniversityApplications"> | $Enums.ApplicationStatus
    appliedAt?: DateTimeWithAggregatesFilter<"UniversityApplications"> | Date | string
    loanRequired?: BoolWithAggregatesFilter<"UniversityApplications"> | boolean
    documents?: StringNullableListFilter<"UniversityApplications">
    additionalNotes?: StringNullableWithAggregatesFilter<"UniversityApplications"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UniversityApplications"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UniversityApplications"> | Date | string
  }

  export type AccommodationWhereInput = {
    AND?: AccommodationWhereInput | AccommodationWhereInput[]
    OR?: AccommodationWhereInput[]
    NOT?: AccommodationWhereInput | AccommodationWhereInput[]
    id?: StringFilter<"Accommodation"> | string
    title?: StringFilter<"Accommodation"> | string
    description?: StringFilter<"Accommodation"> | string
    type?: EnumAccommodationTypeFilter<"Accommodation"> | $Enums.AccommodationType
    address?: StringFilter<"Accommodation"> | string
    city?: StringFilter<"Accommodation"> | string
    country?: StringFilter<"Accommodation"> | string
    banner?: StringFilter<"Accommodation"> | string
    includeBills?: BoolNullableFilter<"Accommodation"> | boolean | null
    deposit?: FloatNullableFilter<"Accommodation"> | number | null
    furnishing?: EnumFurnishingTypeNullableFilter<"Accommodation"> | $Enums.FurnishingType | null
    bathrooms?: IntFilter<"Accommodation"> | number
    bedrooms?: IntFilter<"Accommodation"> | number
    size?: FloatNullableFilter<"Accommodation"> | number | null
    amenities?: StringNullableListFilter<"Accommodation">
    rules?: StringNullableListFilter<"Accommodation">
    images?: StringNullableListFilter<"Accommodation">
    availableFrom?: DateTimeFilter<"Accommodation"> | Date | string
    minTerm?: IntFilter<"Accommodation"> | number
    maxTerm?: IntNullableFilter<"Accommodation"> | number | null
    isAvailable?: BoolFilter<"Accommodation"> | boolean
    landlordId?: StringFilter<"Accommodation"> | string
    averageRating?: FloatNullableFilter<"Accommodation"> | number | null
    totalRatings?: IntFilter<"Accommodation"> | number
    createdAt?: DateTimeFilter<"Accommodation"> | Date | string
    updatedAt?: DateTimeFilter<"Accommodation"> | Date | string
    landlord?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviews?: AccommodationReviewListRelationFilter
    ratings?: AccommodationRatingListRelationFilter
    likedBy?: LikedAccommodationsListRelationFilter
    pricingPlans?: PricingPlanListRelationFilter
  }

  export type AccommodationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    banner?: SortOrder
    includeBills?: SortOrderInput | SortOrder
    deposit?: SortOrderInput | SortOrder
    furnishing?: SortOrderInput | SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    size?: SortOrderInput | SortOrder
    amenities?: SortOrder
    rules?: SortOrder
    images?: SortOrder
    availableFrom?: SortOrder
    minTerm?: SortOrder
    maxTerm?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    landlordId?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    totalRatings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    landlord?: UserOrderByWithRelationInput
    reviews?: AccommodationReviewOrderByRelationAggregateInput
    ratings?: AccommodationRatingOrderByRelationAggregateInput
    likedBy?: LikedAccommodationsOrderByRelationAggregateInput
    pricingPlans?: PricingPlanOrderByRelationAggregateInput
  }

  export type AccommodationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccommodationWhereInput | AccommodationWhereInput[]
    OR?: AccommodationWhereInput[]
    NOT?: AccommodationWhereInput | AccommodationWhereInput[]
    title?: StringFilter<"Accommodation"> | string
    description?: StringFilter<"Accommodation"> | string
    type?: EnumAccommodationTypeFilter<"Accommodation"> | $Enums.AccommodationType
    address?: StringFilter<"Accommodation"> | string
    city?: StringFilter<"Accommodation"> | string
    country?: StringFilter<"Accommodation"> | string
    banner?: StringFilter<"Accommodation"> | string
    includeBills?: BoolNullableFilter<"Accommodation"> | boolean | null
    deposit?: FloatNullableFilter<"Accommodation"> | number | null
    furnishing?: EnumFurnishingTypeNullableFilter<"Accommodation"> | $Enums.FurnishingType | null
    bathrooms?: IntFilter<"Accommodation"> | number
    bedrooms?: IntFilter<"Accommodation"> | number
    size?: FloatNullableFilter<"Accommodation"> | number | null
    amenities?: StringNullableListFilter<"Accommodation">
    rules?: StringNullableListFilter<"Accommodation">
    images?: StringNullableListFilter<"Accommodation">
    availableFrom?: DateTimeFilter<"Accommodation"> | Date | string
    minTerm?: IntFilter<"Accommodation"> | number
    maxTerm?: IntNullableFilter<"Accommodation"> | number | null
    isAvailable?: BoolFilter<"Accommodation"> | boolean
    landlordId?: StringFilter<"Accommodation"> | string
    averageRating?: FloatNullableFilter<"Accommodation"> | number | null
    totalRatings?: IntFilter<"Accommodation"> | number
    createdAt?: DateTimeFilter<"Accommodation"> | Date | string
    updatedAt?: DateTimeFilter<"Accommodation"> | Date | string
    landlord?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviews?: AccommodationReviewListRelationFilter
    ratings?: AccommodationRatingListRelationFilter
    likedBy?: LikedAccommodationsListRelationFilter
    pricingPlans?: PricingPlanListRelationFilter
  }, "id">

  export type AccommodationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    banner?: SortOrder
    includeBills?: SortOrderInput | SortOrder
    deposit?: SortOrderInput | SortOrder
    furnishing?: SortOrderInput | SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    size?: SortOrderInput | SortOrder
    amenities?: SortOrder
    rules?: SortOrder
    images?: SortOrder
    availableFrom?: SortOrder
    minTerm?: SortOrder
    maxTerm?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    landlordId?: SortOrder
    averageRating?: SortOrderInput | SortOrder
    totalRatings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccommodationCountOrderByAggregateInput
    _avg?: AccommodationAvgOrderByAggregateInput
    _max?: AccommodationMaxOrderByAggregateInput
    _min?: AccommodationMinOrderByAggregateInput
    _sum?: AccommodationSumOrderByAggregateInput
  }

  export type AccommodationScalarWhereWithAggregatesInput = {
    AND?: AccommodationScalarWhereWithAggregatesInput | AccommodationScalarWhereWithAggregatesInput[]
    OR?: AccommodationScalarWhereWithAggregatesInput[]
    NOT?: AccommodationScalarWhereWithAggregatesInput | AccommodationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Accommodation"> | string
    title?: StringWithAggregatesFilter<"Accommodation"> | string
    description?: StringWithAggregatesFilter<"Accommodation"> | string
    type?: EnumAccommodationTypeWithAggregatesFilter<"Accommodation"> | $Enums.AccommodationType
    address?: StringWithAggregatesFilter<"Accommodation"> | string
    city?: StringWithAggregatesFilter<"Accommodation"> | string
    country?: StringWithAggregatesFilter<"Accommodation"> | string
    banner?: StringWithAggregatesFilter<"Accommodation"> | string
    includeBills?: BoolNullableWithAggregatesFilter<"Accommodation"> | boolean | null
    deposit?: FloatNullableWithAggregatesFilter<"Accommodation"> | number | null
    furnishing?: EnumFurnishingTypeNullableWithAggregatesFilter<"Accommodation"> | $Enums.FurnishingType | null
    bathrooms?: IntWithAggregatesFilter<"Accommodation"> | number
    bedrooms?: IntWithAggregatesFilter<"Accommodation"> | number
    size?: FloatNullableWithAggregatesFilter<"Accommodation"> | number | null
    amenities?: StringNullableListFilter<"Accommodation">
    rules?: StringNullableListFilter<"Accommodation">
    images?: StringNullableListFilter<"Accommodation">
    availableFrom?: DateTimeWithAggregatesFilter<"Accommodation"> | Date | string
    minTerm?: IntWithAggregatesFilter<"Accommodation"> | number
    maxTerm?: IntNullableWithAggregatesFilter<"Accommodation"> | number | null
    isAvailable?: BoolWithAggregatesFilter<"Accommodation"> | boolean
    landlordId?: StringWithAggregatesFilter<"Accommodation"> | string
    averageRating?: FloatNullableWithAggregatesFilter<"Accommodation"> | number | null
    totalRatings?: IntWithAggregatesFilter<"Accommodation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Accommodation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Accommodation"> | Date | string
  }

  export type PricingPlanWhereInput = {
    AND?: PricingPlanWhereInput | PricingPlanWhereInput[]
    OR?: PricingPlanWhereInput[]
    NOT?: PricingPlanWhereInput | PricingPlanWhereInput[]
    id?: StringFilter<"PricingPlan"> | string
    accommodationId?: StringFilter<"PricingPlan"> | string
    type?: StringFilter<"PricingPlan"> | string
    price?: FloatFilter<"PricingPlan"> | number
    createdAt?: DateTimeFilter<"PricingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"PricingPlan"> | Date | string
    accommodation?: XOR<AccommodationScalarRelationFilter, AccommodationWhereInput>
  }

  export type PricingPlanOrderByWithRelationInput = {
    id?: SortOrder
    accommodationId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accommodation?: AccommodationOrderByWithRelationInput
  }

  export type PricingPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PricingPlanWhereInput | PricingPlanWhereInput[]
    OR?: PricingPlanWhereInput[]
    NOT?: PricingPlanWhereInput | PricingPlanWhereInput[]
    accommodationId?: StringFilter<"PricingPlan"> | string
    type?: StringFilter<"PricingPlan"> | string
    price?: FloatFilter<"PricingPlan"> | number
    createdAt?: DateTimeFilter<"PricingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"PricingPlan"> | Date | string
    accommodation?: XOR<AccommodationScalarRelationFilter, AccommodationWhereInput>
  }, "id">

  export type PricingPlanOrderByWithAggregationInput = {
    id?: SortOrder
    accommodationId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PricingPlanCountOrderByAggregateInput
    _avg?: PricingPlanAvgOrderByAggregateInput
    _max?: PricingPlanMaxOrderByAggregateInput
    _min?: PricingPlanMinOrderByAggregateInput
    _sum?: PricingPlanSumOrderByAggregateInput
  }

  export type PricingPlanScalarWhereWithAggregatesInput = {
    AND?: PricingPlanScalarWhereWithAggregatesInput | PricingPlanScalarWhereWithAggregatesInput[]
    OR?: PricingPlanScalarWhereWithAggregatesInput[]
    NOT?: PricingPlanScalarWhereWithAggregatesInput | PricingPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PricingPlan"> | string
    accommodationId?: StringWithAggregatesFilter<"PricingPlan"> | string
    type?: StringWithAggregatesFilter<"PricingPlan"> | string
    price?: FloatWithAggregatesFilter<"PricingPlan"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PricingPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PricingPlan"> | Date | string
  }

  export type AccommodationApplicationWhereInput = {
    AND?: AccommodationApplicationWhereInput | AccommodationApplicationWhereInput[]
    OR?: AccommodationApplicationWhereInput[]
    NOT?: AccommodationApplicationWhereInput | AccommodationApplicationWhereInput[]
    id?: StringFilter<"AccommodationApplication"> | string
    userId?: StringFilter<"AccommodationApplication"> | string
    accommodationId?: StringFilter<"AccommodationApplication"> | string
    interestedFrom?: DateTimeFilter<"AccommodationApplication"> | Date | string
    interestedTill?: DateTimeFilter<"AccommodationApplication"> | Date | string
    numberOfOccupants?: IntFilter<"AccommodationApplication"> | number
    additionalNotes?: StringNullableFilter<"AccommodationApplication"> | string | null
    status?: EnumApplicationStatusFilter<"AccommodationApplication"> | $Enums.ApplicationStatus
    createdAt?: DateTimeFilter<"AccommodationApplication"> | Date | string
  }

  export type AccommodationApplicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    interestedFrom?: SortOrder
    interestedTill?: SortOrder
    numberOfOccupants?: SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AccommodationApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccommodationApplicationWhereInput | AccommodationApplicationWhereInput[]
    OR?: AccommodationApplicationWhereInput[]
    NOT?: AccommodationApplicationWhereInput | AccommodationApplicationWhereInput[]
    userId?: StringFilter<"AccommodationApplication"> | string
    accommodationId?: StringFilter<"AccommodationApplication"> | string
    interestedFrom?: DateTimeFilter<"AccommodationApplication"> | Date | string
    interestedTill?: DateTimeFilter<"AccommodationApplication"> | Date | string
    numberOfOccupants?: IntFilter<"AccommodationApplication"> | number
    additionalNotes?: StringNullableFilter<"AccommodationApplication"> | string | null
    status?: EnumApplicationStatusFilter<"AccommodationApplication"> | $Enums.ApplicationStatus
    createdAt?: DateTimeFilter<"AccommodationApplication"> | Date | string
  }, "id">

  export type AccommodationApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    interestedFrom?: SortOrder
    interestedTill?: SortOrder
    numberOfOccupants?: SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: AccommodationApplicationCountOrderByAggregateInput
    _avg?: AccommodationApplicationAvgOrderByAggregateInput
    _max?: AccommodationApplicationMaxOrderByAggregateInput
    _min?: AccommodationApplicationMinOrderByAggregateInput
    _sum?: AccommodationApplicationSumOrderByAggregateInput
  }

  export type AccommodationApplicationScalarWhereWithAggregatesInput = {
    AND?: AccommodationApplicationScalarWhereWithAggregatesInput | AccommodationApplicationScalarWhereWithAggregatesInput[]
    OR?: AccommodationApplicationScalarWhereWithAggregatesInput[]
    NOT?: AccommodationApplicationScalarWhereWithAggregatesInput | AccommodationApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccommodationApplication"> | string
    userId?: StringWithAggregatesFilter<"AccommodationApplication"> | string
    accommodationId?: StringWithAggregatesFilter<"AccommodationApplication"> | string
    interestedFrom?: DateTimeWithAggregatesFilter<"AccommodationApplication"> | Date | string
    interestedTill?: DateTimeWithAggregatesFilter<"AccommodationApplication"> | Date | string
    numberOfOccupants?: IntWithAggregatesFilter<"AccommodationApplication"> | number
    additionalNotes?: StringNullableWithAggregatesFilter<"AccommodationApplication"> | string | null
    status?: EnumApplicationStatusWithAggregatesFilter<"AccommodationApplication"> | $Enums.ApplicationStatus
    createdAt?: DateTimeWithAggregatesFilter<"AccommodationApplication"> | Date | string
  }

  export type AccommodationReviewWhereInput = {
    AND?: AccommodationReviewWhereInput | AccommodationReviewWhereInput[]
    OR?: AccommodationReviewWhereInput[]
    NOT?: AccommodationReviewWhereInput | AccommodationReviewWhereInput[]
    id?: StringFilter<"AccommodationReview"> | string
    rating?: FloatFilter<"AccommodationReview"> | number
    review?: StringFilter<"AccommodationReview"> | string
    createdAt?: DateTimeFilter<"AccommodationReview"> | Date | string
    updatedAt?: DateTimeFilter<"AccommodationReview"> | Date | string
    accommodationId?: StringFilter<"AccommodationReview"> | string
    userId?: StringFilter<"AccommodationReview"> | string
    accommodation?: XOR<AccommodationScalarRelationFilter, AccommodationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccommodationReviewOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accommodationId?: SortOrder
    userId?: SortOrder
    accommodation?: AccommodationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AccommodationReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccommodationReviewWhereInput | AccommodationReviewWhereInput[]
    OR?: AccommodationReviewWhereInput[]
    NOT?: AccommodationReviewWhereInput | AccommodationReviewWhereInput[]
    rating?: FloatFilter<"AccommodationReview"> | number
    review?: StringFilter<"AccommodationReview"> | string
    createdAt?: DateTimeFilter<"AccommodationReview"> | Date | string
    updatedAt?: DateTimeFilter<"AccommodationReview"> | Date | string
    accommodationId?: StringFilter<"AccommodationReview"> | string
    userId?: StringFilter<"AccommodationReview"> | string
    accommodation?: XOR<AccommodationScalarRelationFilter, AccommodationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccommodationReviewOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accommodationId?: SortOrder
    userId?: SortOrder
    _count?: AccommodationReviewCountOrderByAggregateInput
    _avg?: AccommodationReviewAvgOrderByAggregateInput
    _max?: AccommodationReviewMaxOrderByAggregateInput
    _min?: AccommodationReviewMinOrderByAggregateInput
    _sum?: AccommodationReviewSumOrderByAggregateInput
  }

  export type AccommodationReviewScalarWhereWithAggregatesInput = {
    AND?: AccommodationReviewScalarWhereWithAggregatesInput | AccommodationReviewScalarWhereWithAggregatesInput[]
    OR?: AccommodationReviewScalarWhereWithAggregatesInput[]
    NOT?: AccommodationReviewScalarWhereWithAggregatesInput | AccommodationReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccommodationReview"> | string
    rating?: FloatWithAggregatesFilter<"AccommodationReview"> | number
    review?: StringWithAggregatesFilter<"AccommodationReview"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AccommodationReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AccommodationReview"> | Date | string
    accommodationId?: StringWithAggregatesFilter<"AccommodationReview"> | string
    userId?: StringWithAggregatesFilter<"AccommodationReview"> | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    attachments?: StringNullableListFilter<"Message">
    isRead?: BoolFilter<"Message"> | boolean
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringFilter<"Message"> | string
    attachments?: StringNullableListFilter<"Message">
    isRead?: BoolFilter<"Message"> | boolean
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    attachments?: StringNullableListFilter<"Message">
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    senderId?: StringWithAggregatesFilter<"Message"> | string
    receiverId?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerId_followingId?: FollowFollowerIdFollowingIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "followerId_followingId">

  export type FollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Follow"> | string
    followerId?: StringWithAggregatesFilter<"Follow"> | string
    followingId?: StringWithAggregatesFilter<"Follow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
  }

  export type LoanWhereInput = {
    AND?: LoanWhereInput | LoanWhereInput[]
    OR?: LoanWhereInput[]
    NOT?: LoanWhereInput | LoanWhereInput[]
    id?: StringFilter<"Loan"> | string
    title?: StringFilter<"Loan"> | string
    description?: StringFilter<"Loan"> | string
    amount?: FloatFilter<"Loan"> | number
    interestRate?: FloatFilter<"Loan"> | number
    duration?: IntFilter<"Loan"> | number
    eligibilityCriteria?: StringNullableListFilter<"Loan">
    documents?: StringNullableListFilter<"Loan">
    deadline?: DateTimeNullableFilter<"Loan"> | Date | string | null
    maxApplications?: IntNullableFilter<"Loan"> | number | null
    isActive?: BoolFilter<"Loan"> | boolean
    universityId?: StringNullableFilter<"Loan"> | string | null
    createdAt?: DateTimeFilter<"Loan"> | Date | string
    updatedAt?: DateTimeFilter<"Loan"> | Date | string
    university?: XOR<UniversityNullableScalarRelationFilter, UniversityWhereInput> | null
    applications?: LoanApplicationListRelationFilter
  }

  export type LoanOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    interestRate?: SortOrder
    duration?: SortOrder
    eligibilityCriteria?: SortOrder
    documents?: SortOrder
    deadline?: SortOrderInput | SortOrder
    maxApplications?: SortOrderInput | SortOrder
    isActive?: SortOrder
    universityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    university?: UniversityOrderByWithRelationInput
    applications?: LoanApplicationOrderByRelationAggregateInput
  }

  export type LoanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoanWhereInput | LoanWhereInput[]
    OR?: LoanWhereInput[]
    NOT?: LoanWhereInput | LoanWhereInput[]
    title?: StringFilter<"Loan"> | string
    description?: StringFilter<"Loan"> | string
    amount?: FloatFilter<"Loan"> | number
    interestRate?: FloatFilter<"Loan"> | number
    duration?: IntFilter<"Loan"> | number
    eligibilityCriteria?: StringNullableListFilter<"Loan">
    documents?: StringNullableListFilter<"Loan">
    deadline?: DateTimeNullableFilter<"Loan"> | Date | string | null
    maxApplications?: IntNullableFilter<"Loan"> | number | null
    isActive?: BoolFilter<"Loan"> | boolean
    universityId?: StringNullableFilter<"Loan"> | string | null
    createdAt?: DateTimeFilter<"Loan"> | Date | string
    updatedAt?: DateTimeFilter<"Loan"> | Date | string
    university?: XOR<UniversityNullableScalarRelationFilter, UniversityWhereInput> | null
    applications?: LoanApplicationListRelationFilter
  }, "id">

  export type LoanOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    interestRate?: SortOrder
    duration?: SortOrder
    eligibilityCriteria?: SortOrder
    documents?: SortOrder
    deadline?: SortOrderInput | SortOrder
    maxApplications?: SortOrderInput | SortOrder
    isActive?: SortOrder
    universityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoanCountOrderByAggregateInput
    _avg?: LoanAvgOrderByAggregateInput
    _max?: LoanMaxOrderByAggregateInput
    _min?: LoanMinOrderByAggregateInput
    _sum?: LoanSumOrderByAggregateInput
  }

  export type LoanScalarWhereWithAggregatesInput = {
    AND?: LoanScalarWhereWithAggregatesInput | LoanScalarWhereWithAggregatesInput[]
    OR?: LoanScalarWhereWithAggregatesInput[]
    NOT?: LoanScalarWhereWithAggregatesInput | LoanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Loan"> | string
    title?: StringWithAggregatesFilter<"Loan"> | string
    description?: StringWithAggregatesFilter<"Loan"> | string
    amount?: FloatWithAggregatesFilter<"Loan"> | number
    interestRate?: FloatWithAggregatesFilter<"Loan"> | number
    duration?: IntWithAggregatesFilter<"Loan"> | number
    eligibilityCriteria?: StringNullableListFilter<"Loan">
    documents?: StringNullableListFilter<"Loan">
    deadline?: DateTimeNullableWithAggregatesFilter<"Loan"> | Date | string | null
    maxApplications?: IntNullableWithAggregatesFilter<"Loan"> | number | null
    isActive?: BoolWithAggregatesFilter<"Loan"> | boolean
    universityId?: StringNullableWithAggregatesFilter<"Loan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Loan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Loan"> | Date | string
  }

  export type LoanApplicationWhereInput = {
    AND?: LoanApplicationWhereInput | LoanApplicationWhereInput[]
    OR?: LoanApplicationWhereInput[]
    NOT?: LoanApplicationWhereInput | LoanApplicationWhereInput[]
    id?: StringFilter<"LoanApplication"> | string
    status?: EnumApplicationStatusFilter<"LoanApplication"> | $Enums.ApplicationStatus
    documents?: StringNullableListFilter<"LoanApplication">
    academicInfo?: JsonFilter<"LoanApplication">
    financialInfo?: JsonFilter<"LoanApplication">
    notes?: StringNullableFilter<"LoanApplication"> | string | null
    loanId?: StringFilter<"LoanApplication"> | string
    userId?: StringFilter<"LoanApplication"> | string
    createdAt?: DateTimeFilter<"LoanApplication"> | Date | string
    updatedAt?: DateTimeFilter<"LoanApplication"> | Date | string
    loan?: XOR<LoanScalarRelationFilter, LoanWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LoanApplicationOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    documents?: SortOrder
    academicInfo?: SortOrder
    financialInfo?: SortOrder
    notes?: SortOrderInput | SortOrder
    loanId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loan?: LoanOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LoanApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoanApplicationWhereInput | LoanApplicationWhereInput[]
    OR?: LoanApplicationWhereInput[]
    NOT?: LoanApplicationWhereInput | LoanApplicationWhereInput[]
    status?: EnumApplicationStatusFilter<"LoanApplication"> | $Enums.ApplicationStatus
    documents?: StringNullableListFilter<"LoanApplication">
    academicInfo?: JsonFilter<"LoanApplication">
    financialInfo?: JsonFilter<"LoanApplication">
    notes?: StringNullableFilter<"LoanApplication"> | string | null
    loanId?: StringFilter<"LoanApplication"> | string
    userId?: StringFilter<"LoanApplication"> | string
    createdAt?: DateTimeFilter<"LoanApplication"> | Date | string
    updatedAt?: DateTimeFilter<"LoanApplication"> | Date | string
    loan?: XOR<LoanScalarRelationFilter, LoanWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LoanApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    documents?: SortOrder
    academicInfo?: SortOrder
    financialInfo?: SortOrder
    notes?: SortOrderInput | SortOrder
    loanId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoanApplicationCountOrderByAggregateInput
    _max?: LoanApplicationMaxOrderByAggregateInput
    _min?: LoanApplicationMinOrderByAggregateInput
  }

  export type LoanApplicationScalarWhereWithAggregatesInput = {
    AND?: LoanApplicationScalarWhereWithAggregatesInput | LoanApplicationScalarWhereWithAggregatesInput[]
    OR?: LoanApplicationScalarWhereWithAggregatesInput[]
    NOT?: LoanApplicationScalarWhereWithAggregatesInput | LoanApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoanApplication"> | string
    status?: EnumApplicationStatusWithAggregatesFilter<"LoanApplication"> | $Enums.ApplicationStatus
    documents?: StringNullableListFilter<"LoanApplication">
    academicInfo?: JsonWithAggregatesFilter<"LoanApplication">
    financialInfo?: JsonWithAggregatesFilter<"LoanApplication">
    notes?: StringNullableWithAggregatesFilter<"LoanApplication"> | string | null
    loanId?: StringWithAggregatesFilter<"LoanApplication"> | string
    userId?: StringWithAggregatesFilter<"LoanApplication"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LoanApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoanApplication"> | Date | string
  }

  export type VoteWhereInput = {
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    id?: StringFilter<"Vote"> | string
    userId?: StringFilter<"Vote"> | string
    articleId?: StringFilter<"Vote"> | string
    status?: EnumVoteTypeFilter<"Vote"> | $Enums.VoteType
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    updatedAt?: DateTimeFilter<"Vote"> | Date | string
    article?: XOR<ArticleScalarRelationFilter, ArticleWhereInput>
  }

  export type VoteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: ArticleOrderByWithRelationInput
  }

  export type VoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_articleId?: VoteUserIdArticleIdCompoundUniqueInput
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    userId?: StringFilter<"Vote"> | string
    articleId?: StringFilter<"Vote"> | string
    status?: EnumVoteTypeFilter<"Vote"> | $Enums.VoteType
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    updatedAt?: DateTimeFilter<"Vote"> | Date | string
    article?: XOR<ArticleScalarRelationFilter, ArticleWhereInput>
  }, "id" | "userId_articleId">

  export type VoteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VoteCountOrderByAggregateInput
    _max?: VoteMaxOrderByAggregateInput
    _min?: VoteMinOrderByAggregateInput
  }

  export type VoteScalarWhereWithAggregatesInput = {
    AND?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    OR?: VoteScalarWhereWithAggregatesInput[]
    NOT?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vote"> | string
    userId?: StringWithAggregatesFilter<"Vote"> | string
    articleId?: StringWithAggregatesFilter<"Vote"> | string
    status?: EnumVoteTypeWithAggregatesFilter<"Vote"> | $Enums.VoteType
    createdAt?: DateTimeWithAggregatesFilter<"Vote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vote"> | Date | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    slug?: StringFilter<"Group"> | string
    banner?: StringNullableFilter<"Group"> | string | null
    logo?: StringNullableFilter<"Group"> | string | null
    description?: StringFilter<"Group"> | string
    privacy?: EnumGroupPrivacyFilter<"Group"> | $Enums.GroupPrivacy
    followersCount?: IntFilter<"Group"> | number
    postsCount?: IntFilter<"Group"> | number
    createdById?: StringFilter<"Group"> | string
    isPinned?: BoolFilter<"Group"> | boolean
    isActive?: BoolFilter<"Group"> | boolean
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    events?: EventListRelationFilter
    articles?: ArticleListRelationFilter
    forums?: ForumListRelationFilter
    members?: GroupMemberListRelationFilter
    moderators?: UserListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    banner?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrder
    privacy?: SortOrder
    followersCount?: SortOrder
    postsCount?: SortOrder
    createdById?: SortOrder
    isPinned?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    events?: EventOrderByRelationAggregateInput
    articles?: ArticleOrderByRelationAggregateInput
    forums?: ForumOrderByRelationAggregateInput
    members?: GroupMemberOrderByRelationAggregateInput
    moderators?: UserOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    banner?: StringNullableFilter<"Group"> | string | null
    logo?: StringNullableFilter<"Group"> | string | null
    description?: StringFilter<"Group"> | string
    privacy?: EnumGroupPrivacyFilter<"Group"> | $Enums.GroupPrivacy
    followersCount?: IntFilter<"Group"> | number
    postsCount?: IntFilter<"Group"> | number
    createdById?: StringFilter<"Group"> | string
    isPinned?: BoolFilter<"Group"> | boolean
    isActive?: BoolFilter<"Group"> | boolean
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    events?: EventListRelationFilter
    articles?: ArticleListRelationFilter
    forums?: ForumListRelationFilter
    members?: GroupMemberListRelationFilter
    moderators?: UserListRelationFilter
  }, "id" | "name" | "slug">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    banner?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrder
    privacy?: SortOrder
    followersCount?: SortOrder
    postsCount?: SortOrder
    createdById?: SortOrder
    isPinned?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    name?: StringWithAggregatesFilter<"Group"> | string
    slug?: StringWithAggregatesFilter<"Group"> | string
    banner?: StringNullableWithAggregatesFilter<"Group"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Group"> | string | null
    description?: StringWithAggregatesFilter<"Group"> | string
    privacy?: EnumGroupPrivacyWithAggregatesFilter<"Group"> | $Enums.GroupPrivacy
    followersCount?: IntWithAggregatesFilter<"Group"> | number
    postsCount?: IntWithAggregatesFilter<"Group"> | number
    createdById?: StringWithAggregatesFilter<"Group"> | string
    isPinned?: BoolWithAggregatesFilter<"Group"> | boolean
    isActive?: BoolWithAggregatesFilter<"Group"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type GroupMemberWhereInput = {
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    role?: EnumGroupMemberRoleFilter<"GroupMember"> | $Enums.GroupMemberRole
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    group?: GroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type GroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId?: GroupMemberGroupIdUserIdCompoundUniqueInput
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    role?: EnumGroupMemberRoleFilter<"GroupMember"> | $Enums.GroupMemberRole
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "groupId_userId">

  export type GroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: GroupMemberCountOrderByAggregateInput
    _max?: GroupMemberMaxOrderByAggregateInput
    _min?: GroupMemberMinOrderByAggregateInput
  }

  export type GroupMemberScalarWhereWithAggregatesInput = {
    AND?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    OR?: GroupMemberScalarWhereWithAggregatesInput[]
    NOT?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupMember"> | string
    groupId?: StringWithAggregatesFilter<"GroupMember"> | string
    userId?: StringWithAggregatesFilter<"GroupMember"> | string
    role?: EnumGroupMemberRoleWithAggregatesFilter<"GroupMember"> | $Enums.GroupMemberRole
    joinedAt?: DateTimeWithAggregatesFilter<"GroupMember"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    slug?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    date?: DateTimeFilter<"Event"> | Date | string
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeNullableFilter<"Event"> | Date | string | null
    image?: StringNullableFilter<"Event"> | string | null
    location?: StringFilter<"Event"> | string
    eventType?: EnumEventTypeFilter<"Event"> | $Enums.EventType
    registrationType?: EnumRegistrationTypeFilter<"Event"> | $Enums.RegistrationType
    totalSlots?: IntFilter<"Event"> | number
    registeredSlots?: IntFilter<"Event"> | number
    waitlistSlots?: IntNullableFilter<"Event"> | number | null
    ticketPrice?: FloatNullableFilter<"Event"> | number | null
    currency?: StringNullableFilter<"Event"> | string | null
    address?: StringNullableFilter<"Event"> | string | null
    virtualLink?: StringNullableFilter<"Event"> | string | null
    contactById?: StringFilter<"Event"> | string
    groupId?: StringFilter<"Event"> | string
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    contactBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    registrations?: EventRegistrationListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    location?: SortOrder
    eventType?: SortOrder
    registrationType?: SortOrder
    totalSlots?: SortOrder
    registeredSlots?: SortOrder
    waitlistSlots?: SortOrderInput | SortOrder
    ticketPrice?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    virtualLink?: SortOrderInput | SortOrder
    contactById?: SortOrder
    groupId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactBy?: UserOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
    registrations?: EventRegistrationOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    slug?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    date?: DateTimeFilter<"Event"> | Date | string
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeNullableFilter<"Event"> | Date | string | null
    image?: StringNullableFilter<"Event"> | string | null
    location?: StringFilter<"Event"> | string
    eventType?: EnumEventTypeFilter<"Event"> | $Enums.EventType
    registrationType?: EnumRegistrationTypeFilter<"Event"> | $Enums.RegistrationType
    totalSlots?: IntFilter<"Event"> | number
    registeredSlots?: IntFilter<"Event"> | number
    waitlistSlots?: IntNullableFilter<"Event"> | number | null
    ticketPrice?: FloatNullableFilter<"Event"> | number | null
    currency?: StringNullableFilter<"Event"> | string | null
    address?: StringNullableFilter<"Event"> | string | null
    virtualLink?: StringNullableFilter<"Event"> | string | null
    contactById?: StringFilter<"Event"> | string
    groupId?: StringFilter<"Event"> | string
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    contactBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    registrations?: EventRegistrationListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    location?: SortOrder
    eventType?: SortOrder
    registrationType?: SortOrder
    totalSlots?: SortOrder
    registeredSlots?: SortOrder
    waitlistSlots?: SortOrderInput | SortOrder
    ticketPrice?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    virtualLink?: SortOrderInput | SortOrder
    contactById?: SortOrder
    groupId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    slug?: StringWithAggregatesFilter<"Event"> | string
    description?: StringWithAggregatesFilter<"Event"> | string
    date?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"Event"> | string | null
    location?: StringWithAggregatesFilter<"Event"> | string
    eventType?: EnumEventTypeWithAggregatesFilter<"Event"> | $Enums.EventType
    registrationType?: EnumRegistrationTypeWithAggregatesFilter<"Event"> | $Enums.RegistrationType
    totalSlots?: IntWithAggregatesFilter<"Event"> | number
    registeredSlots?: IntWithAggregatesFilter<"Event"> | number
    waitlistSlots?: IntNullableWithAggregatesFilter<"Event"> | number | null
    ticketPrice?: FloatNullableWithAggregatesFilter<"Event"> | number | null
    currency?: StringNullableWithAggregatesFilter<"Event"> | string | null
    address?: StringNullableWithAggregatesFilter<"Event"> | string | null
    virtualLink?: StringNullableWithAggregatesFilter<"Event"> | string | null
    contactById?: StringWithAggregatesFilter<"Event"> | string
    groupId?: StringWithAggregatesFilter<"Event"> | string
    status?: EnumEventStatusWithAggregatesFilter<"Event"> | $Enums.EventStatus
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type EventRegistrationWhereInput = {
    AND?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    OR?: EventRegistrationWhereInput[]
    NOT?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    id?: StringFilter<"EventRegistration"> | string
    eventId?: StringFilter<"EventRegistration"> | string
    userId?: StringFilter<"EventRegistration"> | string
    status?: EnumEventRegistrationStatusFilter<"EventRegistration"> | $Enums.EventRegistrationStatus
    additionalInfo?: JsonNullableFilter<"EventRegistration">
    createdAt?: DateTimeFilter<"EventRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"EventRegistration"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }

  export type EventRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type EventRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_userId?: EventRegistrationEventIdUserIdCompoundUniqueInput
    AND?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    OR?: EventRegistrationWhereInput[]
    NOT?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    eventId?: StringFilter<"EventRegistration"> | string
    userId?: StringFilter<"EventRegistration"> | string
    status?: EnumEventRegistrationStatusFilter<"EventRegistration"> | $Enums.EventRegistrationStatus
    additionalInfo?: JsonNullableFilter<"EventRegistration">
    createdAt?: DateTimeFilter<"EventRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"EventRegistration"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }, "id" | "eventId_userId">

  export type EventRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventRegistrationCountOrderByAggregateInput
    _max?: EventRegistrationMaxOrderByAggregateInput
    _min?: EventRegistrationMinOrderByAggregateInput
  }

  export type EventRegistrationScalarWhereWithAggregatesInput = {
    AND?: EventRegistrationScalarWhereWithAggregatesInput | EventRegistrationScalarWhereWithAggregatesInput[]
    OR?: EventRegistrationScalarWhereWithAggregatesInput[]
    NOT?: EventRegistrationScalarWhereWithAggregatesInput | EventRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventRegistration"> | string
    eventId?: StringWithAggregatesFilter<"EventRegistration"> | string
    userId?: StringWithAggregatesFilter<"EventRegistration"> | string
    status?: EnumEventRegistrationStatusWithAggregatesFilter<"EventRegistration"> | $Enums.EventRegistrationStatus
    additionalInfo?: JsonNullableWithAggregatesFilter<"EventRegistration">
    createdAt?: DateTimeWithAggregatesFilter<"EventRegistration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EventRegistration"> | Date | string
  }

  export type ForumWhereInput = {
    AND?: ForumWhereInput | ForumWhereInput[]
    OR?: ForumWhereInput[]
    NOT?: ForumWhereInput | ForumWhereInput[]
    id?: StringFilter<"Forum"> | string
    title?: StringFilter<"Forum"> | string
    description?: StringNullableFilter<"Forum"> | string | null
    groupId?: StringFilter<"Forum"> | string
    type?: EnumForumTypeFilter<"Forum"> | $Enums.ForumType
    privacy?: EnumForumPrivacyFilter<"Forum"> | $Enums.ForumPrivacy
    attachments?: StringNullableListFilter<"Forum">
    creatorId?: StringFilter<"Forum"> | string
    viewCount?: IntFilter<"Forum"> | number
    topicCount?: IntFilter<"Forum"> | number
    replyCount?: IntFilter<"Forum"> | number
    lastReplyAt?: DateTimeNullableFilter<"Forum"> | Date | string | null
    isLocked?: BoolFilter<"Forum"> | boolean
    tags?: StringNullableListFilter<"Forum">
    createdAt?: DateTimeFilter<"Forum"> | Date | string
    updatedAt?: DateTimeFilter<"Forum"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    topics?: ForumTopicListRelationFilter
    forumReplies?: ForumReplyListRelationFilter
  }

  export type ForumOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    groupId?: SortOrder
    type?: SortOrder
    privacy?: SortOrder
    attachments?: SortOrder
    creatorId?: SortOrder
    viewCount?: SortOrder
    topicCount?: SortOrder
    replyCount?: SortOrder
    lastReplyAt?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    group?: GroupOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    topics?: ForumTopicOrderByRelationAggregateInput
    forumReplies?: ForumReplyOrderByRelationAggregateInput
  }

  export type ForumWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumWhereInput | ForumWhereInput[]
    OR?: ForumWhereInput[]
    NOT?: ForumWhereInput | ForumWhereInput[]
    title?: StringFilter<"Forum"> | string
    description?: StringNullableFilter<"Forum"> | string | null
    groupId?: StringFilter<"Forum"> | string
    type?: EnumForumTypeFilter<"Forum"> | $Enums.ForumType
    privacy?: EnumForumPrivacyFilter<"Forum"> | $Enums.ForumPrivacy
    attachments?: StringNullableListFilter<"Forum">
    creatorId?: StringFilter<"Forum"> | string
    viewCount?: IntFilter<"Forum"> | number
    topicCount?: IntFilter<"Forum"> | number
    replyCount?: IntFilter<"Forum"> | number
    lastReplyAt?: DateTimeNullableFilter<"Forum"> | Date | string | null
    isLocked?: BoolFilter<"Forum"> | boolean
    tags?: StringNullableListFilter<"Forum">
    createdAt?: DateTimeFilter<"Forum"> | Date | string
    updatedAt?: DateTimeFilter<"Forum"> | Date | string
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    topics?: ForumTopicListRelationFilter
    forumReplies?: ForumReplyListRelationFilter
  }, "id">

  export type ForumOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    groupId?: SortOrder
    type?: SortOrder
    privacy?: SortOrder
    attachments?: SortOrder
    creatorId?: SortOrder
    viewCount?: SortOrder
    topicCount?: SortOrder
    replyCount?: SortOrder
    lastReplyAt?: SortOrderInput | SortOrder
    isLocked?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumCountOrderByAggregateInput
    _avg?: ForumAvgOrderByAggregateInput
    _max?: ForumMaxOrderByAggregateInput
    _min?: ForumMinOrderByAggregateInput
    _sum?: ForumSumOrderByAggregateInput
  }

  export type ForumScalarWhereWithAggregatesInput = {
    AND?: ForumScalarWhereWithAggregatesInput | ForumScalarWhereWithAggregatesInput[]
    OR?: ForumScalarWhereWithAggregatesInput[]
    NOT?: ForumScalarWhereWithAggregatesInput | ForumScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Forum"> | string
    title?: StringWithAggregatesFilter<"Forum"> | string
    description?: StringNullableWithAggregatesFilter<"Forum"> | string | null
    groupId?: StringWithAggregatesFilter<"Forum"> | string
    type?: EnumForumTypeWithAggregatesFilter<"Forum"> | $Enums.ForumType
    privacy?: EnumForumPrivacyWithAggregatesFilter<"Forum"> | $Enums.ForumPrivacy
    attachments?: StringNullableListFilter<"Forum">
    creatorId?: StringWithAggregatesFilter<"Forum"> | string
    viewCount?: IntWithAggregatesFilter<"Forum"> | number
    topicCount?: IntWithAggregatesFilter<"Forum"> | number
    replyCount?: IntWithAggregatesFilter<"Forum"> | number
    lastReplyAt?: DateTimeNullableWithAggregatesFilter<"Forum"> | Date | string | null
    isLocked?: BoolWithAggregatesFilter<"Forum"> | boolean
    tags?: StringNullableListFilter<"Forum">
    createdAt?: DateTimeWithAggregatesFilter<"Forum"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Forum"> | Date | string
  }

  export type ForumTopicWhereInput = {
    AND?: ForumTopicWhereInput | ForumTopicWhereInput[]
    OR?: ForumTopicWhereInput[]
    NOT?: ForumTopicWhereInput | ForumTopicWhereInput[]
    id?: StringFilter<"ForumTopic"> | string
    title?: StringFilter<"ForumTopic"> | string
    content?: StringFilter<"ForumTopic"> | string
    forumId?: StringFilter<"ForumTopic"> | string
    creatorId?: StringFilter<"ForumTopic"> | string
    type?: EnumTopicTypeFilter<"ForumTopic"> | $Enums.TopicType
    isPinned?: BoolFilter<"ForumTopic"> | boolean
    isClosed?: BoolFilter<"ForumTopic"> | boolean
    viewCount?: IntFilter<"ForumTopic"> | number
    replyCount?: IntFilter<"ForumTopic"> | number
    lastReplyAt?: DateTimeNullableFilter<"ForumTopic"> | Date | string | null
    status?: EnumTopicStatusFilter<"ForumTopic"> | $Enums.TopicStatus
    createdAt?: DateTimeFilter<"ForumTopic"> | Date | string
    updatedAt?: DateTimeFilter<"ForumTopic"> | Date | string
    forum?: XOR<ForumScalarRelationFilter, ForumWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    posts?: ForumPostListRelationFilter
    replies?: ForumReplyListRelationFilter
  }

  export type ForumTopicOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    forumId?: SortOrder
    creatorId?: SortOrder
    type?: SortOrder
    isPinned?: SortOrder
    isClosed?: SortOrder
    viewCount?: SortOrder
    replyCount?: SortOrder
    lastReplyAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    forum?: ForumOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    posts?: ForumPostOrderByRelationAggregateInput
    replies?: ForumReplyOrderByRelationAggregateInput
  }

  export type ForumTopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumTopicWhereInput | ForumTopicWhereInput[]
    OR?: ForumTopicWhereInput[]
    NOT?: ForumTopicWhereInput | ForumTopicWhereInput[]
    title?: StringFilter<"ForumTopic"> | string
    content?: StringFilter<"ForumTopic"> | string
    forumId?: StringFilter<"ForumTopic"> | string
    creatorId?: StringFilter<"ForumTopic"> | string
    type?: EnumTopicTypeFilter<"ForumTopic"> | $Enums.TopicType
    isPinned?: BoolFilter<"ForumTopic"> | boolean
    isClosed?: BoolFilter<"ForumTopic"> | boolean
    viewCount?: IntFilter<"ForumTopic"> | number
    replyCount?: IntFilter<"ForumTopic"> | number
    lastReplyAt?: DateTimeNullableFilter<"ForumTopic"> | Date | string | null
    status?: EnumTopicStatusFilter<"ForumTopic"> | $Enums.TopicStatus
    createdAt?: DateTimeFilter<"ForumTopic"> | Date | string
    updatedAt?: DateTimeFilter<"ForumTopic"> | Date | string
    forum?: XOR<ForumScalarRelationFilter, ForumWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    posts?: ForumPostListRelationFilter
    replies?: ForumReplyListRelationFilter
  }, "id">

  export type ForumTopicOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    forumId?: SortOrder
    creatorId?: SortOrder
    type?: SortOrder
    isPinned?: SortOrder
    isClosed?: SortOrder
    viewCount?: SortOrder
    replyCount?: SortOrder
    lastReplyAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumTopicCountOrderByAggregateInput
    _avg?: ForumTopicAvgOrderByAggregateInput
    _max?: ForumTopicMaxOrderByAggregateInput
    _min?: ForumTopicMinOrderByAggregateInput
    _sum?: ForumTopicSumOrderByAggregateInput
  }

  export type ForumTopicScalarWhereWithAggregatesInput = {
    AND?: ForumTopicScalarWhereWithAggregatesInput | ForumTopicScalarWhereWithAggregatesInput[]
    OR?: ForumTopicScalarWhereWithAggregatesInput[]
    NOT?: ForumTopicScalarWhereWithAggregatesInput | ForumTopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumTopic"> | string
    title?: StringWithAggregatesFilter<"ForumTopic"> | string
    content?: StringWithAggregatesFilter<"ForumTopic"> | string
    forumId?: StringWithAggregatesFilter<"ForumTopic"> | string
    creatorId?: StringWithAggregatesFilter<"ForumTopic"> | string
    type?: EnumTopicTypeWithAggregatesFilter<"ForumTopic"> | $Enums.TopicType
    isPinned?: BoolWithAggregatesFilter<"ForumTopic"> | boolean
    isClosed?: BoolWithAggregatesFilter<"ForumTopic"> | boolean
    viewCount?: IntWithAggregatesFilter<"ForumTopic"> | number
    replyCount?: IntWithAggregatesFilter<"ForumTopic"> | number
    lastReplyAt?: DateTimeNullableWithAggregatesFilter<"ForumTopic"> | Date | string | null
    status?: EnumTopicStatusWithAggregatesFilter<"ForumTopic"> | $Enums.TopicStatus
    createdAt?: DateTimeWithAggregatesFilter<"ForumTopic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumTopic"> | Date | string
  }

  export type ForumReplyWhereInput = {
    AND?: ForumReplyWhereInput | ForumReplyWhereInput[]
    OR?: ForumReplyWhereInput[]
    NOT?: ForumReplyWhereInput | ForumReplyWhereInput[]
    id?: StringFilter<"ForumReply"> | string
    forumId?: StringFilter<"ForumReply"> | string
    topicId?: StringFilter<"ForumReply"> | string
    userId?: StringFilter<"ForumReply"> | string
    content?: StringFilter<"ForumReply"> | string
    attachments?: StringNullableListFilter<"ForumReply">
    likes?: IntFilter<"ForumReply"> | number
    parentReplyId?: StringNullableFilter<"ForumReply"> | string | null
    createdAt?: DateTimeFilter<"ForumReply"> | Date | string
    updatedAt?: DateTimeFilter<"ForumReply"> | Date | string
    forum?: XOR<ForumScalarRelationFilter, ForumWhereInput>
    topic?: XOR<ForumTopicScalarRelationFilter, ForumTopicWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reactions?: ForumReplyReactionListRelationFilter
    parentReply?: XOR<ForumReplyNullableScalarRelationFilter, ForumReplyWhereInput> | null
    childReplies?: ForumReplyListRelationFilter
  }

  export type ForumReplyOrderByWithRelationInput = {
    id?: SortOrder
    forumId?: SortOrder
    topicId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    likes?: SortOrder
    parentReplyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    forum?: ForumOrderByWithRelationInput
    topic?: ForumTopicOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    reactions?: ForumReplyReactionOrderByRelationAggregateInput
    parentReply?: ForumReplyOrderByWithRelationInput
    childReplies?: ForumReplyOrderByRelationAggregateInput
  }

  export type ForumReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumReplyWhereInput | ForumReplyWhereInput[]
    OR?: ForumReplyWhereInput[]
    NOT?: ForumReplyWhereInput | ForumReplyWhereInput[]
    forumId?: StringFilter<"ForumReply"> | string
    topicId?: StringFilter<"ForumReply"> | string
    userId?: StringFilter<"ForumReply"> | string
    content?: StringFilter<"ForumReply"> | string
    attachments?: StringNullableListFilter<"ForumReply">
    likes?: IntFilter<"ForumReply"> | number
    parentReplyId?: StringNullableFilter<"ForumReply"> | string | null
    createdAt?: DateTimeFilter<"ForumReply"> | Date | string
    updatedAt?: DateTimeFilter<"ForumReply"> | Date | string
    forum?: XOR<ForumScalarRelationFilter, ForumWhereInput>
    topic?: XOR<ForumTopicScalarRelationFilter, ForumTopicWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reactions?: ForumReplyReactionListRelationFilter
    parentReply?: XOR<ForumReplyNullableScalarRelationFilter, ForumReplyWhereInput> | null
    childReplies?: ForumReplyListRelationFilter
  }, "id">

  export type ForumReplyOrderByWithAggregationInput = {
    id?: SortOrder
    forumId?: SortOrder
    topicId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    likes?: SortOrder
    parentReplyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumReplyCountOrderByAggregateInput
    _avg?: ForumReplyAvgOrderByAggregateInput
    _max?: ForumReplyMaxOrderByAggregateInput
    _min?: ForumReplyMinOrderByAggregateInput
    _sum?: ForumReplySumOrderByAggregateInput
  }

  export type ForumReplyScalarWhereWithAggregatesInput = {
    AND?: ForumReplyScalarWhereWithAggregatesInput | ForumReplyScalarWhereWithAggregatesInput[]
    OR?: ForumReplyScalarWhereWithAggregatesInput[]
    NOT?: ForumReplyScalarWhereWithAggregatesInput | ForumReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumReply"> | string
    forumId?: StringWithAggregatesFilter<"ForumReply"> | string
    topicId?: StringWithAggregatesFilter<"ForumReply"> | string
    userId?: StringWithAggregatesFilter<"ForumReply"> | string
    content?: StringWithAggregatesFilter<"ForumReply"> | string
    attachments?: StringNullableListFilter<"ForumReply">
    likes?: IntWithAggregatesFilter<"ForumReply"> | number
    parentReplyId?: StringNullableWithAggregatesFilter<"ForumReply"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ForumReply"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumReply"> | Date | string
  }

  export type ForumPostWhereInput = {
    AND?: ForumPostWhereInput | ForumPostWhereInput[]
    OR?: ForumPostWhereInput[]
    NOT?: ForumPostWhereInput | ForumPostWhereInput[]
    id?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    topicId?: StringFilter<"ForumPost"> | string
    creatorId?: StringFilter<"ForumPost"> | string
    likes?: IntFilter<"ForumPost"> | number
    parentPostId?: StringNullableFilter<"ForumPost"> | string | null
    createdAt?: DateTimeFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPost"> | Date | string
    topic?: XOR<ForumTopicScalarRelationFilter, ForumTopicWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    reactions?: ForumPostReactionListRelationFilter
    parentPost?: XOR<ForumPostNullableScalarRelationFilter, ForumPostWhereInput> | null
    replies?: ForumPostListRelationFilter
  }

  export type ForumPostOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    topicId?: SortOrder
    creatorId?: SortOrder
    likes?: SortOrder
    parentPostId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    topic?: ForumTopicOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    reactions?: ForumPostReactionOrderByRelationAggregateInput
    parentPost?: ForumPostOrderByWithRelationInput
    replies?: ForumPostOrderByRelationAggregateInput
  }

  export type ForumPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumPostWhereInput | ForumPostWhereInput[]
    OR?: ForumPostWhereInput[]
    NOT?: ForumPostWhereInput | ForumPostWhereInput[]
    content?: StringFilter<"ForumPost"> | string
    topicId?: StringFilter<"ForumPost"> | string
    creatorId?: StringFilter<"ForumPost"> | string
    likes?: IntFilter<"ForumPost"> | number
    parentPostId?: StringNullableFilter<"ForumPost"> | string | null
    createdAt?: DateTimeFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPost"> | Date | string
    topic?: XOR<ForumTopicScalarRelationFilter, ForumTopicWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    reactions?: ForumPostReactionListRelationFilter
    parentPost?: XOR<ForumPostNullableScalarRelationFilter, ForumPostWhereInput> | null
    replies?: ForumPostListRelationFilter
  }, "id">

  export type ForumPostOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    topicId?: SortOrder
    creatorId?: SortOrder
    likes?: SortOrder
    parentPostId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumPostCountOrderByAggregateInput
    _avg?: ForumPostAvgOrderByAggregateInput
    _max?: ForumPostMaxOrderByAggregateInput
    _min?: ForumPostMinOrderByAggregateInput
    _sum?: ForumPostSumOrderByAggregateInput
  }

  export type ForumPostScalarWhereWithAggregatesInput = {
    AND?: ForumPostScalarWhereWithAggregatesInput | ForumPostScalarWhereWithAggregatesInput[]
    OR?: ForumPostScalarWhereWithAggregatesInput[]
    NOT?: ForumPostScalarWhereWithAggregatesInput | ForumPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumPost"> | string
    content?: StringWithAggregatesFilter<"ForumPost"> | string
    topicId?: StringWithAggregatesFilter<"ForumPost"> | string
    creatorId?: StringWithAggregatesFilter<"ForumPost"> | string
    likes?: IntWithAggregatesFilter<"ForumPost"> | number
    parentPostId?: StringNullableWithAggregatesFilter<"ForumPost"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumPost"> | Date | string
  }

  export type ForumReplyReactionWhereInput = {
    AND?: ForumReplyReactionWhereInput | ForumReplyReactionWhereInput[]
    OR?: ForumReplyReactionWhereInput[]
    NOT?: ForumReplyReactionWhereInput | ForumReplyReactionWhereInput[]
    id?: StringFilter<"ForumReplyReaction"> | string
    forumReplyId?: StringFilter<"ForumReplyReaction"> | string
    userId?: StringFilter<"ForumReplyReaction"> | string
    type?: EnumReactionTypeFilter<"ForumReplyReaction"> | $Enums.ReactionType
    forumReply?: XOR<ForumReplyScalarRelationFilter, ForumReplyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ForumReplyReactionOrderByWithRelationInput = {
    id?: SortOrder
    forumReplyId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    forumReply?: ForumReplyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ForumReplyReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    forumReplyId_userId_type?: ForumReplyReactionForumReplyIdUserIdTypeCompoundUniqueInput
    AND?: ForumReplyReactionWhereInput | ForumReplyReactionWhereInput[]
    OR?: ForumReplyReactionWhereInput[]
    NOT?: ForumReplyReactionWhereInput | ForumReplyReactionWhereInput[]
    forumReplyId?: StringFilter<"ForumReplyReaction"> | string
    userId?: StringFilter<"ForumReplyReaction"> | string
    type?: EnumReactionTypeFilter<"ForumReplyReaction"> | $Enums.ReactionType
    forumReply?: XOR<ForumReplyScalarRelationFilter, ForumReplyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "forumReplyId_userId_type">

  export type ForumReplyReactionOrderByWithAggregationInput = {
    id?: SortOrder
    forumReplyId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    _count?: ForumReplyReactionCountOrderByAggregateInput
    _max?: ForumReplyReactionMaxOrderByAggregateInput
    _min?: ForumReplyReactionMinOrderByAggregateInput
  }

  export type ForumReplyReactionScalarWhereWithAggregatesInput = {
    AND?: ForumReplyReactionScalarWhereWithAggregatesInput | ForumReplyReactionScalarWhereWithAggregatesInput[]
    OR?: ForumReplyReactionScalarWhereWithAggregatesInput[]
    NOT?: ForumReplyReactionScalarWhereWithAggregatesInput | ForumReplyReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumReplyReaction"> | string
    forumReplyId?: StringWithAggregatesFilter<"ForumReplyReaction"> | string
    userId?: StringWithAggregatesFilter<"ForumReplyReaction"> | string
    type?: EnumReactionTypeWithAggregatesFilter<"ForumReplyReaction"> | $Enums.ReactionType
  }

  export type ForumPostReactionWhereInput = {
    AND?: ForumPostReactionWhereInput | ForumPostReactionWhereInput[]
    OR?: ForumPostReactionWhereInput[]
    NOT?: ForumPostReactionWhereInput | ForumPostReactionWhereInput[]
    id?: StringFilter<"ForumPostReaction"> | string
    forumPostId?: StringFilter<"ForumPostReaction"> | string
    userId?: StringFilter<"ForumPostReaction"> | string
    type?: EnumReactionTypeFilter<"ForumPostReaction"> | $Enums.ReactionType
    forumPost?: XOR<ForumPostScalarRelationFilter, ForumPostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ForumPostReactionOrderByWithRelationInput = {
    id?: SortOrder
    forumPostId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    forumPost?: ForumPostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ForumPostReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    forumPostId_userId_type?: ForumPostReactionForumPostIdUserIdTypeCompoundUniqueInput
    AND?: ForumPostReactionWhereInput | ForumPostReactionWhereInput[]
    OR?: ForumPostReactionWhereInput[]
    NOT?: ForumPostReactionWhereInput | ForumPostReactionWhereInput[]
    forumPostId?: StringFilter<"ForumPostReaction"> | string
    userId?: StringFilter<"ForumPostReaction"> | string
    type?: EnumReactionTypeFilter<"ForumPostReaction"> | $Enums.ReactionType
    forumPost?: XOR<ForumPostScalarRelationFilter, ForumPostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "forumPostId_userId_type">

  export type ForumPostReactionOrderByWithAggregationInput = {
    id?: SortOrder
    forumPostId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    _count?: ForumPostReactionCountOrderByAggregateInput
    _max?: ForumPostReactionMaxOrderByAggregateInput
    _min?: ForumPostReactionMinOrderByAggregateInput
  }

  export type ForumPostReactionScalarWhereWithAggregatesInput = {
    AND?: ForumPostReactionScalarWhereWithAggregatesInput | ForumPostReactionScalarWhereWithAggregatesInput[]
    OR?: ForumPostReactionScalarWhereWithAggregatesInput[]
    NOT?: ForumPostReactionScalarWhereWithAggregatesInput | ForumPostReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumPostReaction"> | string
    forumPostId?: StringWithAggregatesFilter<"ForumPostReaction"> | string
    userId?: StringWithAggregatesFilter<"ForumPostReaction"> | string
    type?: EnumReactionTypeWithAggregatesFilter<"ForumPostReaction"> | $Enums.ReactionType
  }

  export type ArticleWhereInput = {
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    id?: StringFilter<"Article"> | string
    title?: StringFilter<"Article"> | string
    description?: StringNullableFilter<"Article"> | string | null
    content?: StringFilter<"Article"> | string
    bannerImg?: StringNullableFilter<"Article"> | string | null
    images?: StringNullableListFilter<"Article">
    tags?: StringNullableListFilter<"Article">
    type?: EnumArticleTypeFilter<"Article"> | $Enums.ArticleType
    status?: EnumArticleStatusFilter<"Article"> | $Enums.ArticleStatus
    creatorId?: StringFilter<"Article"> | string
    groupId?: StringNullableFilter<"Article"> | string | null
    upVotes?: IntFilter<"Article"> | number
    downVotes?: IntFilter<"Article"> | number
    views?: IntFilter<"Article"> | number
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupNullableScalarRelationFilter, GroupWhereInput> | null
    votes?: VoteListRelationFilter
  }

  export type ArticleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    bannerImg?: SortOrderInput | SortOrder
    images?: SortOrder
    tags?: SortOrder
    type?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    groupId?: SortOrderInput | SortOrder
    upVotes?: SortOrder
    downVotes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
    votes?: VoteOrderByRelationAggregateInput
  }

  export type ArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    title?: StringFilter<"Article"> | string
    description?: StringNullableFilter<"Article"> | string | null
    content?: StringFilter<"Article"> | string
    bannerImg?: StringNullableFilter<"Article"> | string | null
    images?: StringNullableListFilter<"Article">
    tags?: StringNullableListFilter<"Article">
    type?: EnumArticleTypeFilter<"Article"> | $Enums.ArticleType
    status?: EnumArticleStatusFilter<"Article"> | $Enums.ArticleStatus
    creatorId?: StringFilter<"Article"> | string
    groupId?: StringNullableFilter<"Article"> | string | null
    upVotes?: IntFilter<"Article"> | number
    downVotes?: IntFilter<"Article"> | number
    views?: IntFilter<"Article"> | number
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupNullableScalarRelationFilter, GroupWhereInput> | null
    votes?: VoteListRelationFilter
  }, "id">

  export type ArticleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    bannerImg?: SortOrderInput | SortOrder
    images?: SortOrder
    tags?: SortOrder
    type?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    groupId?: SortOrderInput | SortOrder
    upVotes?: SortOrder
    downVotes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArticleCountOrderByAggregateInput
    _avg?: ArticleAvgOrderByAggregateInput
    _max?: ArticleMaxOrderByAggregateInput
    _min?: ArticleMinOrderByAggregateInput
    _sum?: ArticleSumOrderByAggregateInput
  }

  export type ArticleScalarWhereWithAggregatesInput = {
    AND?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    OR?: ArticleScalarWhereWithAggregatesInput[]
    NOT?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Article"> | string
    title?: StringWithAggregatesFilter<"Article"> | string
    description?: StringNullableWithAggregatesFilter<"Article"> | string | null
    content?: StringWithAggregatesFilter<"Article"> | string
    bannerImg?: StringNullableWithAggregatesFilter<"Article"> | string | null
    images?: StringNullableListFilter<"Article">
    tags?: StringNullableListFilter<"Article">
    type?: EnumArticleTypeWithAggregatesFilter<"Article"> | $Enums.ArticleType
    status?: EnumArticleStatusWithAggregatesFilter<"Article"> | $Enums.ArticleStatus
    creatorId?: StringWithAggregatesFilter<"Article"> | string
    groupId?: StringNullableWithAggregatesFilter<"Article"> | string | null
    upVotes?: IntWithAggregatesFilter<"Article"> | number
    downVotes?: IntWithAggregatesFilter<"Article"> | number
    views?: IntWithAggregatesFilter<"Article"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    refreshToken?: StringNullableFilter<"Session"> | string | null
    expires?: DateTimeFilter<"Session"> | Date | string
    lastActivity?: DateTimeNullableFilter<"Session"> | Date | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expires?: SortOrder
    lastActivity?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    refreshToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    lastActivity?: DateTimeNullableFilter<"Session"> | Date | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken" | "refreshToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expires?: SortOrder
    lastActivity?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"Session"> | string | null
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    lastActivity?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    data?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type FavCourseWhereInput = {
    AND?: FavCourseWhereInput | FavCourseWhereInput[]
    OR?: FavCourseWhereInput[]
    NOT?: FavCourseWhereInput | FavCourseWhereInput[]
    id?: StringFilter<"FavCourse"> | string
    userId?: StringFilter<"FavCourse"> | string
    universityId?: StringNullableFilter<"FavCourse"> | string | null
    universityName?: StringNullableFilter<"FavCourse"> | string | null
    courseName?: StringNullableFilter<"FavCourse"> | string | null
    courseId?: StringFilter<"FavCourse"> | string
    createdAt?: DateTimeFilter<"FavCourse"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type FavCourseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    universityId?: SortOrderInput | SortOrder
    universityName?: SortOrderInput | SortOrder
    courseName?: SortOrderInput | SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type FavCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_courseId?: FavCourseUserIdCourseIdCompoundUniqueInput
    AND?: FavCourseWhereInput | FavCourseWhereInput[]
    OR?: FavCourseWhereInput[]
    NOT?: FavCourseWhereInput | FavCourseWhereInput[]
    userId?: StringFilter<"FavCourse"> | string
    universityId?: StringNullableFilter<"FavCourse"> | string | null
    universityName?: StringNullableFilter<"FavCourse"> | string | null
    courseName?: StringNullableFilter<"FavCourse"> | string | null
    courseId?: StringFilter<"FavCourse"> | string
    createdAt?: DateTimeFilter<"FavCourse"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "userId_courseId">

  export type FavCourseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    universityId?: SortOrderInput | SortOrder
    universityName?: SortOrderInput | SortOrder
    courseName?: SortOrderInput | SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    _count?: FavCourseCountOrderByAggregateInput
    _max?: FavCourseMaxOrderByAggregateInput
    _min?: FavCourseMinOrderByAggregateInput
  }

  export type FavCourseScalarWhereWithAggregatesInput = {
    AND?: FavCourseScalarWhereWithAggregatesInput | FavCourseScalarWhereWithAggregatesInput[]
    OR?: FavCourseScalarWhereWithAggregatesInput[]
    NOT?: FavCourseScalarWhereWithAggregatesInput | FavCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FavCourse"> | string
    userId?: StringWithAggregatesFilter<"FavCourse"> | string
    universityId?: StringNullableWithAggregatesFilter<"FavCourse"> | string | null
    universityName?: StringNullableWithAggregatesFilter<"FavCourse"> | string | null
    courseName?: StringNullableWithAggregatesFilter<"FavCourse"> | string | null
    courseId?: StringWithAggregatesFilter<"FavCourse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FavCourse"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    countryCode?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    header?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    banner?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    googleAccessToken?: StringNullableFilter<"User"> | string | null
    googleRefreshToken?: StringNullableFilter<"User"> | string | null
    googleTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordToken?: StringNullableFilter<"User"> | string | null
    resetPasswordExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    lastPasswordChangeAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isPhoneVerified?: BoolFilter<"User"> | boolean
    isEmailVerified?: BoolFilter<"User"> | boolean
    otpRetryCount?: IntFilter<"User"> | number
    otpLastSentAt?: DateTimeNullableFilter<"User"> | Date | string | null
    otpBlockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    followersCount?: IntFilter<"User"> | number
    followingCount?: IntFilter<"User"> | number
    universityId?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    program?: StringNullableFilter<"User"> | string | null
    graduationYear?: IntNullableFilter<"User"> | number | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    loginAttempts?: IntFilter<"User"> | number
    isLocked?: BoolFilter<"User"> | boolean
    lockUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    isLandlordVerified?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    favCourses?: FavCourseListRelationFilter
    quizAnswers?: QuizAnswerListRelationFilter
    createdForums?: ForumListRelationFilter
    createdForumTopics?: ForumTopicListRelationFilter
    forumReplies?: ForumReplyListRelationFilter
    forumPosts?: ForumPostListRelationFilter
    forumReplyReactions?: ForumReplyReactionListRelationFilter
    forumPostReactions?: ForumPostReactionListRelationFilter
    university?: XOR<UniversityNullableScalarRelationFilter, UniversityWhereInput> | null
    loanApplications?: LoanApplicationListRelationFilter
    accommodationRatings?: AccommodationRatingListRelationFilter
    applications?: UniversityApplicationsListRelationFilter
    tokens?: TokenListRelationFilter
    accommodations?: AccommodationListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    otps?: OTPListRelationFilter
    notifications?: NotificationListRelationFilter
    followers?: FollowListRelationFilter
    following?: FollowListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    createdGroups?: GroupListRelationFilter
    adminOf?: GroupListRelationFilter
    groupMemberships?: GroupMemberListRelationFilter
    hostedEvents?: EventListRelationFilter
    articles?: ArticleListRelationFilter
    accommodationReviews?: AccommodationReviewListRelationFilter
    likedAccommodations?: LikedAccommodationsListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    name?: SortOrder
    header?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    banner?: SortOrderInput | SortOrder
    role?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    googleAccessToken?: SortOrderInput | SortOrder
    googleRefreshToken?: SortOrderInput | SortOrder
    googleTokenExpiry?: SortOrderInput | SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    resetPasswordExpiry?: SortOrderInput | SortOrder
    lastPasswordChangeAt?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isPhoneVerified?: SortOrder
    isEmailVerified?: SortOrder
    otpRetryCount?: SortOrder
    otpLastSentAt?: SortOrderInput | SortOrder
    otpBlockedUntil?: SortOrderInput | SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    universityId?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    program?: SortOrderInput | SortOrder
    graduationYear?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    isLocked?: SortOrder
    lockUntil?: SortOrderInput | SortOrder
    isLandlordVerified?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    favCourses?: FavCourseOrderByRelationAggregateInput
    quizAnswers?: QuizAnswerOrderByRelationAggregateInput
    createdForums?: ForumOrderByRelationAggregateInput
    createdForumTopics?: ForumTopicOrderByRelationAggregateInput
    forumReplies?: ForumReplyOrderByRelationAggregateInput
    forumPosts?: ForumPostOrderByRelationAggregateInput
    forumReplyReactions?: ForumReplyReactionOrderByRelationAggregateInput
    forumPostReactions?: ForumPostReactionOrderByRelationAggregateInput
    university?: UniversityOrderByWithRelationInput
    loanApplications?: LoanApplicationOrderByRelationAggregateInput
    accommodationRatings?: AccommodationRatingOrderByRelationAggregateInput
    applications?: UniversityApplicationsOrderByRelationAggregateInput
    tokens?: TokenOrderByRelationAggregateInput
    accommodations?: AccommodationOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    otps?: OTPOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    followers?: FollowOrderByRelationAggregateInput
    following?: FollowOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    createdGroups?: GroupOrderByRelationAggregateInput
    adminOf?: GroupOrderByRelationAggregateInput
    groupMemberships?: GroupMemberOrderByRelationAggregateInput
    hostedEvents?: EventOrderByRelationAggregateInput
    articles?: ArticleOrderByRelationAggregateInput
    accommodationReviews?: AccommodationReviewOrderByRelationAggregateInput
    likedAccommodations?: LikedAccommodationsOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    googleId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    countryCode?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    header?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    banner?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    googleAccessToken?: StringNullableFilter<"User"> | string | null
    googleRefreshToken?: StringNullableFilter<"User"> | string | null
    googleTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordToken?: StringNullableFilter<"User"> | string | null
    resetPasswordExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    lastPasswordChangeAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isPhoneVerified?: BoolFilter<"User"> | boolean
    isEmailVerified?: BoolFilter<"User"> | boolean
    otpRetryCount?: IntFilter<"User"> | number
    otpLastSentAt?: DateTimeNullableFilter<"User"> | Date | string | null
    otpBlockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    followersCount?: IntFilter<"User"> | number
    followingCount?: IntFilter<"User"> | number
    universityId?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    program?: StringNullableFilter<"User"> | string | null
    graduationYear?: IntNullableFilter<"User"> | number | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    loginAttempts?: IntFilter<"User"> | number
    isLocked?: BoolFilter<"User"> | boolean
    lockUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    isLandlordVerified?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    favCourses?: FavCourseListRelationFilter
    quizAnswers?: QuizAnswerListRelationFilter
    createdForums?: ForumListRelationFilter
    createdForumTopics?: ForumTopicListRelationFilter
    forumReplies?: ForumReplyListRelationFilter
    forumPosts?: ForumPostListRelationFilter
    forumReplyReactions?: ForumReplyReactionListRelationFilter
    forumPostReactions?: ForumPostReactionListRelationFilter
    university?: XOR<UniversityNullableScalarRelationFilter, UniversityWhereInput> | null
    loanApplications?: LoanApplicationListRelationFilter
    accommodationRatings?: AccommodationRatingListRelationFilter
    applications?: UniversityApplicationsListRelationFilter
    tokens?: TokenListRelationFilter
    accommodations?: AccommodationListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    otps?: OTPListRelationFilter
    notifications?: NotificationListRelationFilter
    followers?: FollowListRelationFilter
    following?: FollowListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    createdGroups?: GroupListRelationFilter
    adminOf?: GroupListRelationFilter
    groupMemberships?: GroupMemberListRelationFilter
    hostedEvents?: EventListRelationFilter
    articles?: ArticleListRelationFilter
    accommodationReviews?: AccommodationReviewListRelationFilter
    likedAccommodations?: LikedAccommodationsListRelationFilter
  }, "id" | "username" | "email" | "googleId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    name?: SortOrder
    header?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    banner?: SortOrderInput | SortOrder
    role?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    googleAccessToken?: SortOrderInput | SortOrder
    googleRefreshToken?: SortOrderInput | SortOrder
    googleTokenExpiry?: SortOrderInput | SortOrder
    resetPasswordToken?: SortOrderInput | SortOrder
    resetPasswordExpiry?: SortOrderInput | SortOrder
    lastPasswordChangeAt?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isPhoneVerified?: SortOrder
    isEmailVerified?: SortOrder
    otpRetryCount?: SortOrder
    otpLastSentAt?: SortOrderInput | SortOrder
    otpBlockedUntil?: SortOrderInput | SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    universityId?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    program?: SortOrderInput | SortOrder
    graduationYear?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    isLocked?: SortOrder
    lockUntil?: SortOrderInput | SortOrder
    isLandlordVerified?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    countryCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    header?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    banner?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleAccessToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleRefreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetPasswordToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetPasswordExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastPasswordChangeAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isPhoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    otpRetryCount?: IntWithAggregatesFilter<"User"> | number
    otpLastSentAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    otpBlockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    followersCount?: IntWithAggregatesFilter<"User"> | number
    followingCount?: IntWithAggregatesFilter<"User"> | number
    universityId?: StringNullableWithAggregatesFilter<"User"> | string | null
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
    program?: StringNullableWithAggregatesFilter<"User"> | string | null
    graduationYear?: IntNullableWithAggregatesFilter<"User"> | number | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    loginAttempts?: IntWithAggregatesFilter<"User"> | number
    isLocked?: BoolWithAggregatesFilter<"User"> | boolean
    lockUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isLandlordVerified?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type QuizAnswerWhereInput = {
    AND?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    OR?: QuizAnswerWhereInput[]
    NOT?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    id?: IntFilter<"QuizAnswer"> | number
    userId?: StringFilter<"QuizAnswer"> | string
    questionId?: IntFilter<"QuizAnswer"> | number
    answer?: StringFilter<"QuizAnswer"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type QuizAnswerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type QuizAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    OR?: QuizAnswerWhereInput[]
    NOT?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    userId?: StringFilter<"QuizAnswer"> | string
    questionId?: IntFilter<"QuizAnswer"> | number
    answer?: StringFilter<"QuizAnswer"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type QuizAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    _count?: QuizAnswerCountOrderByAggregateInput
    _avg?: QuizAnswerAvgOrderByAggregateInput
    _max?: QuizAnswerMaxOrderByAggregateInput
    _min?: QuizAnswerMinOrderByAggregateInput
    _sum?: QuizAnswerSumOrderByAggregateInput
  }

  export type QuizAnswerScalarWhereWithAggregatesInput = {
    AND?: QuizAnswerScalarWhereWithAggregatesInput | QuizAnswerScalarWhereWithAggregatesInput[]
    OR?: QuizAnswerScalarWhereWithAggregatesInput[]
    NOT?: QuizAnswerScalarWhereWithAggregatesInput | QuizAnswerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizAnswer"> | number
    userId?: StringWithAggregatesFilter<"QuizAnswer"> | string
    questionId?: IntWithAggregatesFilter<"QuizAnswer"> | number
    answer?: StringWithAggregatesFilter<"QuizAnswer"> | string
  }

  export type LikedAccommodationsWhereInput = {
    AND?: LikedAccommodationsWhereInput | LikedAccommodationsWhereInput[]
    OR?: LikedAccommodationsWhereInput[]
    NOT?: LikedAccommodationsWhereInput | LikedAccommodationsWhereInput[]
    id?: StringFilter<"LikedAccommodations"> | string
    userId?: StringFilter<"LikedAccommodations"> | string
    accommodationId?: StringFilter<"LikedAccommodations"> | string
    createdAt?: DateTimeFilter<"LikedAccommodations"> | Date | string
    updatedAt?: DateTimeFilter<"LikedAccommodations"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    accommodation?: XOR<AccommodationScalarRelationFilter, AccommodationWhereInput>
  }

  export type LikedAccommodationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    accommodation?: AccommodationOrderByWithRelationInput
  }

  export type LikedAccommodationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_accommodationId?: LikedAccommodationsUserIdAccommodationIdCompoundUniqueInput
    AND?: LikedAccommodationsWhereInput | LikedAccommodationsWhereInput[]
    OR?: LikedAccommodationsWhereInput[]
    NOT?: LikedAccommodationsWhereInput | LikedAccommodationsWhereInput[]
    userId?: StringFilter<"LikedAccommodations"> | string
    accommodationId?: StringFilter<"LikedAccommodations"> | string
    createdAt?: DateTimeFilter<"LikedAccommodations"> | Date | string
    updatedAt?: DateTimeFilter<"LikedAccommodations"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    accommodation?: XOR<AccommodationScalarRelationFilter, AccommodationWhereInput>
  }, "id" | "userId_accommodationId">

  export type LikedAccommodationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LikedAccommodationsCountOrderByAggregateInput
    _max?: LikedAccommodationsMaxOrderByAggregateInput
    _min?: LikedAccommodationsMinOrderByAggregateInput
  }

  export type LikedAccommodationsScalarWhereWithAggregatesInput = {
    AND?: LikedAccommodationsScalarWhereWithAggregatesInput | LikedAccommodationsScalarWhereWithAggregatesInput[]
    OR?: LikedAccommodationsScalarWhereWithAggregatesInput[]
    NOT?: LikedAccommodationsScalarWhereWithAggregatesInput | LikedAccommodationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LikedAccommodations"> | string
    userId?: StringWithAggregatesFilter<"LikedAccommodations"> | string
    accommodationId?: StringWithAggregatesFilter<"LikedAccommodations"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LikedAccommodations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LikedAccommodations"> | Date | string
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: StringFilter<"Token"> | string
    token?: StringFilter<"Token"> | string
    type?: EnumTokenTypeFilter<"Token"> | $Enums.TokenType
    userId?: StringFilter<"Token"> | string
    createdAt?: DateTimeFilter<"Token"> | Date | string
    expiresAt?: DateTimeFilter<"Token"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    type?: EnumTokenTypeFilter<"Token"> | $Enums.TokenType
    userId?: StringFilter<"Token"> | string
    createdAt?: DateTimeFilter<"Token"> | Date | string
    expiresAt?: DateTimeFilter<"Token"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: TokenCountOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Token"> | string
    token?: StringWithAggregatesFilter<"Token"> | string
    type?: EnumTokenTypeWithAggregatesFilter<"Token"> | $Enums.TokenType
    userId?: StringWithAggregatesFilter<"Token"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
  }

  export type OTPWhereInput = {
    AND?: OTPWhereInput | OTPWhereInput[]
    OR?: OTPWhereInput[]
    NOT?: OTPWhereInput | OTPWhereInput[]
    id?: StringFilter<"OTP"> | string
    userId?: StringFilter<"OTP"> | string
    otpCode?: StringFilter<"OTP"> | string
    type?: EnumOTPTypeFilter<"OTP"> | $Enums.OTPType
    purpose?: EnumOTPPurposeFilter<"OTP"> | $Enums.OTPPurpose
    verified?: BoolFilter<"OTP"> | boolean
    attempts?: IntFilter<"OTP"> | number
    expiresAt?: DateTimeFilter<"OTP"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"OTP"> | Date | string | null
    invalidated?: BoolFilter<"OTP"> | boolean
    createdAt?: DateTimeFilter<"OTP"> | Date | string
    updatedAt?: DateTimeFilter<"OTP"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OTPOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    otpCode?: SortOrder
    type?: SortOrder
    purpose?: SortOrder
    verified?: SortOrder
    attempts?: SortOrder
    expiresAt?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    invalidated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OTPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OTPWhereInput | OTPWhereInput[]
    OR?: OTPWhereInput[]
    NOT?: OTPWhereInput | OTPWhereInput[]
    userId?: StringFilter<"OTP"> | string
    otpCode?: StringFilter<"OTP"> | string
    type?: EnumOTPTypeFilter<"OTP"> | $Enums.OTPType
    purpose?: EnumOTPPurposeFilter<"OTP"> | $Enums.OTPPurpose
    verified?: BoolFilter<"OTP"> | boolean
    attempts?: IntFilter<"OTP"> | number
    expiresAt?: DateTimeFilter<"OTP"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"OTP"> | Date | string | null
    invalidated?: BoolFilter<"OTP"> | boolean
    createdAt?: DateTimeFilter<"OTP"> | Date | string
    updatedAt?: DateTimeFilter<"OTP"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type OTPOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    otpCode?: SortOrder
    type?: SortOrder
    purpose?: SortOrder
    verified?: SortOrder
    attempts?: SortOrder
    expiresAt?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    invalidated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OTPCountOrderByAggregateInput
    _avg?: OTPAvgOrderByAggregateInput
    _max?: OTPMaxOrderByAggregateInput
    _min?: OTPMinOrderByAggregateInput
    _sum?: OTPSumOrderByAggregateInput
  }

  export type OTPScalarWhereWithAggregatesInput = {
    AND?: OTPScalarWhereWithAggregatesInput | OTPScalarWhereWithAggregatesInput[]
    OR?: OTPScalarWhereWithAggregatesInput[]
    NOT?: OTPScalarWhereWithAggregatesInput | OTPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OTP"> | string
    userId?: StringWithAggregatesFilter<"OTP"> | string
    otpCode?: StringWithAggregatesFilter<"OTP"> | string
    type?: EnumOTPTypeWithAggregatesFilter<"OTP"> | $Enums.OTPType
    purpose?: EnumOTPPurposeWithAggregatesFilter<"OTP"> | $Enums.OTPPurpose
    verified?: BoolWithAggregatesFilter<"OTP"> | boolean
    attempts?: IntWithAggregatesFilter<"OTP"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"OTP"> | Date | string
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"OTP"> | Date | string | null
    invalidated?: BoolWithAggregatesFilter<"OTP"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OTP"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OTP"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type BlogWhereInput = {
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    id?: UuidFilter<"Blog"> | string
    title?: StringFilter<"Blog"> | string
    slug?: StringFilter<"Blog"> | string
    summary?: StringFilter<"Blog"> | string
    coverImage?: StringNullableFilter<"Blog"> | string | null
    published?: BoolFilter<"Blog"> | boolean
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    contentBlocks?: ContentBlockListRelationFilter
  }

  export type BlogOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    coverImage?: SortOrderInput | SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contentBlocks?: ContentBlockOrderByRelationAggregateInput
  }

  export type BlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    title?: StringFilter<"Blog"> | string
    summary?: StringFilter<"Blog"> | string
    coverImage?: StringNullableFilter<"Blog"> | string | null
    published?: BoolFilter<"Blog"> | boolean
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    contentBlocks?: ContentBlockListRelationFilter
  }, "id" | "slug">

  export type BlogOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    coverImage?: SortOrderInput | SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogCountOrderByAggregateInput
    _max?: BlogMaxOrderByAggregateInput
    _min?: BlogMinOrderByAggregateInput
  }

  export type BlogScalarWhereWithAggregatesInput = {
    AND?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    OR?: BlogScalarWhereWithAggregatesInput[]
    NOT?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Blog"> | string
    title?: StringWithAggregatesFilter<"Blog"> | string
    slug?: StringWithAggregatesFilter<"Blog"> | string
    summary?: StringWithAggregatesFilter<"Blog"> | string
    coverImage?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    published?: BoolWithAggregatesFilter<"Blog"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
  }

  export type ContentBlockWhereInput = {
    AND?: ContentBlockWhereInput | ContentBlockWhereInput[]
    OR?: ContentBlockWhereInput[]
    NOT?: ContentBlockWhereInput | ContentBlockWhereInput[]
    id?: UuidFilter<"ContentBlock"> | string
    type?: StringFilter<"ContentBlock"> | string
    content?: StringFilter<"ContentBlock"> | string
    order?: IntFilter<"ContentBlock"> | number
    blogId?: UuidFilter<"ContentBlock"> | string
    createdAt?: DateTimeFilter<"ContentBlock"> | Date | string
    updatedAt?: DateTimeFilter<"ContentBlock"> | Date | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
  }

  export type ContentBlockOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    blogId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blog?: BlogOrderByWithRelationInput
  }

  export type ContentBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentBlockWhereInput | ContentBlockWhereInput[]
    OR?: ContentBlockWhereInput[]
    NOT?: ContentBlockWhereInput | ContentBlockWhereInput[]
    type?: StringFilter<"ContentBlock"> | string
    content?: StringFilter<"ContentBlock"> | string
    order?: IntFilter<"ContentBlock"> | number
    blogId?: UuidFilter<"ContentBlock"> | string
    createdAt?: DateTimeFilter<"ContentBlock"> | Date | string
    updatedAt?: DateTimeFilter<"ContentBlock"> | Date | string
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
  }, "id">

  export type ContentBlockOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    blogId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContentBlockCountOrderByAggregateInput
    _avg?: ContentBlockAvgOrderByAggregateInput
    _max?: ContentBlockMaxOrderByAggregateInput
    _min?: ContentBlockMinOrderByAggregateInput
    _sum?: ContentBlockSumOrderByAggregateInput
  }

  export type ContentBlockScalarWhereWithAggregatesInput = {
    AND?: ContentBlockScalarWhereWithAggregatesInput | ContentBlockScalarWhereWithAggregatesInput[]
    OR?: ContentBlockScalarWhereWithAggregatesInput[]
    NOT?: ContentBlockScalarWhereWithAggregatesInput | ContentBlockScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ContentBlock"> | string
    type?: StringWithAggregatesFilter<"ContentBlock"> | string
    content?: StringWithAggregatesFilter<"ContentBlock"> | string
    order?: IntWithAggregatesFilter<"ContentBlock"> | number
    blogId?: UuidWithAggregatesFilter<"ContentBlock"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContentBlock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentBlock"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    details?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: StringWithAggregatesFilter<"AuditLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AccommodationRatingCreateInput = {
    id?: string
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccommodationRatingsInput
    accommodation: AccommodationCreateNestedOneWithoutRatingsInput
  }

  export type AccommodationRatingUncheckedCreateInput = {
    id?: string
    rating: number
    review?: string | null
    userId: string
    accommodationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccommodationRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccommodationRatingsNestedInput
    accommodation?: AccommodationUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type AccommodationRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationRatingCreateManyInput = {
    id?: string
    rating: number
    review?: string | null
    userId: string
    accommodationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccommodationRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerOutcomeCreateInput = {
    id?: string
    iconName: string
    iconImage: string
    title: string
    value: string
    description: string
    details: string
    color: string
    bgColor: string
    university: UniversityCreateNestedOneWithoutCareerOutcomesInput
  }

  export type CareerOutcomeUncheckedCreateInput = {
    id?: string
    iconName: string
    iconImage: string
    title: string
    value: string
    description: string
    details: string
    color: string
    bgColor: string
    universityId: string
  }

  export type CareerOutcomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    iconImage?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
    university?: UniversityUpdateOneRequiredWithoutCareerOutcomesNestedInput
  }

  export type CareerOutcomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    iconImage?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
    universityId?: StringFieldUpdateOperationsInput | string
  }

  export type CareerOutcomeCreateManyInput = {
    id?: string
    iconName: string
    iconImage: string
    title: string
    value: string
    description: string
    details: string
    color: string
    bgColor: string
    universityId: string
  }

  export type CareerOutcomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    iconImage?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
  }

  export type CareerOutcomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    iconImage?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
    universityId?: StringFieldUpdateOperationsInput | string
  }

  export type FaqCreateInput = {
    id?: string
    question: string
    answer: string
    university: UniversityCreateNestedOneWithoutFaqsInput
  }

  export type FaqUncheckedCreateInput = {
    id?: string
    question: string
    answer: string
    universityId: string
  }

  export type FaqUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    university?: UniversityUpdateOneRequiredWithoutFaqsNestedInput
  }

  export type FaqUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    universityId?: StringFieldUpdateOperationsInput | string
  }

  export type FaqCreateManyInput = {
    id?: string
    question: string
    answer: string
    universityId: string
  }

  export type FaqUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type FaqUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    universityId?: StringFieldUpdateOperationsInput | string
  }

  export type UniversityCreateInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    careerOutcomes?: CareerOutcomeCreateNestedManyWithoutUniversityInput
    faqs?: FaqCreateNestedManyWithoutUniversityInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUniversityInput
    loans?: LoanCreateNestedManyWithoutUniversityInput
    users?: UserCreateNestedManyWithoutUniversityInput
    courses?: CourseCreateNestedManyWithoutUniversityInput
  }

  export type UniversityUncheckedCreateInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    careerOutcomes?: CareerOutcomeUncheckedCreateNestedManyWithoutUniversityInput
    faqs?: FaqUncheckedCreateNestedManyWithoutUniversityInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUniversityInput
    loans?: LoanUncheckedCreateNestedManyWithoutUniversityInput
    users?: UserUncheckedCreateNestedManyWithoutUniversityInput
    courses?: CourseUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerOutcomes?: CareerOutcomeUpdateManyWithoutUniversityNestedInput
    faqs?: FaqUpdateManyWithoutUniversityNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUniversityNestedInput
    loans?: LoanUpdateManyWithoutUniversityNestedInput
    users?: UserUpdateManyWithoutUniversityNestedInput
    courses?: CourseUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerOutcomes?: CareerOutcomeUncheckedUpdateManyWithoutUniversityNestedInput
    faqs?: FaqUncheckedUpdateManyWithoutUniversityNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUniversityNestedInput
    loans?: LoanUncheckedUpdateManyWithoutUniversityNestedInput
    users?: UserUncheckedUpdateManyWithoutUniversityNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityCreateManyInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    fees?: string | null
    duration?: string | null
    degreeType?: string | null
    ieltsScore?: string | null
    ranking?: string | null
    intake?: CourseCreateintakeInput | string[]
    websiteLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: UniversityApplicationsCreateNestedManyWithoutCourseInput
    favByUsers?: FavCourseCreateNestedManyWithoutCourseInput
    university: UniversityCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    fees?: string | null
    duration?: string | null
    degreeType?: string | null
    ieltsScore?: string | null
    ranking?: string | null
    intake?: CourseCreateintakeInput | string[]
    websiteLink?: string | null
    universityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutCourseInput
    favByUsers?: FavCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: NullableStringFieldUpdateOperationsInput | string | null
    ieltsScore?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableStringFieldUpdateOperationsInput | string | null
    intake?: CourseUpdateintakeInput | string[]
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: UniversityApplicationsUpdateManyWithoutCourseNestedInput
    favByUsers?: FavCourseUpdateManyWithoutCourseNestedInput
    university?: UniversityUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: NullableStringFieldUpdateOperationsInput | string | null
    ieltsScore?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableStringFieldUpdateOperationsInput | string | null
    intake?: CourseUpdateintakeInput | string[]
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    universityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutCourseNestedInput
    favByUsers?: FavCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    fees?: string | null
    duration?: string | null
    degreeType?: string | null
    ieltsScore?: string | null
    ranking?: string | null
    intake?: CourseCreateintakeInput | string[]
    websiteLink?: string | null
    universityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: NullableStringFieldUpdateOperationsInput | string | null
    ieltsScore?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableStringFieldUpdateOperationsInput | string | null
    intake?: CourseUpdateintakeInput | string[]
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: NullableStringFieldUpdateOperationsInput | string | null
    ieltsScore?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableStringFieldUpdateOperationsInput | string | null
    intake?: CourseUpdateintakeInput | string[]
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    universityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityApplicationsCreateInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    appliedAt?: Date | string
    loanRequired?: boolean
    documents?: UniversityApplicationsCreatedocumentsInput | string[]
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutApplicationsInput
    university: UniversityCreateNestedOneWithoutApplicationsInput
    course: CourseCreateNestedOneWithoutApplicationsInput
  }

  export type UniversityApplicationsUncheckedCreateInput = {
    id?: string
    userId: string
    universityId: string
    courseId: string
    status?: $Enums.ApplicationStatus
    appliedAt?: Date | string
    loanRequired?: boolean
    documents?: UniversityApplicationsCreatedocumentsInput | string[]
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityApplicationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApplicationsNestedInput
    university?: UniversityUpdateOneRequiredWithoutApplicationsNestedInput
    course?: CourseUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type UniversityApplicationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    universityId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityApplicationsCreateManyInput = {
    id?: string
    userId: string
    universityId: string
    courseId: string
    status?: $Enums.ApplicationStatus
    appliedAt?: Date | string
    loanRequired?: boolean
    documents?: UniversityApplicationsCreatedocumentsInput | string[]
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityApplicationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityApplicationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    universityId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationCreateInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    landlord: UserCreateNestedOneWithoutAccommodationsInput
    reviews?: AccommodationReviewCreateNestedManyWithoutAccommodationInput
    ratings?: AccommodationRatingCreateNestedManyWithoutAccommodationInput
    likedBy?: LikedAccommodationsCreateNestedManyWithoutAccommodationInput
    pricingPlans?: PricingPlanCreateNestedManyWithoutAccommodationInput
  }

  export type AccommodationUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    landlordId: string
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: AccommodationReviewUncheckedCreateNestedManyWithoutAccommodationInput
    ratings?: AccommodationRatingUncheckedCreateNestedManyWithoutAccommodationInput
    likedBy?: LikedAccommodationsUncheckedCreateNestedManyWithoutAccommodationInput
    pricingPlans?: PricingPlanUncheckedCreateNestedManyWithoutAccommodationInput
  }

  export type AccommodationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    landlord?: UserUpdateOneRequiredWithoutAccommodationsNestedInput
    reviews?: AccommodationReviewUpdateManyWithoutAccommodationNestedInput
    ratings?: AccommodationRatingUpdateManyWithoutAccommodationNestedInput
    likedBy?: LikedAccommodationsUpdateManyWithoutAccommodationNestedInput
    pricingPlans?: PricingPlanUpdateManyWithoutAccommodationNestedInput
  }

  export type AccommodationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    landlordId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: AccommodationReviewUncheckedUpdateManyWithoutAccommodationNestedInput
    ratings?: AccommodationRatingUncheckedUpdateManyWithoutAccommodationNestedInput
    likedBy?: LikedAccommodationsUncheckedUpdateManyWithoutAccommodationNestedInput
    pricingPlans?: PricingPlanUncheckedUpdateManyWithoutAccommodationNestedInput
  }

  export type AccommodationCreateManyInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    landlordId: string
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccommodationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    landlordId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingPlanCreateInput = {
    id?: string
    type: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accommodation: AccommodationCreateNestedOneWithoutPricingPlansInput
  }

  export type PricingPlanUncheckedCreateInput = {
    id?: string
    accommodationId: string
    type: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodation?: AccommodationUpdateOneRequiredWithoutPricingPlansNestedInput
  }

  export type PricingPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingPlanCreateManyInput = {
    id?: string
    accommodationId: string
    type: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationApplicationCreateInput = {
    id?: string
    userId: string
    accommodationId: string
    interestedFrom: Date | string
    interestedTill: Date | string
    numberOfOccupants: number
    additionalNotes?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
  }

  export type AccommodationApplicationUncheckedCreateInput = {
    id?: string
    userId: string
    accommodationId: string
    interestedFrom: Date | string
    interestedTill: Date | string
    numberOfOccupants: number
    additionalNotes?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
  }

  export type AccommodationApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    interestedFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    interestedTill?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfOccupants?: IntFieldUpdateOperationsInput | number
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    interestedFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    interestedTill?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfOccupants?: IntFieldUpdateOperationsInput | number
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationApplicationCreateManyInput = {
    id?: string
    userId: string
    accommodationId: string
    interestedFrom: Date | string
    interestedTill: Date | string
    numberOfOccupants: number
    additionalNotes?: string | null
    status?: $Enums.ApplicationStatus
    createdAt?: Date | string
  }

  export type AccommodationApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    interestedFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    interestedTill?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfOccupants?: IntFieldUpdateOperationsInput | number
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    interestedFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    interestedTill?: DateTimeFieldUpdateOperationsInput | Date | string
    numberOfOccupants?: IntFieldUpdateOperationsInput | number
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationReviewCreateInput = {
    id?: string
    rating: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accommodation: AccommodationCreateNestedOneWithoutReviewsInput
    user: UserCreateNestedOneWithoutAccommodationReviewsInput
  }

  export type AccommodationReviewUncheckedCreateInput = {
    id?: string
    rating: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accommodationId: string
    userId: string
  }

  export type AccommodationReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodation?: AccommodationUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserUpdateOneRequiredWithoutAccommodationReviewsNestedInput
  }

  export type AccommodationReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccommodationReviewCreateManyInput = {
    id?: string
    rating: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accommodationId: string
    userId: string
  }

  export type AccommodationReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    senderId: string
    receiverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    senderId: string
    receiverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowersInput
    following: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowersNestedInput
    following?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateManyInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanCreateInput = {
    id?: string
    title: string
    description: string
    amount: number
    interestRate: number
    duration: number
    eligibilityCriteria?: LoanCreateeligibilityCriteriaInput | string[]
    documents?: LoanCreatedocumentsInput | string[]
    deadline?: Date | string | null
    maxApplications?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    university?: UniversityCreateNestedOneWithoutLoansInput
    applications?: LoanApplicationCreateNestedManyWithoutLoanInput
  }

  export type LoanUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    amount: number
    interestRate: number
    duration: number
    eligibilityCriteria?: LoanCreateeligibilityCriteriaInput | string[]
    documents?: LoanCreatedocumentsInput | string[]
    deadline?: Date | string | null
    maxApplications?: number | null
    isActive?: boolean
    universityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: LoanApplicationUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    eligibilityCriteria?: LoanUpdateeligibilityCriteriaInput | string[]
    documents?: LoanUpdatedocumentsInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxApplications?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    university?: UniversityUpdateOneWithoutLoansNestedInput
    applications?: LoanApplicationUpdateManyWithoutLoanNestedInput
  }

  export type LoanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    eligibilityCriteria?: LoanUpdateeligibilityCriteriaInput | string[]
    documents?: LoanUpdatedocumentsInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxApplications?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: LoanApplicationUncheckedUpdateManyWithoutLoanNestedInput
  }

  export type LoanCreateManyInput = {
    id?: string
    title: string
    description: string
    amount: number
    interestRate: number
    duration: number
    eligibilityCriteria?: LoanCreateeligibilityCriteriaInput | string[]
    documents?: LoanCreatedocumentsInput | string[]
    deadline?: Date | string | null
    maxApplications?: number | null
    isActive?: boolean
    universityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    eligibilityCriteria?: LoanUpdateeligibilityCriteriaInput | string[]
    documents?: LoanUpdatedocumentsInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxApplications?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    eligibilityCriteria?: LoanUpdateeligibilityCriteriaInput | string[]
    documents?: LoanUpdatedocumentsInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxApplications?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationCreateInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    documents?: LoanApplicationCreatedocumentsInput | string[]
    academicInfo: JsonNullValueInput | InputJsonValue
    financialInfo: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanCreateNestedOneWithoutApplicationsInput
    user: UserCreateNestedOneWithoutLoanApplicationsInput
  }

  export type LoanApplicationUncheckedCreateInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    documents?: LoanApplicationCreatedocumentsInput | string[]
    academicInfo: JsonNullValueInput | InputJsonValue
    financialInfo: JsonNullValueInput | InputJsonValue
    notes?: string | null
    loanId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    documents?: LoanApplicationUpdatedocumentsInput | string[]
    academicInfo?: JsonNullValueInput | InputJsonValue
    financialInfo?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanUpdateOneRequiredWithoutApplicationsNestedInput
    user?: UserUpdateOneRequiredWithoutLoanApplicationsNestedInput
  }

  export type LoanApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    documents?: LoanApplicationUpdatedocumentsInput | string[]
    academicInfo?: JsonNullValueInput | InputJsonValue
    financialInfo?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loanId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationCreateManyInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    documents?: LoanApplicationCreatedocumentsInput | string[]
    academicInfo: JsonNullValueInput | InputJsonValue
    financialInfo: JsonNullValueInput | InputJsonValue
    notes?: string | null
    loanId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    documents?: LoanApplicationUpdatedocumentsInput | string[]
    academicInfo?: JsonNullValueInput | InputJsonValue
    financialInfo?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    documents?: LoanApplicationUpdatedocumentsInput | string[]
    academicInfo?: JsonNullValueInput | InputJsonValue
    financialInfo?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loanId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateInput = {
    id?: string
    userId: string
    status: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
    article: ArticleCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateInput = {
    id?: string
    userId: string
    articleId: string
    status: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: ArticleUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    status?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateManyInput = {
    id?: string
    userId: string
    articleId: string
    status: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    status?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedGroupsInput
    events?: EventCreateNestedManyWithoutGroupInput
    articles?: ArticleCreateNestedManyWithoutGroupInput
    forums?: ForumCreateNestedManyWithoutGroupInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    moderators?: UserCreateNestedManyWithoutAdminOfInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    createdById: string
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutGroupInput
    articles?: ArticleUncheckedCreateNestedManyWithoutGroupInput
    forums?: ForumUncheckedCreateNestedManyWithoutGroupInput
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    moderators?: UserUncheckedCreateNestedManyWithoutAdminOfInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    events?: EventUpdateManyWithoutGroupNestedInput
    articles?: ArticleUpdateManyWithoutGroupNestedInput
    forums?: ForumUpdateManyWithoutGroupNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    moderators?: UserUpdateManyWithoutAdminOfNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutGroupNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutGroupNestedInput
    forums?: ForumUncheckedUpdateManyWithoutGroupNestedInput
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    moderators?: UserUncheckedUpdateManyWithoutAdminOfNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    createdById: string
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateInput = {
    id?: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
    group: GroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutGroupMembershipsInput
  }

  export type GroupMemberUncheckedCreateInput = {
    id?: string
    groupId: string
    userId: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
  }

  export type GroupMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
  }

  export type GroupMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyInput = {
    id?: string
    groupId: string
    userId: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
  }

  export type GroupMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    slug: string
    description: string
    date: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    image?: string | null
    location: string
    eventType?: $Enums.EventType
    registrationType?: $Enums.RegistrationType
    totalSlots: number
    registeredSlots?: number
    waitlistSlots?: number | null
    ticketPrice?: number | null
    currency?: string | null
    address?: string | null
    virtualLink?: string | null
    status?: $Enums.EventStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contactBy: UserCreateNestedOneWithoutHostedEventsInput
    group: GroupCreateNestedOneWithoutEventsInput
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description: string
    date: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    image?: string | null
    location: string
    eventType?: $Enums.EventType
    registrationType?: $Enums.RegistrationType
    totalSlots: number
    registeredSlots?: number
    waitlistSlots?: number | null
    ticketPrice?: number | null
    currency?: string | null
    address?: string | null
    virtualLink?: string | null
    contactById: string
    groupId: string
    status?: $Enums.EventStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    registrationType?: EnumRegistrationTypeFieldUpdateOperationsInput | $Enums.RegistrationType
    totalSlots?: IntFieldUpdateOperationsInput | number
    registeredSlots?: IntFieldUpdateOperationsInput | number
    waitlistSlots?: NullableIntFieldUpdateOperationsInput | number | null
    ticketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactBy?: UserUpdateOneRequiredWithoutHostedEventsNestedInput
    group?: GroupUpdateOneRequiredWithoutEventsNestedInput
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    registrationType?: EnumRegistrationTypeFieldUpdateOperationsInput | $Enums.RegistrationType
    totalSlots?: IntFieldUpdateOperationsInput | number
    registeredSlots?: IntFieldUpdateOperationsInput | number
    waitlistSlots?: NullableIntFieldUpdateOperationsInput | number | null
    ticketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    contactById?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    slug: string
    description: string
    date: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    image?: string | null
    location: string
    eventType?: $Enums.EventType
    registrationType?: $Enums.RegistrationType
    totalSlots: number
    registeredSlots?: number
    waitlistSlots?: number | null
    ticketPrice?: number | null
    currency?: string | null
    address?: string | null
    virtualLink?: string | null
    contactById: string
    groupId: string
    status?: $Enums.EventStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    registrationType?: EnumRegistrationTypeFieldUpdateOperationsInput | $Enums.RegistrationType
    totalSlots?: IntFieldUpdateOperationsInput | number
    registeredSlots?: IntFieldUpdateOperationsInput | number
    waitlistSlots?: NullableIntFieldUpdateOperationsInput | number | null
    ticketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    registrationType?: EnumRegistrationTypeFieldUpdateOperationsInput | $Enums.RegistrationType
    totalSlots?: IntFieldUpdateOperationsInput | number
    registeredSlots?: IntFieldUpdateOperationsInput | number
    waitlistSlots?: NullableIntFieldUpdateOperationsInput | number | null
    ticketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    contactById?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationCreateInput = {
    id?: string
    userId: string
    status?: $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    status?: $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumEventRegistrationStatusFieldUpdateOperationsInput | $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumEventRegistrationStatusFieldUpdateOperationsInput | $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    status?: $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumEventRegistrationStatusFieldUpdateOperationsInput | $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumEventRegistrationStatusFieldUpdateOperationsInput | $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCreateInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutForumsInput
    creator: UserCreateNestedOneWithoutCreatedForumsInput
    topics?: ForumTopicCreateNestedManyWithoutForumInput
    forumReplies?: ForumReplyCreateNestedManyWithoutForumInput
  }

  export type ForumUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    groupId: string
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    creatorId: string
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: ForumTopicUncheckedCreateNestedManyWithoutForumInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutForumInput
  }

  export type ForumUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutForumsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedForumsNestedInput
    topics?: ForumTopicUpdateManyWithoutForumNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutForumNestedInput
  }

  export type ForumUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: StringFieldUpdateOperationsInput | string
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    creatorId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: ForumTopicUncheckedUpdateManyWithoutForumNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutForumNestedInput
  }

  export type ForumCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    groupId: string
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    creatorId: string
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: StringFieldUpdateOperationsInput | string
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    creatorId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicCreateInput = {
    id?: string
    title: string
    content: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    forum: ForumCreateNestedOneWithoutTopicsInput
    creator: UserCreateNestedOneWithoutCreatedForumTopicsInput
    posts?: ForumPostCreateNestedManyWithoutTopicInput
    replies?: ForumReplyCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    forumId: string
    creatorId: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: ForumPostUncheckedCreateNestedManyWithoutTopicInput
    replies?: ForumReplyUncheckedCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forum?: ForumUpdateOneRequiredWithoutTopicsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedForumTopicsNestedInput
    posts?: ForumPostUpdateManyWithoutTopicNestedInput
    replies?: ForumReplyUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostUncheckedUpdateManyWithoutTopicNestedInput
    replies?: ForumReplyUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicCreateManyInput = {
    id?: string
    title: string
    content: string
    forumId: string
    creatorId: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumTopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyCreateInput = {
    id?: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    forum: ForumCreateNestedOneWithoutForumRepliesInput
    topic: ForumTopicCreateNestedOneWithoutRepliesInput
    user: UserCreateNestedOneWithoutForumRepliesInput
    reactions?: ForumReplyReactionCreateNestedManyWithoutForumReplyInput
    parentReply?: ForumReplyCreateNestedOneWithoutChildRepliesInput
    childReplies?: ForumReplyCreateNestedManyWithoutParentReplyInput
  }

  export type ForumReplyUncheckedCreateInput = {
    id?: string
    forumId: string
    topicId: string
    userId: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    parentReplyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutForumReplyInput
    childReplies?: ForumReplyUncheckedCreateNestedManyWithoutParentReplyInput
  }

  export type ForumReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forum?: ForumUpdateOneRequiredWithoutForumRepliesNestedInput
    topic?: ForumTopicUpdateOneRequiredWithoutRepliesNestedInput
    user?: UserUpdateOneRequiredWithoutForumRepliesNestedInput
    reactions?: ForumReplyReactionUpdateManyWithoutForumReplyNestedInput
    parentReply?: ForumReplyUpdateOneWithoutChildRepliesNestedInput
    childReplies?: ForumReplyUpdateManyWithoutParentReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ForumReplyReactionUncheckedUpdateManyWithoutForumReplyNestedInput
    childReplies?: ForumReplyUncheckedUpdateManyWithoutParentReplyNestedInput
  }

  export type ForumReplyCreateManyInput = {
    id?: string
    forumId: string
    topicId: string
    userId: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    parentReplyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostCreateInput = {
    id?: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: ForumTopicCreateNestedOneWithoutPostsInput
    creator: UserCreateNestedOneWithoutForumPostsInput
    reactions?: ForumPostReactionCreateNestedManyWithoutForumPostInput
    parentPost?: ForumPostCreateNestedOneWithoutRepliesInput
    replies?: ForumPostCreateNestedManyWithoutParentPostInput
  }

  export type ForumPostUncheckedCreateInput = {
    id?: string
    content: string
    topicId: string
    creatorId: string
    likes?: number
    parentPostId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ForumPostReactionUncheckedCreateNestedManyWithoutForumPostInput
    replies?: ForumPostUncheckedCreateNestedManyWithoutParentPostInput
  }

  export type ForumPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: ForumTopicUpdateOneRequiredWithoutPostsNestedInput
    creator?: UserUpdateOneRequiredWithoutForumPostsNestedInput
    reactions?: ForumPostReactionUpdateManyWithoutForumPostNestedInput
    parentPost?: ForumPostUpdateOneWithoutRepliesNestedInput
    replies?: ForumPostUpdateManyWithoutParentPostNestedInput
  }

  export type ForumPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    parentPostId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ForumPostReactionUncheckedUpdateManyWithoutForumPostNestedInput
    replies?: ForumPostUncheckedUpdateManyWithoutParentPostNestedInput
  }

  export type ForumPostCreateManyInput = {
    id?: string
    content: string
    topicId: string
    creatorId: string
    likes?: number
    parentPostId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    parentPostId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyReactionCreateInput = {
    id?: string
    type: $Enums.ReactionType
    forumReply: ForumReplyCreateNestedOneWithoutReactionsInput
    user: UserCreateNestedOneWithoutForumReplyReactionsInput
  }

  export type ForumReplyReactionUncheckedCreateInput = {
    id?: string
    forumReplyId: string
    userId: string
    type: $Enums.ReactionType
  }

  export type ForumReplyReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    forumReply?: ForumReplyUpdateOneRequiredWithoutReactionsNestedInput
    user?: UserUpdateOneRequiredWithoutForumReplyReactionsNestedInput
  }

  export type ForumReplyReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumReplyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ForumReplyReactionCreateManyInput = {
    id?: string
    forumReplyId: string
    userId: string
    type: $Enums.ReactionType
  }

  export type ForumReplyReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ForumReplyReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumReplyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ForumPostReactionCreateInput = {
    id?: string
    type: $Enums.ReactionType
    forumPost: ForumPostCreateNestedOneWithoutReactionsInput
    user: UserCreateNestedOneWithoutForumPostReactionsInput
  }

  export type ForumPostReactionUncheckedCreateInput = {
    id?: string
    forumPostId: string
    userId: string
    type: $Enums.ReactionType
  }

  export type ForumPostReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    forumPost?: ForumPostUpdateOneRequiredWithoutReactionsNestedInput
    user?: UserUpdateOneRequiredWithoutForumPostReactionsNestedInput
  }

  export type ForumPostReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumPostId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ForumPostReactionCreateManyInput = {
    id?: string
    forumPostId: string
    userId: string
    type: $Enums.ReactionType
  }

  export type ForumPostReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ForumPostReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumPostId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ArticleCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    bannerImg?: string | null
    images?: ArticleCreateimagesInput | string[]
    tags?: ArticleCreatetagsInput | string[]
    type?: $Enums.ArticleType
    status?: $Enums.ArticleStatus
    upVotes?: number
    downVotes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutArticlesInput
    group?: GroupCreateNestedOneWithoutArticlesInput
    votes?: VoteCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    bannerImg?: string | null
    images?: ArticleCreateimagesInput | string[]
    tags?: ArticleCreatetagsInput | string[]
    type?: $Enums.ArticleType
    status?: $Enums.ArticleStatus
    creatorId: string
    groupId?: string | null
    upVotes?: number
    downVotes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    bannerImg?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleUpdateimagesInput | string[]
    tags?: ArticleUpdatetagsInput | string[]
    type?: EnumArticleTypeFieldUpdateOperationsInput | $Enums.ArticleType
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    upVotes?: IntFieldUpdateOperationsInput | number
    downVotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutArticlesNestedInput
    group?: GroupUpdateOneWithoutArticlesNestedInput
    votes?: VoteUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    bannerImg?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleUpdateimagesInput | string[]
    tags?: ArticleUpdatetagsInput | string[]
    type?: EnumArticleTypeFieldUpdateOperationsInput | $Enums.ArticleType
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    upVotes?: IntFieldUpdateOperationsInput | number
    downVotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    bannerImg?: string | null
    images?: ArticleCreateimagesInput | string[]
    tags?: ArticleCreatetagsInput | string[]
    type?: $Enums.ArticleType
    status?: $Enums.ArticleStatus
    creatorId: string
    groupId?: string | null
    upVotes?: number
    downVotes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    bannerImg?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleUpdateimagesInput | string[]
    tags?: ArticleUpdatetagsInput | string[]
    type?: EnumArticleTypeFieldUpdateOperationsInput | $Enums.ArticleType
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    upVotes?: IntFieldUpdateOperationsInput | number
    downVotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    bannerImg?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleUpdateimagesInput | string[]
    tags?: ArticleUpdatetagsInput | string[]
    type?: EnumArticleTypeFieldUpdateOperationsInput | $Enums.ArticleType
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    upVotes?: IntFieldUpdateOperationsInput | number
    downVotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    refreshToken?: string | null
    expires: Date | string
    lastActivity?: Date | string | null
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    sessionToken: string
    refreshToken?: string | null
    expires: Date | string
    lastActivity?: Date | string | null
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    sessionToken: string
    refreshToken?: string | null
    expires: Date | string
    lastActivity?: Date | string | null
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavCourseCreateInput = {
    id?: string
    universityId?: string | null
    universityName?: string | null
    courseName?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavCoursesInput
    course: CourseCreateNestedOneWithoutFavByUsersInput
  }

  export type FavCourseUncheckedCreateInput = {
    id?: string
    userId: string
    universityId?: string | null
    universityName?: string | null
    courseName?: string | null
    courseId: string
    createdAt?: Date | string
  }

  export type FavCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    universityName?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutFavByUsersNestedInput
  }

  export type FavCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    universityName?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavCourseCreateManyInput = {
    id?: string
    userId: string
    universityId?: string | null
    universityName?: string | null
    courseName?: string | null
    courseId: string
    createdAt?: Date | string
  }

  export type FavCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    universityName?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    universityName?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAnswerCreateInput = {
    questionId: number
    answer: string
    user: UserCreateNestedOneWithoutQuizAnswersInput
  }

  export type QuizAnswerUncheckedCreateInput = {
    id?: number
    userId: string
    questionId: number
    answer: string
  }

  export type QuizAnswerUpdateInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutQuizAnswersNestedInput
  }

  export type QuizAnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type QuizAnswerCreateManyInput = {
    id?: number
    userId: string
    questionId: number
    answer: string
  }

  export type QuizAnswerUpdateManyMutationInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type QuizAnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type LikedAccommodationsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLikedAccommodationsInput
    accommodation: AccommodationCreateNestedOneWithoutLikedByInput
  }

  export type LikedAccommodationsUncheckedCreateInput = {
    id?: string
    userId: string
    accommodationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikedAccommodationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedAccommodationsNestedInput
    accommodation?: AccommodationUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type LikedAccommodationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedAccommodationsCreateManyInput = {
    id?: string
    userId: string
    accommodationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikedAccommodationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedAccommodationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    createdAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutTokensInput
  }

  export type TokenUncheckedCreateInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    userId: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type TokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTokensNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateManyInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    userId: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type TokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPCreateInput = {
    id?: string
    otpCode: string
    type: $Enums.OTPType
    purpose: $Enums.OTPPurpose
    verified?: boolean
    attempts?: number
    expiresAt: Date | string
    verifiedAt?: Date | string | null
    invalidated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOtpsInput
  }

  export type OTPUncheckedCreateInput = {
    id?: string
    userId: string
    otpCode: string
    type: $Enums.OTPType
    purpose: $Enums.OTPPurpose
    verified?: boolean
    attempts?: number
    expiresAt: Date | string
    verifiedAt?: Date | string | null
    invalidated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    type?: EnumOTPTypeFieldUpdateOperationsInput | $Enums.OTPType
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    verified?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invalidated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOtpsNestedInput
  }

  export type OTPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    type?: EnumOTPTypeFieldUpdateOperationsInput | $Enums.OTPType
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    verified?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invalidated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPCreateManyInput = {
    id?: string
    userId: string
    otpCode: string
    type: $Enums.OTPType
    purpose: $Enums.OTPPurpose
    verified?: boolean
    attempts?: number
    expiresAt: Date | string
    verifiedAt?: Date | string | null
    invalidated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    type?: EnumOTPTypeFieldUpdateOperationsInput | $Enums.OTPType
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    verified?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invalidated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    type?: EnumOTPTypeFieldUpdateOperationsInput | $Enums.OTPType
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    verified?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invalidated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCreateInput = {
    id?: string
    title: string
    slug: string
    summary: string
    coverImage?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contentBlocks?: ContentBlockCreateNestedManyWithoutBlogInput
  }

  export type BlogUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    summary: string
    coverImage?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contentBlocks?: ContentBlockUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentBlocks?: ContentBlockUpdateManyWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentBlocks?: ContentBlockUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type BlogCreateManyInput = {
    id?: string
    title: string
    slug: string
    summary: string
    coverImage?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentBlockCreateInput = {
    id?: string
    type: string
    content: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    blog: BlogCreateNestedOneWithoutContentBlocksInput
  }

  export type ContentBlockUncheckedCreateInput = {
    id?: string
    type: string
    content: string
    order: number
    blogId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentBlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutContentBlocksNestedInput
  }

  export type ContentBlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    blogId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentBlockCreateManyInput = {
    id?: string
    type: string
    content: string
    order: number
    blogId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentBlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentBlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    blogId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId: string
    details: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccommodationScalarRelationFilter = {
    is?: AccommodationWhereInput
    isNot?: AccommodationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccommodationRatingUserIdAccommodationIdCompoundUniqueInput = {
    userId: string
    accommodationId: string
  }

  export type AccommodationRatingCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccommodationRatingAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type AccommodationRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccommodationRatingMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccommodationRatingSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UniversityScalarRelationFilter = {
    is?: UniversityWhereInput
    isNot?: UniversityWhereInput
  }

  export type CareerOutcomeCountOrderByAggregateInput = {
    id?: SortOrder
    iconName?: SortOrder
    iconImage?: SortOrder
    title?: SortOrder
    value?: SortOrder
    description?: SortOrder
    details?: SortOrder
    color?: SortOrder
    bgColor?: SortOrder
    universityId?: SortOrder
  }

  export type CareerOutcomeMaxOrderByAggregateInput = {
    id?: SortOrder
    iconName?: SortOrder
    iconImage?: SortOrder
    title?: SortOrder
    value?: SortOrder
    description?: SortOrder
    details?: SortOrder
    color?: SortOrder
    bgColor?: SortOrder
    universityId?: SortOrder
  }

  export type CareerOutcomeMinOrderByAggregateInput = {
    id?: SortOrder
    iconName?: SortOrder
    iconImage?: SortOrder
    title?: SortOrder
    value?: SortOrder
    description?: SortOrder
    details?: SortOrder
    color?: SortOrder
    bgColor?: SortOrder
    universityId?: SortOrder
  }

  export type FaqCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    universityId?: SortOrder
  }

  export type FaqMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    universityId?: SortOrder
  }

  export type FaqMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    universityId?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CareerOutcomeListRelationFilter = {
    every?: CareerOutcomeWhereInput
    some?: CareerOutcomeWhereInput
    none?: CareerOutcomeWhereInput
  }

  export type FaqListRelationFilter = {
    every?: FaqWhereInput
    some?: FaqWhereInput
    none?: FaqWhereInput
  }

  export type UniversityApplicationsListRelationFilter = {
    every?: UniversityApplicationsWhereInput
    some?: UniversityApplicationsWhereInput
    none?: UniversityApplicationsWhereInput
  }

  export type LoanListRelationFilter = {
    every?: LoanWhereInput
    some?: LoanWhereInput
    none?: LoanWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type CareerOutcomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FaqOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UniversityApplicationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UniversityCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    country?: SortOrder
    website?: SortOrder
    established?: SortOrder
    banner?: SortOrder
    logoUrl?: SortOrder
    youtubeLink?: SortOrder
    imageUrls?: SortOrder
    facilities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UniversityMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    country?: SortOrder
    website?: SortOrder
    established?: SortOrder
    banner?: SortOrder
    logoUrl?: SortOrder
    youtubeLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UniversityMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    country?: SortOrder
    website?: SortOrder
    established?: SortOrder
    banner?: SortOrder
    logoUrl?: SortOrder
    youtubeLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FavCourseListRelationFilter = {
    every?: FavCourseWhereInput
    some?: FavCourseWhereInput
    none?: FavCourseWhereInput
  }

  export type FavCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    fees?: SortOrder
    duration?: SortOrder
    degreeType?: SortOrder
    ieltsScore?: SortOrder
    ranking?: SortOrder
    intake?: SortOrder
    websiteLink?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    fees?: SortOrder
    duration?: SortOrder
    degreeType?: SortOrder
    ieltsScore?: SortOrder
    ranking?: SortOrder
    websiteLink?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    fees?: SortOrder
    duration?: SortOrder
    degreeType?: SortOrder
    ieltsScore?: SortOrder
    ranking?: SortOrder
    websiteLink?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type UniversityApplicationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    universityId?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    loanRequired?: SortOrder
    documents?: SortOrder
    additionalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UniversityApplicationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    universityId?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    loanRequired?: SortOrder
    additionalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UniversityApplicationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    universityId?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    loanRequired?: SortOrder
    additionalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAccommodationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccommodationType | EnumAccommodationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccommodationType[] | ListEnumAccommodationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccommodationType[] | ListEnumAccommodationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccommodationTypeFilter<$PrismaModel> | $Enums.AccommodationType
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumFurnishingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FurnishingType | EnumFurnishingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FurnishingType[] | ListEnumFurnishingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FurnishingType[] | ListEnumFurnishingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFurnishingTypeNullableFilter<$PrismaModel> | $Enums.FurnishingType | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AccommodationReviewListRelationFilter = {
    every?: AccommodationReviewWhereInput
    some?: AccommodationReviewWhereInput
    none?: AccommodationReviewWhereInput
  }

  export type AccommodationRatingListRelationFilter = {
    every?: AccommodationRatingWhereInput
    some?: AccommodationRatingWhereInput
    none?: AccommodationRatingWhereInput
  }

  export type LikedAccommodationsListRelationFilter = {
    every?: LikedAccommodationsWhereInput
    some?: LikedAccommodationsWhereInput
    none?: LikedAccommodationsWhereInput
  }

  export type PricingPlanListRelationFilter = {
    every?: PricingPlanWhereInput
    some?: PricingPlanWhereInput
    none?: PricingPlanWhereInput
  }

  export type AccommodationReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccommodationRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikedAccommodationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PricingPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccommodationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    banner?: SortOrder
    includeBills?: SortOrder
    deposit?: SortOrder
    furnishing?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    size?: SortOrder
    amenities?: SortOrder
    rules?: SortOrder
    images?: SortOrder
    availableFrom?: SortOrder
    minTerm?: SortOrder
    maxTerm?: SortOrder
    isAvailable?: SortOrder
    landlordId?: SortOrder
    averageRating?: SortOrder
    totalRatings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccommodationAvgOrderByAggregateInput = {
    deposit?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    size?: SortOrder
    minTerm?: SortOrder
    maxTerm?: SortOrder
    averageRating?: SortOrder
    totalRatings?: SortOrder
  }

  export type AccommodationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    banner?: SortOrder
    includeBills?: SortOrder
    deposit?: SortOrder
    furnishing?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    size?: SortOrder
    availableFrom?: SortOrder
    minTerm?: SortOrder
    maxTerm?: SortOrder
    isAvailable?: SortOrder
    landlordId?: SortOrder
    averageRating?: SortOrder
    totalRatings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccommodationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    banner?: SortOrder
    includeBills?: SortOrder
    deposit?: SortOrder
    furnishing?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    size?: SortOrder
    availableFrom?: SortOrder
    minTerm?: SortOrder
    maxTerm?: SortOrder
    isAvailable?: SortOrder
    landlordId?: SortOrder
    averageRating?: SortOrder
    totalRatings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccommodationSumOrderByAggregateInput = {
    deposit?: SortOrder
    bathrooms?: SortOrder
    bedrooms?: SortOrder
    size?: SortOrder
    minTerm?: SortOrder
    maxTerm?: SortOrder
    averageRating?: SortOrder
    totalRatings?: SortOrder
  }

  export type EnumAccommodationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccommodationType | EnumAccommodationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccommodationType[] | ListEnumAccommodationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccommodationType[] | ListEnumAccommodationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccommodationTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccommodationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccommodationTypeFilter<$PrismaModel>
    _max?: NestedEnumAccommodationTypeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumFurnishingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FurnishingType | EnumFurnishingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FurnishingType[] | ListEnumFurnishingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FurnishingType[] | ListEnumFurnishingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFurnishingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FurnishingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFurnishingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFurnishingTypeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PricingPlanCountOrderByAggregateInput = {
    id?: SortOrder
    accommodationId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingPlanAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PricingPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    accommodationId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingPlanMinOrderByAggregateInput = {
    id?: SortOrder
    accommodationId?: SortOrder
    type?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingPlanSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type AccommodationApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    interestedFrom?: SortOrder
    interestedTill?: SortOrder
    numberOfOccupants?: SortOrder
    additionalNotes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AccommodationApplicationAvgOrderByAggregateInput = {
    numberOfOccupants?: SortOrder
  }

  export type AccommodationApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    interestedFrom?: SortOrder
    interestedTill?: SortOrder
    numberOfOccupants?: SortOrder
    additionalNotes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AccommodationApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    interestedFrom?: SortOrder
    interestedTill?: SortOrder
    numberOfOccupants?: SortOrder
    additionalNotes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AccommodationApplicationSumOrderByAggregateInput = {
    numberOfOccupants?: SortOrder
  }

  export type AccommodationReviewCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accommodationId?: SortOrder
    userId?: SortOrder
  }

  export type AccommodationReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type AccommodationReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accommodationId?: SortOrder
    userId?: SortOrder
  }

  export type AccommodationReviewMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accommodationId?: SortOrder
    userId?: SortOrder
  }

  export type AccommodationReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowFollowerIdFollowingIdCompoundUniqueInput = {
    followerId: string
    followingId: string
  }

  export type FollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UniversityNullableScalarRelationFilter = {
    is?: UniversityWhereInput | null
    isNot?: UniversityWhereInput | null
  }

  export type LoanApplicationListRelationFilter = {
    every?: LoanApplicationWhereInput
    some?: LoanApplicationWhereInput
    none?: LoanApplicationWhereInput
  }

  export type LoanApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoanCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    interestRate?: SortOrder
    duration?: SortOrder
    eligibilityCriteria?: SortOrder
    documents?: SortOrder
    deadline?: SortOrder
    maxApplications?: SortOrder
    isActive?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanAvgOrderByAggregateInput = {
    amount?: SortOrder
    interestRate?: SortOrder
    duration?: SortOrder
    maxApplications?: SortOrder
  }

  export type LoanMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    interestRate?: SortOrder
    duration?: SortOrder
    deadline?: SortOrder
    maxApplications?: SortOrder
    isActive?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    interestRate?: SortOrder
    duration?: SortOrder
    deadline?: SortOrder
    maxApplications?: SortOrder
    isActive?: SortOrder
    universityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanSumOrderByAggregateInput = {
    amount?: SortOrder
    interestRate?: SortOrder
    duration?: SortOrder
    maxApplications?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type LoanScalarRelationFilter = {
    is?: LoanWhereInput
    isNot?: LoanWhereInput
  }

  export type LoanApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    documents?: SortOrder
    academicInfo?: SortOrder
    financialInfo?: SortOrder
    notes?: SortOrder
    loanId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    loanId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoanApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    loanId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumVoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeFilter<$PrismaModel> | $Enums.VoteType
  }

  export type ArticleScalarRelationFilter = {
    is?: ArticleWhereInput
    isNot?: ArticleWhereInput
  }

  export type VoteUserIdArticleIdCompoundUniqueInput = {
    userId: string
    articleId: string
  }

  export type VoteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteTypeFilter<$PrismaModel>
    _max?: NestedEnumVoteTypeFilter<$PrismaModel>
  }

  export type EnumGroupPrivacyFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupPrivacy | EnumGroupPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.GroupPrivacy[] | ListEnumGroupPrivacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupPrivacy[] | ListEnumGroupPrivacyFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupPrivacyFilter<$PrismaModel> | $Enums.GroupPrivacy
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type ArticleListRelationFilter = {
    every?: ArticleWhereInput
    some?: ArticleWhereInput
    none?: ArticleWhereInput
  }

  export type ForumListRelationFilter = {
    every?: ForumWhereInput
    some?: ForumWhereInput
    none?: ForumWhereInput
  }

  export type GroupMemberListRelationFilter = {
    every?: GroupMemberWhereInput
    some?: GroupMemberWhereInput
    none?: GroupMemberWhereInput
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    banner?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    privacy?: SortOrder
    followersCount?: SortOrder
    postsCount?: SortOrder
    createdById?: SortOrder
    isPinned?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    followersCount?: SortOrder
    postsCount?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    banner?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    privacy?: SortOrder
    followersCount?: SortOrder
    postsCount?: SortOrder
    createdById?: SortOrder
    isPinned?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    banner?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    privacy?: SortOrder
    followersCount?: SortOrder
    postsCount?: SortOrder
    createdById?: SortOrder
    isPinned?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    followersCount?: SortOrder
    postsCount?: SortOrder
  }

  export type EnumGroupPrivacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupPrivacy | EnumGroupPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.GroupPrivacy[] | ListEnumGroupPrivacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupPrivacy[] | ListEnumGroupPrivacyFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupPrivacyWithAggregatesFilter<$PrismaModel> | $Enums.GroupPrivacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupPrivacyFilter<$PrismaModel>
    _max?: NestedEnumGroupPrivacyFilter<$PrismaModel>
  }

  export type EnumGroupMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupMemberRole | EnumGroupMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupMemberRoleFilter<$PrismaModel> | $Enums.GroupMemberRole
  }

  export type GroupScalarRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type GroupMemberGroupIdUserIdCompoundUniqueInput = {
    groupId: string
    userId: string
  }

  export type GroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type GroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumGroupMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupMemberRole | EnumGroupMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.GroupMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumGroupMemberRoleFilter<$PrismaModel>
  }

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type EnumRegistrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RegistrationType | EnumRegistrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RegistrationType[] | ListEnumRegistrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RegistrationType[] | ListEnumRegistrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRegistrationTypeFilter<$PrismaModel> | $Enums.RegistrationType
  }

  export type EnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus
  }

  export type EventRegistrationListRelationFilter = {
    every?: EventRegistrationWhereInput
    some?: EventRegistrationWhereInput
    none?: EventRegistrationWhereInput
  }

  export type EventRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    image?: SortOrder
    location?: SortOrder
    eventType?: SortOrder
    registrationType?: SortOrder
    totalSlots?: SortOrder
    registeredSlots?: SortOrder
    waitlistSlots?: SortOrder
    ticketPrice?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    virtualLink?: SortOrder
    contactById?: SortOrder
    groupId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    totalSlots?: SortOrder
    registeredSlots?: SortOrder
    waitlistSlots?: SortOrder
    ticketPrice?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    image?: SortOrder
    location?: SortOrder
    eventType?: SortOrder
    registrationType?: SortOrder
    totalSlots?: SortOrder
    registeredSlots?: SortOrder
    waitlistSlots?: SortOrder
    ticketPrice?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    virtualLink?: SortOrder
    contactById?: SortOrder
    groupId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    image?: SortOrder
    location?: SortOrder
    eventType?: SortOrder
    registrationType?: SortOrder
    totalSlots?: SortOrder
    registeredSlots?: SortOrder
    waitlistSlots?: SortOrder
    ticketPrice?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    virtualLink?: SortOrder
    contactById?: SortOrder
    groupId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    totalSlots?: SortOrder
    registeredSlots?: SortOrder
    waitlistSlots?: SortOrder
    ticketPrice?: SortOrder
  }

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type EnumRegistrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RegistrationType | EnumRegistrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RegistrationType[] | ListEnumRegistrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RegistrationType[] | ListEnumRegistrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRegistrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.RegistrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRegistrationTypeFilter<$PrismaModel>
    _max?: NestedEnumRegistrationTypeFilter<$PrismaModel>
  }

  export type EnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventStatusFilter<$PrismaModel>
    _max?: NestedEnumEventStatusFilter<$PrismaModel>
  }

  export type EnumEventRegistrationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventRegistrationStatus | EnumEventRegistrationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventRegistrationStatus[] | ListEnumEventRegistrationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventRegistrationStatus[] | ListEnumEventRegistrationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventRegistrationStatusFilter<$PrismaModel> | $Enums.EventRegistrationStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventRegistrationEventIdUserIdCompoundUniqueInput = {
    eventId: string
    userId: string
  }

  export type EventRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    additionalInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEventRegistrationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventRegistrationStatus | EnumEventRegistrationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventRegistrationStatus[] | ListEnumEventRegistrationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventRegistrationStatus[] | ListEnumEventRegistrationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventRegistrationStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventRegistrationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventRegistrationStatusFilter<$PrismaModel>
    _max?: NestedEnumEventRegistrationStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumForumTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ForumType | EnumForumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ForumType[] | ListEnumForumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForumType[] | ListEnumForumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumForumTypeFilter<$PrismaModel> | $Enums.ForumType
  }

  export type EnumForumPrivacyFilter<$PrismaModel = never> = {
    equals?: $Enums.ForumPrivacy | EnumForumPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.ForumPrivacy[] | ListEnumForumPrivacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForumPrivacy[] | ListEnumForumPrivacyFieldRefInput<$PrismaModel>
    not?: NestedEnumForumPrivacyFilter<$PrismaModel> | $Enums.ForumPrivacy
  }

  export type ForumTopicListRelationFilter = {
    every?: ForumTopicWhereInput
    some?: ForumTopicWhereInput
    none?: ForumTopicWhereInput
  }

  export type ForumReplyListRelationFilter = {
    every?: ForumReplyWhereInput
    some?: ForumReplyWhereInput
    none?: ForumReplyWhereInput
  }

  export type ForumTopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
    privacy?: SortOrder
    attachments?: SortOrder
    creatorId?: SortOrder
    viewCount?: SortOrder
    topicCount?: SortOrder
    replyCount?: SortOrder
    lastReplyAt?: SortOrder
    isLocked?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumAvgOrderByAggregateInput = {
    viewCount?: SortOrder
    topicCount?: SortOrder
    replyCount?: SortOrder
  }

  export type ForumMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
    privacy?: SortOrder
    creatorId?: SortOrder
    viewCount?: SortOrder
    topicCount?: SortOrder
    replyCount?: SortOrder
    lastReplyAt?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    groupId?: SortOrder
    type?: SortOrder
    privacy?: SortOrder
    creatorId?: SortOrder
    viewCount?: SortOrder
    topicCount?: SortOrder
    replyCount?: SortOrder
    lastReplyAt?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumSumOrderByAggregateInput = {
    viewCount?: SortOrder
    topicCount?: SortOrder
    replyCount?: SortOrder
  }

  export type EnumForumTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ForumType | EnumForumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ForumType[] | ListEnumForumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForumType[] | ListEnumForumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumForumTypeWithAggregatesFilter<$PrismaModel> | $Enums.ForumType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumForumTypeFilter<$PrismaModel>
    _max?: NestedEnumForumTypeFilter<$PrismaModel>
  }

  export type EnumForumPrivacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ForumPrivacy | EnumForumPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.ForumPrivacy[] | ListEnumForumPrivacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForumPrivacy[] | ListEnumForumPrivacyFieldRefInput<$PrismaModel>
    not?: NestedEnumForumPrivacyWithAggregatesFilter<$PrismaModel> | $Enums.ForumPrivacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumForumPrivacyFilter<$PrismaModel>
    _max?: NestedEnumForumPrivacyFilter<$PrismaModel>
  }

  export type EnumTopicTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicType | EnumTopicTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicTypeFilter<$PrismaModel> | $Enums.TopicType
  }

  export type EnumTopicStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicStatus | EnumTopicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicStatusFilter<$PrismaModel> | $Enums.TopicStatus
  }

  export type ForumScalarRelationFilter = {
    is?: ForumWhereInput
    isNot?: ForumWhereInput
  }

  export type ForumPostListRelationFilter = {
    every?: ForumPostWhereInput
    some?: ForumPostWhereInput
    none?: ForumPostWhereInput
  }

  export type ForumPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumTopicCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    forumId?: SortOrder
    creatorId?: SortOrder
    type?: SortOrder
    isPinned?: SortOrder
    isClosed?: SortOrder
    viewCount?: SortOrder
    replyCount?: SortOrder
    lastReplyAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumTopicAvgOrderByAggregateInput = {
    viewCount?: SortOrder
    replyCount?: SortOrder
  }

  export type ForumTopicMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    forumId?: SortOrder
    creatorId?: SortOrder
    type?: SortOrder
    isPinned?: SortOrder
    isClosed?: SortOrder
    viewCount?: SortOrder
    replyCount?: SortOrder
    lastReplyAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumTopicMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    forumId?: SortOrder
    creatorId?: SortOrder
    type?: SortOrder
    isPinned?: SortOrder
    isClosed?: SortOrder
    viewCount?: SortOrder
    replyCount?: SortOrder
    lastReplyAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumTopicSumOrderByAggregateInput = {
    viewCount?: SortOrder
    replyCount?: SortOrder
  }

  export type EnumTopicTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicType | EnumTopicTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicTypeWithAggregatesFilter<$PrismaModel> | $Enums.TopicType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTopicTypeFilter<$PrismaModel>
    _max?: NestedEnumTopicTypeFilter<$PrismaModel>
  }

  export type EnumTopicStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicStatus | EnumTopicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicStatusWithAggregatesFilter<$PrismaModel> | $Enums.TopicStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTopicStatusFilter<$PrismaModel>
    _max?: NestedEnumTopicStatusFilter<$PrismaModel>
  }

  export type ForumTopicScalarRelationFilter = {
    is?: ForumTopicWhereInput
    isNot?: ForumTopicWhereInput
  }

  export type ForumReplyReactionListRelationFilter = {
    every?: ForumReplyReactionWhereInput
    some?: ForumReplyReactionWhereInput
    none?: ForumReplyReactionWhereInput
  }

  export type ForumReplyNullableScalarRelationFilter = {
    is?: ForumReplyWhereInput | null
    isNot?: ForumReplyWhereInput | null
  }

  export type ForumReplyReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumReplyCountOrderByAggregateInput = {
    id?: SortOrder
    forumId?: SortOrder
    topicId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    likes?: SortOrder
    parentReplyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumReplyAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type ForumReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    forumId?: SortOrder
    topicId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    parentReplyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumReplyMinOrderByAggregateInput = {
    id?: SortOrder
    forumId?: SortOrder
    topicId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    parentReplyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumReplySumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type ForumPostReactionListRelationFilter = {
    every?: ForumPostReactionWhereInput
    some?: ForumPostReactionWhereInput
    none?: ForumPostReactionWhereInput
  }

  export type ForumPostNullableScalarRelationFilter = {
    is?: ForumPostWhereInput | null
    isNot?: ForumPostWhereInput | null
  }

  export type ForumPostReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumPostCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    topicId?: SortOrder
    creatorId?: SortOrder
    likes?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type ForumPostMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    topicId?: SortOrder
    creatorId?: SortOrder
    likes?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    topicId?: SortOrder
    creatorId?: SortOrder
    likes?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostSumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type EnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type ForumReplyScalarRelationFilter = {
    is?: ForumReplyWhereInput
    isNot?: ForumReplyWhereInput
  }

  export type ForumReplyReactionForumReplyIdUserIdTypeCompoundUniqueInput = {
    forumReplyId: string
    userId: string
    type: $Enums.ReactionType
  }

  export type ForumReplyReactionCountOrderByAggregateInput = {
    id?: SortOrder
    forumReplyId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
  }

  export type ForumReplyReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    forumReplyId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
  }

  export type ForumReplyReactionMinOrderByAggregateInput = {
    id?: SortOrder
    forumReplyId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
  }

  export type EnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type ForumPostScalarRelationFilter = {
    is?: ForumPostWhereInput
    isNot?: ForumPostWhereInput
  }

  export type ForumPostReactionForumPostIdUserIdTypeCompoundUniqueInput = {
    forumPostId: string
    userId: string
    type: $Enums.ReactionType
  }

  export type ForumPostReactionCountOrderByAggregateInput = {
    id?: SortOrder
    forumPostId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
  }

  export type ForumPostReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    forumPostId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
  }

  export type ForumPostReactionMinOrderByAggregateInput = {
    id?: SortOrder
    forumPostId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
  }

  export type EnumArticleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleType | EnumArticleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleType[] | ListEnumArticleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArticleType[] | ListEnumArticleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArticleTypeFilter<$PrismaModel> | $Enums.ArticleType
  }

  export type EnumArticleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleStatus | EnumArticleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArticleStatusFilter<$PrismaModel> | $Enums.ArticleStatus
  }

  export type GroupNullableScalarRelationFilter = {
    is?: GroupWhereInput | null
    isNot?: GroupWhereInput | null
  }

  export type VoteListRelationFilter = {
    every?: VoteWhereInput
    some?: VoteWhereInput
    none?: VoteWhereInput
  }

  export type VoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    bannerImg?: SortOrder
    images?: SortOrder
    tags?: SortOrder
    type?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    groupId?: SortOrder
    upVotes?: SortOrder
    downVotes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleAvgOrderByAggregateInput = {
    upVotes?: SortOrder
    downVotes?: SortOrder
    views?: SortOrder
  }

  export type ArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    bannerImg?: SortOrder
    type?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    groupId?: SortOrder
    upVotes?: SortOrder
    downVotes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    bannerImg?: SortOrder
    type?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    groupId?: SortOrder
    upVotes?: SortOrder
    downVotes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleSumOrderByAggregateInput = {
    upVotes?: SortOrder
    downVotes?: SortOrder
    views?: SortOrder
  }

  export type EnumArticleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleType | EnumArticleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleType[] | ListEnumArticleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArticleType[] | ListEnumArticleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArticleTypeWithAggregatesFilter<$PrismaModel> | $Enums.ArticleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArticleTypeFilter<$PrismaModel>
    _max?: NestedEnumArticleTypeFilter<$PrismaModel>
  }

  export type EnumArticleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleStatus | EnumArticleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArticleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ArticleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArticleStatusFilter<$PrismaModel>
    _max?: NestedEnumArticleStatusFilter<$PrismaModel>
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    refreshToken?: SortOrder
    expires?: SortOrder
    lastActivity?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    refreshToken?: SortOrder
    expires?: SortOrder
    lastActivity?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    refreshToken?: SortOrder
    expires?: SortOrder
    lastActivity?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type FavCourseUserIdCourseIdCompoundUniqueInput = {
    userId: string
    courseId: string
  }

  export type FavCourseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    universityId?: SortOrder
    universityName?: SortOrder
    courseName?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    universityId?: SortOrder
    universityName?: SortOrder
    courseName?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavCourseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    universityId?: SortOrder
    universityName?: SortOrder
    courseName?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type QuizAnswerListRelationFilter = {
    every?: QuizAnswerWhereInput
    some?: QuizAnswerWhereInput
    none?: QuizAnswerWhereInput
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type AccommodationListRelationFilter = {
    every?: AccommodationWhereInput
    some?: AccommodationWhereInput
    none?: AccommodationWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type OTPListRelationFilter = {
    every?: OTPWhereInput
    some?: OTPWhereInput
    none?: OTPWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type QuizAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccommodationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OTPOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    countryCode?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    header?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    banner?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    googleId?: SortOrder
    googleAccessToken?: SortOrder
    googleRefreshToken?: SortOrder
    googleTokenExpiry?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordExpiry?: SortOrder
    lastPasswordChangeAt?: SortOrder
    isVerified?: SortOrder
    isPhoneVerified?: SortOrder
    isEmailVerified?: SortOrder
    otpRetryCount?: SortOrder
    otpLastSentAt?: SortOrder
    otpBlockedUntil?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    universityId?: SortOrder
    department?: SortOrder
    program?: SortOrder
    graduationYear?: SortOrder
    lastLoginAt?: SortOrder
    loginAttempts?: SortOrder
    isLocked?: SortOrder
    lockUntil?: SortOrder
    isLandlordVerified?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    otpRetryCount?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    graduationYear?: SortOrder
    loginAttempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    countryCode?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    header?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    banner?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    googleId?: SortOrder
    googleAccessToken?: SortOrder
    googleRefreshToken?: SortOrder
    googleTokenExpiry?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordExpiry?: SortOrder
    lastPasswordChangeAt?: SortOrder
    isVerified?: SortOrder
    isPhoneVerified?: SortOrder
    isEmailVerified?: SortOrder
    otpRetryCount?: SortOrder
    otpLastSentAt?: SortOrder
    otpBlockedUntil?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    universityId?: SortOrder
    department?: SortOrder
    program?: SortOrder
    graduationYear?: SortOrder
    lastLoginAt?: SortOrder
    loginAttempts?: SortOrder
    isLocked?: SortOrder
    lockUntil?: SortOrder
    isLandlordVerified?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    countryCode?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    header?: SortOrder
    bio?: SortOrder
    avatarUrl?: SortOrder
    banner?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    googleId?: SortOrder
    googleAccessToken?: SortOrder
    googleRefreshToken?: SortOrder
    googleTokenExpiry?: SortOrder
    resetPasswordToken?: SortOrder
    resetPasswordExpiry?: SortOrder
    lastPasswordChangeAt?: SortOrder
    isVerified?: SortOrder
    isPhoneVerified?: SortOrder
    isEmailVerified?: SortOrder
    otpRetryCount?: SortOrder
    otpLastSentAt?: SortOrder
    otpBlockedUntil?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    universityId?: SortOrder
    department?: SortOrder
    program?: SortOrder
    graduationYear?: SortOrder
    lastLoginAt?: SortOrder
    loginAttempts?: SortOrder
    isLocked?: SortOrder
    lockUntil?: SortOrder
    isLandlordVerified?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    otpRetryCount?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    graduationYear?: SortOrder
    loginAttempts?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type QuizAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
  }

  export type QuizAnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type QuizAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
  }

  export type QuizAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
  }

  export type QuizAnswerSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type LikedAccommodationsUserIdAccommodationIdCompoundUniqueInput = {
    userId: string
    accommodationId: string
  }

  export type LikedAccommodationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LikedAccommodationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LikedAccommodationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accommodationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeFilter<$PrismaModel> | $Enums.TokenType
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.TokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumTokenTypeFilter<$PrismaModel>
  }

  export type EnumOTPTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPType | EnumOTPTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPTypeFilter<$PrismaModel> | $Enums.OTPType
  }

  export type EnumOTPPurposeFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPPurpose | EnumOTPPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPPurposeFilter<$PrismaModel> | $Enums.OTPPurpose
  }

  export type OTPCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otpCode?: SortOrder
    type?: SortOrder
    purpose?: SortOrder
    verified?: SortOrder
    attempts?: SortOrder
    expiresAt?: SortOrder
    verifiedAt?: SortOrder
    invalidated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTPAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type OTPMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otpCode?: SortOrder
    type?: SortOrder
    purpose?: SortOrder
    verified?: SortOrder
    attempts?: SortOrder
    expiresAt?: SortOrder
    verifiedAt?: SortOrder
    invalidated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTPMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otpCode?: SortOrder
    type?: SortOrder
    purpose?: SortOrder
    verified?: SortOrder
    attempts?: SortOrder
    expiresAt?: SortOrder
    verifiedAt?: SortOrder
    invalidated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTPSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type EnumOTPTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPType | EnumOTPTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPTypeWithAggregatesFilter<$PrismaModel> | $Enums.OTPType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOTPTypeFilter<$PrismaModel>
    _max?: NestedEnumOTPTypeFilter<$PrismaModel>
  }

  export type EnumOTPPurposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPPurpose | EnumOTPPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPPurposeWithAggregatesFilter<$PrismaModel> | $Enums.OTPPurpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOTPPurposeFilter<$PrismaModel>
    _max?: NestedEnumOTPPurposeFilter<$PrismaModel>
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type ContentBlockListRelationFilter = {
    every?: ContentBlockWhereInput
    some?: ContentBlockWhereInput
    none?: ContentBlockWhereInput
  }

  export type ContentBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    coverImage?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    coverImage?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    coverImage?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BlogScalarRelationFilter = {
    is?: BlogWhereInput
    isNot?: BlogWhereInput
  }

  export type ContentBlockCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    blogId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentBlockAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ContentBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    blogId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentBlockMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    blogId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentBlockSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccommodationRatingsInput = {
    create?: XOR<UserCreateWithoutAccommodationRatingsInput, UserUncheckedCreateWithoutAccommodationRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccommodationRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type AccommodationCreateNestedOneWithoutRatingsInput = {
    create?: XOR<AccommodationCreateWithoutRatingsInput, AccommodationUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: AccommodationCreateOrConnectWithoutRatingsInput
    connect?: AccommodationWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutAccommodationRatingsNestedInput = {
    create?: XOR<UserCreateWithoutAccommodationRatingsInput, UserUncheckedCreateWithoutAccommodationRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccommodationRatingsInput
    upsert?: UserUpsertWithoutAccommodationRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccommodationRatingsInput, UserUpdateWithoutAccommodationRatingsInput>, UserUncheckedUpdateWithoutAccommodationRatingsInput>
  }

  export type AccommodationUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<AccommodationCreateWithoutRatingsInput, AccommodationUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: AccommodationCreateOrConnectWithoutRatingsInput
    upsert?: AccommodationUpsertWithoutRatingsInput
    connect?: AccommodationWhereUniqueInput
    update?: XOR<XOR<AccommodationUpdateToOneWithWhereWithoutRatingsInput, AccommodationUpdateWithoutRatingsInput>, AccommodationUncheckedUpdateWithoutRatingsInput>
  }

  export type UniversityCreateNestedOneWithoutCareerOutcomesInput = {
    create?: XOR<UniversityCreateWithoutCareerOutcomesInput, UniversityUncheckedCreateWithoutCareerOutcomesInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutCareerOutcomesInput
    connect?: UniversityWhereUniqueInput
  }

  export type UniversityUpdateOneRequiredWithoutCareerOutcomesNestedInput = {
    create?: XOR<UniversityCreateWithoutCareerOutcomesInput, UniversityUncheckedCreateWithoutCareerOutcomesInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutCareerOutcomesInput
    upsert?: UniversityUpsertWithoutCareerOutcomesInput
    connect?: UniversityWhereUniqueInput
    update?: XOR<XOR<UniversityUpdateToOneWithWhereWithoutCareerOutcomesInput, UniversityUpdateWithoutCareerOutcomesInput>, UniversityUncheckedUpdateWithoutCareerOutcomesInput>
  }

  export type UniversityCreateNestedOneWithoutFaqsInput = {
    create?: XOR<UniversityCreateWithoutFaqsInput, UniversityUncheckedCreateWithoutFaqsInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutFaqsInput
    connect?: UniversityWhereUniqueInput
  }

  export type UniversityUpdateOneRequiredWithoutFaqsNestedInput = {
    create?: XOR<UniversityCreateWithoutFaqsInput, UniversityUncheckedCreateWithoutFaqsInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutFaqsInput
    upsert?: UniversityUpsertWithoutFaqsInput
    connect?: UniversityWhereUniqueInput
    update?: XOR<XOR<UniversityUpdateToOneWithWhereWithoutFaqsInput, UniversityUpdateWithoutFaqsInput>, UniversityUncheckedUpdateWithoutFaqsInput>
  }

  export type UniversityCreateimageUrlsInput = {
    set: string[]
  }

  export type UniversityCreatefacilitiesInput = {
    set: string[]
  }

  export type CareerOutcomeCreateNestedManyWithoutUniversityInput = {
    create?: XOR<CareerOutcomeCreateWithoutUniversityInput, CareerOutcomeUncheckedCreateWithoutUniversityInput> | CareerOutcomeCreateWithoutUniversityInput[] | CareerOutcomeUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: CareerOutcomeCreateOrConnectWithoutUniversityInput | CareerOutcomeCreateOrConnectWithoutUniversityInput[]
    createMany?: CareerOutcomeCreateManyUniversityInputEnvelope
    connect?: CareerOutcomeWhereUniqueInput | CareerOutcomeWhereUniqueInput[]
  }

  export type FaqCreateNestedManyWithoutUniversityInput = {
    create?: XOR<FaqCreateWithoutUniversityInput, FaqUncheckedCreateWithoutUniversityInput> | FaqCreateWithoutUniversityInput[] | FaqUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: FaqCreateOrConnectWithoutUniversityInput | FaqCreateOrConnectWithoutUniversityInput[]
    createMany?: FaqCreateManyUniversityInputEnvelope
    connect?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
  }

  export type UniversityApplicationsCreateNestedManyWithoutUniversityInput = {
    create?: XOR<UniversityApplicationsCreateWithoutUniversityInput, UniversityApplicationsUncheckedCreateWithoutUniversityInput> | UniversityApplicationsCreateWithoutUniversityInput[] | UniversityApplicationsUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: UniversityApplicationsCreateOrConnectWithoutUniversityInput | UniversityApplicationsCreateOrConnectWithoutUniversityInput[]
    createMany?: UniversityApplicationsCreateManyUniversityInputEnvelope
    connect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
  }

  export type LoanCreateNestedManyWithoutUniversityInput = {
    create?: XOR<LoanCreateWithoutUniversityInput, LoanUncheckedCreateWithoutUniversityInput> | LoanCreateWithoutUniversityInput[] | LoanUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: LoanCreateOrConnectWithoutUniversityInput | LoanCreateOrConnectWithoutUniversityInput[]
    createMany?: LoanCreateManyUniversityInputEnvelope
    connect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutUniversityInput = {
    create?: XOR<UserCreateWithoutUniversityInput, UserUncheckedCreateWithoutUniversityInput> | UserCreateWithoutUniversityInput[] | UserUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUniversityInput | UserCreateOrConnectWithoutUniversityInput[]
    createMany?: UserCreateManyUniversityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutUniversityInput = {
    create?: XOR<CourseCreateWithoutUniversityInput, CourseUncheckedCreateWithoutUniversityInput> | CourseCreateWithoutUniversityInput[] | CourseUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUniversityInput | CourseCreateOrConnectWithoutUniversityInput[]
    createMany?: CourseCreateManyUniversityInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CareerOutcomeUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<CareerOutcomeCreateWithoutUniversityInput, CareerOutcomeUncheckedCreateWithoutUniversityInput> | CareerOutcomeCreateWithoutUniversityInput[] | CareerOutcomeUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: CareerOutcomeCreateOrConnectWithoutUniversityInput | CareerOutcomeCreateOrConnectWithoutUniversityInput[]
    createMany?: CareerOutcomeCreateManyUniversityInputEnvelope
    connect?: CareerOutcomeWhereUniqueInput | CareerOutcomeWhereUniqueInput[]
  }

  export type FaqUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<FaqCreateWithoutUniversityInput, FaqUncheckedCreateWithoutUniversityInput> | FaqCreateWithoutUniversityInput[] | FaqUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: FaqCreateOrConnectWithoutUniversityInput | FaqCreateOrConnectWithoutUniversityInput[]
    createMany?: FaqCreateManyUniversityInputEnvelope
    connect?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
  }

  export type UniversityApplicationsUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<UniversityApplicationsCreateWithoutUniversityInput, UniversityApplicationsUncheckedCreateWithoutUniversityInput> | UniversityApplicationsCreateWithoutUniversityInput[] | UniversityApplicationsUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: UniversityApplicationsCreateOrConnectWithoutUniversityInput | UniversityApplicationsCreateOrConnectWithoutUniversityInput[]
    createMany?: UniversityApplicationsCreateManyUniversityInputEnvelope
    connect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
  }

  export type LoanUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<LoanCreateWithoutUniversityInput, LoanUncheckedCreateWithoutUniversityInput> | LoanCreateWithoutUniversityInput[] | LoanUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: LoanCreateOrConnectWithoutUniversityInput | LoanCreateOrConnectWithoutUniversityInput[]
    createMany?: LoanCreateManyUniversityInputEnvelope
    connect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<UserCreateWithoutUniversityInput, UserUncheckedCreateWithoutUniversityInput> | UserCreateWithoutUniversityInput[] | UserUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUniversityInput | UserCreateOrConnectWithoutUniversityInput[]
    createMany?: UserCreateManyUniversityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutUniversityInput = {
    create?: XOR<CourseCreateWithoutUniversityInput, CourseUncheckedCreateWithoutUniversityInput> | CourseCreateWithoutUniversityInput[] | CourseUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUniversityInput | CourseCreateOrConnectWithoutUniversityInput[]
    createMany?: CourseCreateManyUniversityInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UniversityUpdateimageUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UniversityUpdatefacilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CareerOutcomeUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<CareerOutcomeCreateWithoutUniversityInput, CareerOutcomeUncheckedCreateWithoutUniversityInput> | CareerOutcomeCreateWithoutUniversityInput[] | CareerOutcomeUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: CareerOutcomeCreateOrConnectWithoutUniversityInput | CareerOutcomeCreateOrConnectWithoutUniversityInput[]
    upsert?: CareerOutcomeUpsertWithWhereUniqueWithoutUniversityInput | CareerOutcomeUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: CareerOutcomeCreateManyUniversityInputEnvelope
    set?: CareerOutcomeWhereUniqueInput | CareerOutcomeWhereUniqueInput[]
    disconnect?: CareerOutcomeWhereUniqueInput | CareerOutcomeWhereUniqueInput[]
    delete?: CareerOutcomeWhereUniqueInput | CareerOutcomeWhereUniqueInput[]
    connect?: CareerOutcomeWhereUniqueInput | CareerOutcomeWhereUniqueInput[]
    update?: CareerOutcomeUpdateWithWhereUniqueWithoutUniversityInput | CareerOutcomeUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: CareerOutcomeUpdateManyWithWhereWithoutUniversityInput | CareerOutcomeUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: CareerOutcomeScalarWhereInput | CareerOutcomeScalarWhereInput[]
  }

  export type FaqUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<FaqCreateWithoutUniversityInput, FaqUncheckedCreateWithoutUniversityInput> | FaqCreateWithoutUniversityInput[] | FaqUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: FaqCreateOrConnectWithoutUniversityInput | FaqCreateOrConnectWithoutUniversityInput[]
    upsert?: FaqUpsertWithWhereUniqueWithoutUniversityInput | FaqUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: FaqCreateManyUniversityInputEnvelope
    set?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    disconnect?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    delete?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    connect?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    update?: FaqUpdateWithWhereUniqueWithoutUniversityInput | FaqUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: FaqUpdateManyWithWhereWithoutUniversityInput | FaqUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: FaqScalarWhereInput | FaqScalarWhereInput[]
  }

  export type UniversityApplicationsUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<UniversityApplicationsCreateWithoutUniversityInput, UniversityApplicationsUncheckedCreateWithoutUniversityInput> | UniversityApplicationsCreateWithoutUniversityInput[] | UniversityApplicationsUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: UniversityApplicationsCreateOrConnectWithoutUniversityInput | UniversityApplicationsCreateOrConnectWithoutUniversityInput[]
    upsert?: UniversityApplicationsUpsertWithWhereUniqueWithoutUniversityInput | UniversityApplicationsUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: UniversityApplicationsCreateManyUniversityInputEnvelope
    set?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    disconnect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    delete?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    connect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    update?: UniversityApplicationsUpdateWithWhereUniqueWithoutUniversityInput | UniversityApplicationsUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: UniversityApplicationsUpdateManyWithWhereWithoutUniversityInput | UniversityApplicationsUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: UniversityApplicationsScalarWhereInput | UniversityApplicationsScalarWhereInput[]
  }

  export type LoanUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<LoanCreateWithoutUniversityInput, LoanUncheckedCreateWithoutUniversityInput> | LoanCreateWithoutUniversityInput[] | LoanUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: LoanCreateOrConnectWithoutUniversityInput | LoanCreateOrConnectWithoutUniversityInput[]
    upsert?: LoanUpsertWithWhereUniqueWithoutUniversityInput | LoanUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: LoanCreateManyUniversityInputEnvelope
    set?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    disconnect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    delete?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    connect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    update?: LoanUpdateWithWhereUniqueWithoutUniversityInput | LoanUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: LoanUpdateManyWithWhereWithoutUniversityInput | LoanUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: LoanScalarWhereInput | LoanScalarWhereInput[]
  }

  export type UserUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<UserCreateWithoutUniversityInput, UserUncheckedCreateWithoutUniversityInput> | UserCreateWithoutUniversityInput[] | UserUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUniversityInput | UserCreateOrConnectWithoutUniversityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUniversityInput | UserUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: UserCreateManyUniversityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUniversityInput | UserUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUniversityInput | UserUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<CourseCreateWithoutUniversityInput, CourseUncheckedCreateWithoutUniversityInput> | CourseCreateWithoutUniversityInput[] | CourseUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUniversityInput | CourseCreateOrConnectWithoutUniversityInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutUniversityInput | CourseUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: CourseCreateManyUniversityInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutUniversityInput | CourseUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutUniversityInput | CourseUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CareerOutcomeUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<CareerOutcomeCreateWithoutUniversityInput, CareerOutcomeUncheckedCreateWithoutUniversityInput> | CareerOutcomeCreateWithoutUniversityInput[] | CareerOutcomeUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: CareerOutcomeCreateOrConnectWithoutUniversityInput | CareerOutcomeCreateOrConnectWithoutUniversityInput[]
    upsert?: CareerOutcomeUpsertWithWhereUniqueWithoutUniversityInput | CareerOutcomeUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: CareerOutcomeCreateManyUniversityInputEnvelope
    set?: CareerOutcomeWhereUniqueInput | CareerOutcomeWhereUniqueInput[]
    disconnect?: CareerOutcomeWhereUniqueInput | CareerOutcomeWhereUniqueInput[]
    delete?: CareerOutcomeWhereUniqueInput | CareerOutcomeWhereUniqueInput[]
    connect?: CareerOutcomeWhereUniqueInput | CareerOutcomeWhereUniqueInput[]
    update?: CareerOutcomeUpdateWithWhereUniqueWithoutUniversityInput | CareerOutcomeUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: CareerOutcomeUpdateManyWithWhereWithoutUniversityInput | CareerOutcomeUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: CareerOutcomeScalarWhereInput | CareerOutcomeScalarWhereInput[]
  }

  export type FaqUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<FaqCreateWithoutUniversityInput, FaqUncheckedCreateWithoutUniversityInput> | FaqCreateWithoutUniversityInput[] | FaqUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: FaqCreateOrConnectWithoutUniversityInput | FaqCreateOrConnectWithoutUniversityInput[]
    upsert?: FaqUpsertWithWhereUniqueWithoutUniversityInput | FaqUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: FaqCreateManyUniversityInputEnvelope
    set?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    disconnect?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    delete?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    connect?: FaqWhereUniqueInput | FaqWhereUniqueInput[]
    update?: FaqUpdateWithWhereUniqueWithoutUniversityInput | FaqUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: FaqUpdateManyWithWhereWithoutUniversityInput | FaqUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: FaqScalarWhereInput | FaqScalarWhereInput[]
  }

  export type UniversityApplicationsUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<UniversityApplicationsCreateWithoutUniversityInput, UniversityApplicationsUncheckedCreateWithoutUniversityInput> | UniversityApplicationsCreateWithoutUniversityInput[] | UniversityApplicationsUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: UniversityApplicationsCreateOrConnectWithoutUniversityInput | UniversityApplicationsCreateOrConnectWithoutUniversityInput[]
    upsert?: UniversityApplicationsUpsertWithWhereUniqueWithoutUniversityInput | UniversityApplicationsUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: UniversityApplicationsCreateManyUniversityInputEnvelope
    set?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    disconnect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    delete?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    connect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    update?: UniversityApplicationsUpdateWithWhereUniqueWithoutUniversityInput | UniversityApplicationsUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: UniversityApplicationsUpdateManyWithWhereWithoutUniversityInput | UniversityApplicationsUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: UniversityApplicationsScalarWhereInput | UniversityApplicationsScalarWhereInput[]
  }

  export type LoanUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<LoanCreateWithoutUniversityInput, LoanUncheckedCreateWithoutUniversityInput> | LoanCreateWithoutUniversityInput[] | LoanUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: LoanCreateOrConnectWithoutUniversityInput | LoanCreateOrConnectWithoutUniversityInput[]
    upsert?: LoanUpsertWithWhereUniqueWithoutUniversityInput | LoanUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: LoanCreateManyUniversityInputEnvelope
    set?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    disconnect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    delete?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    connect?: LoanWhereUniqueInput | LoanWhereUniqueInput[]
    update?: LoanUpdateWithWhereUniqueWithoutUniversityInput | LoanUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: LoanUpdateManyWithWhereWithoutUniversityInput | LoanUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: LoanScalarWhereInput | LoanScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<UserCreateWithoutUniversityInput, UserUncheckedCreateWithoutUniversityInput> | UserCreateWithoutUniversityInput[] | UserUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUniversityInput | UserCreateOrConnectWithoutUniversityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUniversityInput | UserUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: UserCreateManyUniversityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUniversityInput | UserUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUniversityInput | UserUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutUniversityNestedInput = {
    create?: XOR<CourseCreateWithoutUniversityInput, CourseUncheckedCreateWithoutUniversityInput> | CourseCreateWithoutUniversityInput[] | CourseUncheckedCreateWithoutUniversityInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUniversityInput | CourseCreateOrConnectWithoutUniversityInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutUniversityInput | CourseUpsertWithWhereUniqueWithoutUniversityInput[]
    createMany?: CourseCreateManyUniversityInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutUniversityInput | CourseUpdateWithWhereUniqueWithoutUniversityInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutUniversityInput | CourseUpdateManyWithWhereWithoutUniversityInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseCreateintakeInput = {
    set: string[]
  }

  export type UniversityApplicationsCreateNestedManyWithoutCourseInput = {
    create?: XOR<UniversityApplicationsCreateWithoutCourseInput, UniversityApplicationsUncheckedCreateWithoutCourseInput> | UniversityApplicationsCreateWithoutCourseInput[] | UniversityApplicationsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UniversityApplicationsCreateOrConnectWithoutCourseInput | UniversityApplicationsCreateOrConnectWithoutCourseInput[]
    createMany?: UniversityApplicationsCreateManyCourseInputEnvelope
    connect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
  }

  export type FavCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<FavCourseCreateWithoutCourseInput, FavCourseUncheckedCreateWithoutCourseInput> | FavCourseCreateWithoutCourseInput[] | FavCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FavCourseCreateOrConnectWithoutCourseInput | FavCourseCreateOrConnectWithoutCourseInput[]
    createMany?: FavCourseCreateManyCourseInputEnvelope
    connect?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
  }

  export type UniversityCreateNestedOneWithoutCoursesInput = {
    create?: XOR<UniversityCreateWithoutCoursesInput, UniversityUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutCoursesInput
    connect?: UniversityWhereUniqueInput
  }

  export type UniversityApplicationsUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<UniversityApplicationsCreateWithoutCourseInput, UniversityApplicationsUncheckedCreateWithoutCourseInput> | UniversityApplicationsCreateWithoutCourseInput[] | UniversityApplicationsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UniversityApplicationsCreateOrConnectWithoutCourseInput | UniversityApplicationsCreateOrConnectWithoutCourseInput[]
    createMany?: UniversityApplicationsCreateManyCourseInputEnvelope
    connect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
  }

  export type FavCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<FavCourseCreateWithoutCourseInput, FavCourseUncheckedCreateWithoutCourseInput> | FavCourseCreateWithoutCourseInput[] | FavCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FavCourseCreateOrConnectWithoutCourseInput | FavCourseCreateOrConnectWithoutCourseInput[]
    createMany?: FavCourseCreateManyCourseInputEnvelope
    connect?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
  }

  export type CourseUpdateintakeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UniversityApplicationsUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UniversityApplicationsCreateWithoutCourseInput, UniversityApplicationsUncheckedCreateWithoutCourseInput> | UniversityApplicationsCreateWithoutCourseInput[] | UniversityApplicationsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UniversityApplicationsCreateOrConnectWithoutCourseInput | UniversityApplicationsCreateOrConnectWithoutCourseInput[]
    upsert?: UniversityApplicationsUpsertWithWhereUniqueWithoutCourseInput | UniversityApplicationsUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UniversityApplicationsCreateManyCourseInputEnvelope
    set?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    disconnect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    delete?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    connect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    update?: UniversityApplicationsUpdateWithWhereUniqueWithoutCourseInput | UniversityApplicationsUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UniversityApplicationsUpdateManyWithWhereWithoutCourseInput | UniversityApplicationsUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UniversityApplicationsScalarWhereInput | UniversityApplicationsScalarWhereInput[]
  }

  export type FavCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<FavCourseCreateWithoutCourseInput, FavCourseUncheckedCreateWithoutCourseInput> | FavCourseCreateWithoutCourseInput[] | FavCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FavCourseCreateOrConnectWithoutCourseInput | FavCourseCreateOrConnectWithoutCourseInput[]
    upsert?: FavCourseUpsertWithWhereUniqueWithoutCourseInput | FavCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: FavCourseCreateManyCourseInputEnvelope
    set?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    disconnect?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    delete?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    connect?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    update?: FavCourseUpdateWithWhereUniqueWithoutCourseInput | FavCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: FavCourseUpdateManyWithWhereWithoutCourseInput | FavCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: FavCourseScalarWhereInput | FavCourseScalarWhereInput[]
  }

  export type UniversityUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<UniversityCreateWithoutCoursesInput, UniversityUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutCoursesInput
    upsert?: UniversityUpsertWithoutCoursesInput
    connect?: UniversityWhereUniqueInput
    update?: XOR<XOR<UniversityUpdateToOneWithWhereWithoutCoursesInput, UniversityUpdateWithoutCoursesInput>, UniversityUncheckedUpdateWithoutCoursesInput>
  }

  export type UniversityApplicationsUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UniversityApplicationsCreateWithoutCourseInput, UniversityApplicationsUncheckedCreateWithoutCourseInput> | UniversityApplicationsCreateWithoutCourseInput[] | UniversityApplicationsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UniversityApplicationsCreateOrConnectWithoutCourseInput | UniversityApplicationsCreateOrConnectWithoutCourseInput[]
    upsert?: UniversityApplicationsUpsertWithWhereUniqueWithoutCourseInput | UniversityApplicationsUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UniversityApplicationsCreateManyCourseInputEnvelope
    set?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    disconnect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    delete?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    connect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    update?: UniversityApplicationsUpdateWithWhereUniqueWithoutCourseInput | UniversityApplicationsUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UniversityApplicationsUpdateManyWithWhereWithoutCourseInput | UniversityApplicationsUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UniversityApplicationsScalarWhereInput | UniversityApplicationsScalarWhereInput[]
  }

  export type FavCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<FavCourseCreateWithoutCourseInput, FavCourseUncheckedCreateWithoutCourseInput> | FavCourseCreateWithoutCourseInput[] | FavCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FavCourseCreateOrConnectWithoutCourseInput | FavCourseCreateOrConnectWithoutCourseInput[]
    upsert?: FavCourseUpsertWithWhereUniqueWithoutCourseInput | FavCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: FavCourseCreateManyCourseInputEnvelope
    set?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    disconnect?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    delete?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    connect?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    update?: FavCourseUpdateWithWhereUniqueWithoutCourseInput | FavCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: FavCourseUpdateManyWithWhereWithoutCourseInput | FavCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: FavCourseScalarWhereInput | FavCourseScalarWhereInput[]
  }

  export type UniversityApplicationsCreatedocumentsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type UniversityCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<UniversityCreateWithoutApplicationsInput, UniversityUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutApplicationsInput
    connect?: UniversityWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<CourseCreateWithoutApplicationsInput, CourseUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutApplicationsInput
    connect?: CourseWhereUniqueInput
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UniversityApplicationsUpdatedocumentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    upsert?: UserUpsertWithoutApplicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApplicationsInput, UserUpdateWithoutApplicationsInput>, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type UniversityUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<UniversityCreateWithoutApplicationsInput, UniversityUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutApplicationsInput
    upsert?: UniversityUpsertWithoutApplicationsInput
    connect?: UniversityWhereUniqueInput
    update?: XOR<XOR<UniversityUpdateToOneWithWhereWithoutApplicationsInput, UniversityUpdateWithoutApplicationsInput>, UniversityUncheckedUpdateWithoutApplicationsInput>
  }

  export type CourseUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<CourseCreateWithoutApplicationsInput, CourseUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutApplicationsInput
    upsert?: CourseUpsertWithoutApplicationsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutApplicationsInput, CourseUpdateWithoutApplicationsInput>, CourseUncheckedUpdateWithoutApplicationsInput>
  }

  export type AccommodationCreateamenitiesInput = {
    set: string[]
  }

  export type AccommodationCreaterulesInput = {
    set: string[]
  }

  export type AccommodationCreateimagesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAccommodationsInput = {
    create?: XOR<UserCreateWithoutAccommodationsInput, UserUncheckedCreateWithoutAccommodationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccommodationsInput
    connect?: UserWhereUniqueInput
  }

  export type AccommodationReviewCreateNestedManyWithoutAccommodationInput = {
    create?: XOR<AccommodationReviewCreateWithoutAccommodationInput, AccommodationReviewUncheckedCreateWithoutAccommodationInput> | AccommodationReviewCreateWithoutAccommodationInput[] | AccommodationReviewUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: AccommodationReviewCreateOrConnectWithoutAccommodationInput | AccommodationReviewCreateOrConnectWithoutAccommodationInput[]
    createMany?: AccommodationReviewCreateManyAccommodationInputEnvelope
    connect?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
  }

  export type AccommodationRatingCreateNestedManyWithoutAccommodationInput = {
    create?: XOR<AccommodationRatingCreateWithoutAccommodationInput, AccommodationRatingUncheckedCreateWithoutAccommodationInput> | AccommodationRatingCreateWithoutAccommodationInput[] | AccommodationRatingUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: AccommodationRatingCreateOrConnectWithoutAccommodationInput | AccommodationRatingCreateOrConnectWithoutAccommodationInput[]
    createMany?: AccommodationRatingCreateManyAccommodationInputEnvelope
    connect?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
  }

  export type LikedAccommodationsCreateNestedManyWithoutAccommodationInput = {
    create?: XOR<LikedAccommodationsCreateWithoutAccommodationInput, LikedAccommodationsUncheckedCreateWithoutAccommodationInput> | LikedAccommodationsCreateWithoutAccommodationInput[] | LikedAccommodationsUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: LikedAccommodationsCreateOrConnectWithoutAccommodationInput | LikedAccommodationsCreateOrConnectWithoutAccommodationInput[]
    createMany?: LikedAccommodationsCreateManyAccommodationInputEnvelope
    connect?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
  }

  export type PricingPlanCreateNestedManyWithoutAccommodationInput = {
    create?: XOR<PricingPlanCreateWithoutAccommodationInput, PricingPlanUncheckedCreateWithoutAccommodationInput> | PricingPlanCreateWithoutAccommodationInput[] | PricingPlanUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: PricingPlanCreateOrConnectWithoutAccommodationInput | PricingPlanCreateOrConnectWithoutAccommodationInput[]
    createMany?: PricingPlanCreateManyAccommodationInputEnvelope
    connect?: PricingPlanWhereUniqueInput | PricingPlanWhereUniqueInput[]
  }

  export type AccommodationReviewUncheckedCreateNestedManyWithoutAccommodationInput = {
    create?: XOR<AccommodationReviewCreateWithoutAccommodationInput, AccommodationReviewUncheckedCreateWithoutAccommodationInput> | AccommodationReviewCreateWithoutAccommodationInput[] | AccommodationReviewUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: AccommodationReviewCreateOrConnectWithoutAccommodationInput | AccommodationReviewCreateOrConnectWithoutAccommodationInput[]
    createMany?: AccommodationReviewCreateManyAccommodationInputEnvelope
    connect?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
  }

  export type AccommodationRatingUncheckedCreateNestedManyWithoutAccommodationInput = {
    create?: XOR<AccommodationRatingCreateWithoutAccommodationInput, AccommodationRatingUncheckedCreateWithoutAccommodationInput> | AccommodationRatingCreateWithoutAccommodationInput[] | AccommodationRatingUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: AccommodationRatingCreateOrConnectWithoutAccommodationInput | AccommodationRatingCreateOrConnectWithoutAccommodationInput[]
    createMany?: AccommodationRatingCreateManyAccommodationInputEnvelope
    connect?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
  }

  export type LikedAccommodationsUncheckedCreateNestedManyWithoutAccommodationInput = {
    create?: XOR<LikedAccommodationsCreateWithoutAccommodationInput, LikedAccommodationsUncheckedCreateWithoutAccommodationInput> | LikedAccommodationsCreateWithoutAccommodationInput[] | LikedAccommodationsUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: LikedAccommodationsCreateOrConnectWithoutAccommodationInput | LikedAccommodationsCreateOrConnectWithoutAccommodationInput[]
    createMany?: LikedAccommodationsCreateManyAccommodationInputEnvelope
    connect?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
  }

  export type PricingPlanUncheckedCreateNestedManyWithoutAccommodationInput = {
    create?: XOR<PricingPlanCreateWithoutAccommodationInput, PricingPlanUncheckedCreateWithoutAccommodationInput> | PricingPlanCreateWithoutAccommodationInput[] | PricingPlanUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: PricingPlanCreateOrConnectWithoutAccommodationInput | PricingPlanCreateOrConnectWithoutAccommodationInput[]
    createMany?: PricingPlanCreateManyAccommodationInputEnvelope
    connect?: PricingPlanWhereUniqueInput | PricingPlanWhereUniqueInput[]
  }

  export type EnumAccommodationTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccommodationType
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumFurnishingTypeFieldUpdateOperationsInput = {
    set?: $Enums.FurnishingType | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccommodationUpdateamenitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AccommodationUpdaterulesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AccommodationUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccommodationsNestedInput = {
    create?: XOR<UserCreateWithoutAccommodationsInput, UserUncheckedCreateWithoutAccommodationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccommodationsInput
    upsert?: UserUpsertWithoutAccommodationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccommodationsInput, UserUpdateWithoutAccommodationsInput>, UserUncheckedUpdateWithoutAccommodationsInput>
  }

  export type AccommodationReviewUpdateManyWithoutAccommodationNestedInput = {
    create?: XOR<AccommodationReviewCreateWithoutAccommodationInput, AccommodationReviewUncheckedCreateWithoutAccommodationInput> | AccommodationReviewCreateWithoutAccommodationInput[] | AccommodationReviewUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: AccommodationReviewCreateOrConnectWithoutAccommodationInput | AccommodationReviewCreateOrConnectWithoutAccommodationInput[]
    upsert?: AccommodationReviewUpsertWithWhereUniqueWithoutAccommodationInput | AccommodationReviewUpsertWithWhereUniqueWithoutAccommodationInput[]
    createMany?: AccommodationReviewCreateManyAccommodationInputEnvelope
    set?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    disconnect?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    delete?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    connect?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    update?: AccommodationReviewUpdateWithWhereUniqueWithoutAccommodationInput | AccommodationReviewUpdateWithWhereUniqueWithoutAccommodationInput[]
    updateMany?: AccommodationReviewUpdateManyWithWhereWithoutAccommodationInput | AccommodationReviewUpdateManyWithWhereWithoutAccommodationInput[]
    deleteMany?: AccommodationReviewScalarWhereInput | AccommodationReviewScalarWhereInput[]
  }

  export type AccommodationRatingUpdateManyWithoutAccommodationNestedInput = {
    create?: XOR<AccommodationRatingCreateWithoutAccommodationInput, AccommodationRatingUncheckedCreateWithoutAccommodationInput> | AccommodationRatingCreateWithoutAccommodationInput[] | AccommodationRatingUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: AccommodationRatingCreateOrConnectWithoutAccommodationInput | AccommodationRatingCreateOrConnectWithoutAccommodationInput[]
    upsert?: AccommodationRatingUpsertWithWhereUniqueWithoutAccommodationInput | AccommodationRatingUpsertWithWhereUniqueWithoutAccommodationInput[]
    createMany?: AccommodationRatingCreateManyAccommodationInputEnvelope
    set?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    disconnect?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    delete?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    connect?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    update?: AccommodationRatingUpdateWithWhereUniqueWithoutAccommodationInput | AccommodationRatingUpdateWithWhereUniqueWithoutAccommodationInput[]
    updateMany?: AccommodationRatingUpdateManyWithWhereWithoutAccommodationInput | AccommodationRatingUpdateManyWithWhereWithoutAccommodationInput[]
    deleteMany?: AccommodationRatingScalarWhereInput | AccommodationRatingScalarWhereInput[]
  }

  export type LikedAccommodationsUpdateManyWithoutAccommodationNestedInput = {
    create?: XOR<LikedAccommodationsCreateWithoutAccommodationInput, LikedAccommodationsUncheckedCreateWithoutAccommodationInput> | LikedAccommodationsCreateWithoutAccommodationInput[] | LikedAccommodationsUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: LikedAccommodationsCreateOrConnectWithoutAccommodationInput | LikedAccommodationsCreateOrConnectWithoutAccommodationInput[]
    upsert?: LikedAccommodationsUpsertWithWhereUniqueWithoutAccommodationInput | LikedAccommodationsUpsertWithWhereUniqueWithoutAccommodationInput[]
    createMany?: LikedAccommodationsCreateManyAccommodationInputEnvelope
    set?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    disconnect?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    delete?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    connect?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    update?: LikedAccommodationsUpdateWithWhereUniqueWithoutAccommodationInput | LikedAccommodationsUpdateWithWhereUniqueWithoutAccommodationInput[]
    updateMany?: LikedAccommodationsUpdateManyWithWhereWithoutAccommodationInput | LikedAccommodationsUpdateManyWithWhereWithoutAccommodationInput[]
    deleteMany?: LikedAccommodationsScalarWhereInput | LikedAccommodationsScalarWhereInput[]
  }

  export type PricingPlanUpdateManyWithoutAccommodationNestedInput = {
    create?: XOR<PricingPlanCreateWithoutAccommodationInput, PricingPlanUncheckedCreateWithoutAccommodationInput> | PricingPlanCreateWithoutAccommodationInput[] | PricingPlanUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: PricingPlanCreateOrConnectWithoutAccommodationInput | PricingPlanCreateOrConnectWithoutAccommodationInput[]
    upsert?: PricingPlanUpsertWithWhereUniqueWithoutAccommodationInput | PricingPlanUpsertWithWhereUniqueWithoutAccommodationInput[]
    createMany?: PricingPlanCreateManyAccommodationInputEnvelope
    set?: PricingPlanWhereUniqueInput | PricingPlanWhereUniqueInput[]
    disconnect?: PricingPlanWhereUniqueInput | PricingPlanWhereUniqueInput[]
    delete?: PricingPlanWhereUniqueInput | PricingPlanWhereUniqueInput[]
    connect?: PricingPlanWhereUniqueInput | PricingPlanWhereUniqueInput[]
    update?: PricingPlanUpdateWithWhereUniqueWithoutAccommodationInput | PricingPlanUpdateWithWhereUniqueWithoutAccommodationInput[]
    updateMany?: PricingPlanUpdateManyWithWhereWithoutAccommodationInput | PricingPlanUpdateManyWithWhereWithoutAccommodationInput[]
    deleteMany?: PricingPlanScalarWhereInput | PricingPlanScalarWhereInput[]
  }

  export type AccommodationReviewUncheckedUpdateManyWithoutAccommodationNestedInput = {
    create?: XOR<AccommodationReviewCreateWithoutAccommodationInput, AccommodationReviewUncheckedCreateWithoutAccommodationInput> | AccommodationReviewCreateWithoutAccommodationInput[] | AccommodationReviewUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: AccommodationReviewCreateOrConnectWithoutAccommodationInput | AccommodationReviewCreateOrConnectWithoutAccommodationInput[]
    upsert?: AccommodationReviewUpsertWithWhereUniqueWithoutAccommodationInput | AccommodationReviewUpsertWithWhereUniqueWithoutAccommodationInput[]
    createMany?: AccommodationReviewCreateManyAccommodationInputEnvelope
    set?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    disconnect?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    delete?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    connect?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    update?: AccommodationReviewUpdateWithWhereUniqueWithoutAccommodationInput | AccommodationReviewUpdateWithWhereUniqueWithoutAccommodationInput[]
    updateMany?: AccommodationReviewUpdateManyWithWhereWithoutAccommodationInput | AccommodationReviewUpdateManyWithWhereWithoutAccommodationInput[]
    deleteMany?: AccommodationReviewScalarWhereInput | AccommodationReviewScalarWhereInput[]
  }

  export type AccommodationRatingUncheckedUpdateManyWithoutAccommodationNestedInput = {
    create?: XOR<AccommodationRatingCreateWithoutAccommodationInput, AccommodationRatingUncheckedCreateWithoutAccommodationInput> | AccommodationRatingCreateWithoutAccommodationInput[] | AccommodationRatingUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: AccommodationRatingCreateOrConnectWithoutAccommodationInput | AccommodationRatingCreateOrConnectWithoutAccommodationInput[]
    upsert?: AccommodationRatingUpsertWithWhereUniqueWithoutAccommodationInput | AccommodationRatingUpsertWithWhereUniqueWithoutAccommodationInput[]
    createMany?: AccommodationRatingCreateManyAccommodationInputEnvelope
    set?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    disconnect?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    delete?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    connect?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    update?: AccommodationRatingUpdateWithWhereUniqueWithoutAccommodationInput | AccommodationRatingUpdateWithWhereUniqueWithoutAccommodationInput[]
    updateMany?: AccommodationRatingUpdateManyWithWhereWithoutAccommodationInput | AccommodationRatingUpdateManyWithWhereWithoutAccommodationInput[]
    deleteMany?: AccommodationRatingScalarWhereInput | AccommodationRatingScalarWhereInput[]
  }

  export type LikedAccommodationsUncheckedUpdateManyWithoutAccommodationNestedInput = {
    create?: XOR<LikedAccommodationsCreateWithoutAccommodationInput, LikedAccommodationsUncheckedCreateWithoutAccommodationInput> | LikedAccommodationsCreateWithoutAccommodationInput[] | LikedAccommodationsUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: LikedAccommodationsCreateOrConnectWithoutAccommodationInput | LikedAccommodationsCreateOrConnectWithoutAccommodationInput[]
    upsert?: LikedAccommodationsUpsertWithWhereUniqueWithoutAccommodationInput | LikedAccommodationsUpsertWithWhereUniqueWithoutAccommodationInput[]
    createMany?: LikedAccommodationsCreateManyAccommodationInputEnvelope
    set?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    disconnect?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    delete?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    connect?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    update?: LikedAccommodationsUpdateWithWhereUniqueWithoutAccommodationInput | LikedAccommodationsUpdateWithWhereUniqueWithoutAccommodationInput[]
    updateMany?: LikedAccommodationsUpdateManyWithWhereWithoutAccommodationInput | LikedAccommodationsUpdateManyWithWhereWithoutAccommodationInput[]
    deleteMany?: LikedAccommodationsScalarWhereInput | LikedAccommodationsScalarWhereInput[]
  }

  export type PricingPlanUncheckedUpdateManyWithoutAccommodationNestedInput = {
    create?: XOR<PricingPlanCreateWithoutAccommodationInput, PricingPlanUncheckedCreateWithoutAccommodationInput> | PricingPlanCreateWithoutAccommodationInput[] | PricingPlanUncheckedCreateWithoutAccommodationInput[]
    connectOrCreate?: PricingPlanCreateOrConnectWithoutAccommodationInput | PricingPlanCreateOrConnectWithoutAccommodationInput[]
    upsert?: PricingPlanUpsertWithWhereUniqueWithoutAccommodationInput | PricingPlanUpsertWithWhereUniqueWithoutAccommodationInput[]
    createMany?: PricingPlanCreateManyAccommodationInputEnvelope
    set?: PricingPlanWhereUniqueInput | PricingPlanWhereUniqueInput[]
    disconnect?: PricingPlanWhereUniqueInput | PricingPlanWhereUniqueInput[]
    delete?: PricingPlanWhereUniqueInput | PricingPlanWhereUniqueInput[]
    connect?: PricingPlanWhereUniqueInput | PricingPlanWhereUniqueInput[]
    update?: PricingPlanUpdateWithWhereUniqueWithoutAccommodationInput | PricingPlanUpdateWithWhereUniqueWithoutAccommodationInput[]
    updateMany?: PricingPlanUpdateManyWithWhereWithoutAccommodationInput | PricingPlanUpdateManyWithWhereWithoutAccommodationInput[]
    deleteMany?: PricingPlanScalarWhereInput | PricingPlanScalarWhereInput[]
  }

  export type AccommodationCreateNestedOneWithoutPricingPlansInput = {
    create?: XOR<AccommodationCreateWithoutPricingPlansInput, AccommodationUncheckedCreateWithoutPricingPlansInput>
    connectOrCreate?: AccommodationCreateOrConnectWithoutPricingPlansInput
    connect?: AccommodationWhereUniqueInput
  }

  export type AccommodationUpdateOneRequiredWithoutPricingPlansNestedInput = {
    create?: XOR<AccommodationCreateWithoutPricingPlansInput, AccommodationUncheckedCreateWithoutPricingPlansInput>
    connectOrCreate?: AccommodationCreateOrConnectWithoutPricingPlansInput
    upsert?: AccommodationUpsertWithoutPricingPlansInput
    connect?: AccommodationWhereUniqueInput
    update?: XOR<XOR<AccommodationUpdateToOneWithWhereWithoutPricingPlansInput, AccommodationUpdateWithoutPricingPlansInput>, AccommodationUncheckedUpdateWithoutPricingPlansInput>
  }

  export type AccommodationCreateNestedOneWithoutReviewsInput = {
    create?: XOR<AccommodationCreateWithoutReviewsInput, AccommodationUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: AccommodationCreateOrConnectWithoutReviewsInput
    connect?: AccommodationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAccommodationReviewsInput = {
    create?: XOR<UserCreateWithoutAccommodationReviewsInput, UserUncheckedCreateWithoutAccommodationReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccommodationReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type AccommodationUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<AccommodationCreateWithoutReviewsInput, AccommodationUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: AccommodationCreateOrConnectWithoutReviewsInput
    upsert?: AccommodationUpsertWithoutReviewsInput
    connect?: AccommodationWhereUniqueInput
    update?: XOR<XOR<AccommodationUpdateToOneWithWhereWithoutReviewsInput, AccommodationUpdateWithoutReviewsInput>, AccommodationUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutAccommodationReviewsNestedInput = {
    create?: XOR<UserCreateWithoutAccommodationReviewsInput, UserUncheckedCreateWithoutAccommodationReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccommodationReviewsInput
    upsert?: UserUpsertWithoutAccommodationReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccommodationReviewsInput, UserUpdateWithoutAccommodationReviewsInput>, UserUncheckedUpdateWithoutAccommodationReviewsInput>
  }

  export type MessageCreateattachmentsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingInput, UserUpdateWithoutFollowingInput>, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type LoanCreateeligibilityCriteriaInput = {
    set: string[]
  }

  export type LoanCreatedocumentsInput = {
    set: string[]
  }

  export type UniversityCreateNestedOneWithoutLoansInput = {
    create?: XOR<UniversityCreateWithoutLoansInput, UniversityUncheckedCreateWithoutLoansInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutLoansInput
    connect?: UniversityWhereUniqueInput
  }

  export type LoanApplicationCreateNestedManyWithoutLoanInput = {
    create?: XOR<LoanApplicationCreateWithoutLoanInput, LoanApplicationUncheckedCreateWithoutLoanInput> | LoanApplicationCreateWithoutLoanInput[] | LoanApplicationUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutLoanInput | LoanApplicationCreateOrConnectWithoutLoanInput[]
    createMany?: LoanApplicationCreateManyLoanInputEnvelope
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
  }

  export type LoanApplicationUncheckedCreateNestedManyWithoutLoanInput = {
    create?: XOR<LoanApplicationCreateWithoutLoanInput, LoanApplicationUncheckedCreateWithoutLoanInput> | LoanApplicationCreateWithoutLoanInput[] | LoanApplicationUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutLoanInput | LoanApplicationCreateOrConnectWithoutLoanInput[]
    createMany?: LoanApplicationCreateManyLoanInputEnvelope
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
  }

  export type LoanUpdateeligibilityCriteriaInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LoanUpdatedocumentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UniversityUpdateOneWithoutLoansNestedInput = {
    create?: XOR<UniversityCreateWithoutLoansInput, UniversityUncheckedCreateWithoutLoansInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutLoansInput
    upsert?: UniversityUpsertWithoutLoansInput
    disconnect?: UniversityWhereInput | boolean
    delete?: UniversityWhereInput | boolean
    connect?: UniversityWhereUniqueInput
    update?: XOR<XOR<UniversityUpdateToOneWithWhereWithoutLoansInput, UniversityUpdateWithoutLoansInput>, UniversityUncheckedUpdateWithoutLoansInput>
  }

  export type LoanApplicationUpdateManyWithoutLoanNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutLoanInput, LoanApplicationUncheckedCreateWithoutLoanInput> | LoanApplicationCreateWithoutLoanInput[] | LoanApplicationUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutLoanInput | LoanApplicationCreateOrConnectWithoutLoanInput[]
    upsert?: LoanApplicationUpsertWithWhereUniqueWithoutLoanInput | LoanApplicationUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: LoanApplicationCreateManyLoanInputEnvelope
    set?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    disconnect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    delete?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    update?: LoanApplicationUpdateWithWhereUniqueWithoutLoanInput | LoanApplicationUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: LoanApplicationUpdateManyWithWhereWithoutLoanInput | LoanApplicationUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
  }

  export type LoanApplicationUncheckedUpdateManyWithoutLoanNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutLoanInput, LoanApplicationUncheckedCreateWithoutLoanInput> | LoanApplicationCreateWithoutLoanInput[] | LoanApplicationUncheckedCreateWithoutLoanInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutLoanInput | LoanApplicationCreateOrConnectWithoutLoanInput[]
    upsert?: LoanApplicationUpsertWithWhereUniqueWithoutLoanInput | LoanApplicationUpsertWithWhereUniqueWithoutLoanInput[]
    createMany?: LoanApplicationCreateManyLoanInputEnvelope
    set?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    disconnect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    delete?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    update?: LoanApplicationUpdateWithWhereUniqueWithoutLoanInput | LoanApplicationUpdateWithWhereUniqueWithoutLoanInput[]
    updateMany?: LoanApplicationUpdateManyWithWhereWithoutLoanInput | LoanApplicationUpdateManyWithWhereWithoutLoanInput[]
    deleteMany?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
  }

  export type LoanApplicationCreatedocumentsInput = {
    set: string[]
  }

  export type LoanCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<LoanCreateWithoutApplicationsInput, LoanUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: LoanCreateOrConnectWithoutApplicationsInput
    connect?: LoanWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLoanApplicationsInput = {
    create?: XOR<UserCreateWithoutLoanApplicationsInput, UserUncheckedCreateWithoutLoanApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoanApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type LoanApplicationUpdatedocumentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LoanUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<LoanCreateWithoutApplicationsInput, LoanUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: LoanCreateOrConnectWithoutApplicationsInput
    upsert?: LoanUpsertWithoutApplicationsInput
    connect?: LoanWhereUniqueInput
    update?: XOR<XOR<LoanUpdateToOneWithWhereWithoutApplicationsInput, LoanUpdateWithoutApplicationsInput>, LoanUncheckedUpdateWithoutApplicationsInput>
  }

  export type UserUpdateOneRequiredWithoutLoanApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutLoanApplicationsInput, UserUncheckedCreateWithoutLoanApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoanApplicationsInput
    upsert?: UserUpsertWithoutLoanApplicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLoanApplicationsInput, UserUpdateWithoutLoanApplicationsInput>, UserUncheckedUpdateWithoutLoanApplicationsInput>
  }

  export type ArticleCreateNestedOneWithoutVotesInput = {
    create?: XOR<ArticleCreateWithoutVotesInput, ArticleUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutVotesInput
    connect?: ArticleWhereUniqueInput
  }

  export type EnumVoteTypeFieldUpdateOperationsInput = {
    set?: $Enums.VoteType
  }

  export type ArticleUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<ArticleCreateWithoutVotesInput, ArticleUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutVotesInput
    upsert?: ArticleUpsertWithoutVotesInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutVotesInput, ArticleUpdateWithoutVotesInput>, ArticleUncheckedUpdateWithoutVotesInput>
  }

  export type UserCreateNestedOneWithoutCreatedGroupsInput = {
    create?: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type EventCreateNestedManyWithoutGroupInput = {
    create?: XOR<EventCreateWithoutGroupInput, EventUncheckedCreateWithoutGroupInput> | EventCreateWithoutGroupInput[] | EventUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: EventCreateOrConnectWithoutGroupInput | EventCreateOrConnectWithoutGroupInput[]
    createMany?: EventCreateManyGroupInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ArticleCreateNestedManyWithoutGroupInput = {
    create?: XOR<ArticleCreateWithoutGroupInput, ArticleUncheckedCreateWithoutGroupInput> | ArticleCreateWithoutGroupInput[] | ArticleUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutGroupInput | ArticleCreateOrConnectWithoutGroupInput[]
    createMany?: ArticleCreateManyGroupInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type ForumCreateNestedManyWithoutGroupInput = {
    create?: XOR<ForumCreateWithoutGroupInput, ForumUncheckedCreateWithoutGroupInput> | ForumCreateWithoutGroupInput[] | ForumUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ForumCreateOrConnectWithoutGroupInput | ForumCreateOrConnectWithoutGroupInput[]
    createMany?: ForumCreateManyGroupInputEnvelope
    connect?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
  }

  export type GroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutAdminOfInput = {
    create?: XOR<UserCreateWithoutAdminOfInput, UserUncheckedCreateWithoutAdminOfInput> | UserCreateWithoutAdminOfInput[] | UserUncheckedCreateWithoutAdminOfInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAdminOfInput | UserCreateOrConnectWithoutAdminOfInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<EventCreateWithoutGroupInput, EventUncheckedCreateWithoutGroupInput> | EventCreateWithoutGroupInput[] | EventUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: EventCreateOrConnectWithoutGroupInput | EventCreateOrConnectWithoutGroupInput[]
    createMany?: EventCreateManyGroupInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ArticleUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<ArticleCreateWithoutGroupInput, ArticleUncheckedCreateWithoutGroupInput> | ArticleCreateWithoutGroupInput[] | ArticleUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutGroupInput | ArticleCreateOrConnectWithoutGroupInput[]
    createMany?: ArticleCreateManyGroupInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type ForumUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<ForumCreateWithoutGroupInput, ForumUncheckedCreateWithoutGroupInput> | ForumCreateWithoutGroupInput[] | ForumUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ForumCreateOrConnectWithoutGroupInput | ForumCreateOrConnectWithoutGroupInput[]
    createMany?: ForumCreateManyGroupInputEnvelope
    connect?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAdminOfInput = {
    create?: XOR<UserCreateWithoutAdminOfInput, UserUncheckedCreateWithoutAdminOfInput> | UserCreateWithoutAdminOfInput[] | UserUncheckedCreateWithoutAdminOfInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAdminOfInput | UserCreateOrConnectWithoutAdminOfInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EnumGroupPrivacyFieldUpdateOperationsInput = {
    set?: $Enums.GroupPrivacy
  }

  export type UserUpdateOneRequiredWithoutCreatedGroupsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGroupsInput
    upsert?: UserUpsertWithoutCreatedGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedGroupsInput, UserUpdateWithoutCreatedGroupsInput>, UserUncheckedUpdateWithoutCreatedGroupsInput>
  }

  export type EventUpdateManyWithoutGroupNestedInput = {
    create?: XOR<EventCreateWithoutGroupInput, EventUncheckedCreateWithoutGroupInput> | EventCreateWithoutGroupInput[] | EventUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: EventCreateOrConnectWithoutGroupInput | EventCreateOrConnectWithoutGroupInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutGroupInput | EventUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: EventCreateManyGroupInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutGroupInput | EventUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: EventUpdateManyWithWhereWithoutGroupInput | EventUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ArticleUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ArticleCreateWithoutGroupInput, ArticleUncheckedCreateWithoutGroupInput> | ArticleCreateWithoutGroupInput[] | ArticleUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutGroupInput | ArticleCreateOrConnectWithoutGroupInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutGroupInput | ArticleUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ArticleCreateManyGroupInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutGroupInput | ArticleUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutGroupInput | ArticleUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type ForumUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ForumCreateWithoutGroupInput, ForumUncheckedCreateWithoutGroupInput> | ForumCreateWithoutGroupInput[] | ForumUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ForumCreateOrConnectWithoutGroupInput | ForumCreateOrConnectWithoutGroupInput[]
    upsert?: ForumUpsertWithWhereUniqueWithoutGroupInput | ForumUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ForumCreateManyGroupInputEnvelope
    set?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    disconnect?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    delete?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    connect?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    update?: ForumUpdateWithWhereUniqueWithoutGroupInput | ForumUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ForumUpdateManyWithWhereWithoutGroupInput | ForumUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ForumScalarWhereInput | ForumScalarWhereInput[]
  }

  export type GroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type UserUpdateManyWithoutAdminOfNestedInput = {
    create?: XOR<UserCreateWithoutAdminOfInput, UserUncheckedCreateWithoutAdminOfInput> | UserCreateWithoutAdminOfInput[] | UserUncheckedCreateWithoutAdminOfInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAdminOfInput | UserCreateOrConnectWithoutAdminOfInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAdminOfInput | UserUpsertWithWhereUniqueWithoutAdminOfInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAdminOfInput | UserUpdateWithWhereUniqueWithoutAdminOfInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAdminOfInput | UserUpdateManyWithWhereWithoutAdminOfInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<EventCreateWithoutGroupInput, EventUncheckedCreateWithoutGroupInput> | EventCreateWithoutGroupInput[] | EventUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: EventCreateOrConnectWithoutGroupInput | EventCreateOrConnectWithoutGroupInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutGroupInput | EventUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: EventCreateManyGroupInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutGroupInput | EventUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: EventUpdateManyWithWhereWithoutGroupInput | EventUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ArticleUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ArticleCreateWithoutGroupInput, ArticleUncheckedCreateWithoutGroupInput> | ArticleCreateWithoutGroupInput[] | ArticleUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutGroupInput | ArticleCreateOrConnectWithoutGroupInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutGroupInput | ArticleUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ArticleCreateManyGroupInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutGroupInput | ArticleUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutGroupInput | ArticleUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type ForumUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ForumCreateWithoutGroupInput, ForumUncheckedCreateWithoutGroupInput> | ForumCreateWithoutGroupInput[] | ForumUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ForumCreateOrConnectWithoutGroupInput | ForumCreateOrConnectWithoutGroupInput[]
    upsert?: ForumUpsertWithWhereUniqueWithoutGroupInput | ForumUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ForumCreateManyGroupInputEnvelope
    set?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    disconnect?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    delete?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    connect?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    update?: ForumUpdateWithWhereUniqueWithoutGroupInput | ForumUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ForumUpdateManyWithWhereWithoutGroupInput | ForumUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ForumScalarWhereInput | ForumScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAdminOfNestedInput = {
    create?: XOR<UserCreateWithoutAdminOfInput, UserUncheckedCreateWithoutAdminOfInput> | UserCreateWithoutAdminOfInput[] | UserUncheckedCreateWithoutAdminOfInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAdminOfInput | UserCreateOrConnectWithoutAdminOfInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAdminOfInput | UserUpsertWithWhereUniqueWithoutAdminOfInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAdminOfInput | UserUpdateWithWhereUniqueWithoutAdminOfInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAdminOfInput | UserUpdateManyWithWhereWithoutAdminOfInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupMembershipsInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGroupMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.GroupMemberRole
  }

  export type GroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    upsert?: GroupUpsertWithoutMembersInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMembersInput, GroupUpdateWithoutMembersInput>, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutGroupMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    upsert?: UserUpsertWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupMembershipsInput, UserUpdateWithoutGroupMembershipsInput>, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type UserCreateNestedOneWithoutHostedEventsInput = {
    create?: XOR<UserCreateWithoutHostedEventsInput, UserUncheckedCreateWithoutHostedEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHostedEventsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutEventsInput = {
    create?: XOR<GroupCreateWithoutEventsInput, GroupUncheckedCreateWithoutEventsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutEventsInput
    connect?: GroupWhereUniqueInput
  }

  export type EventRegistrationCreateNestedManyWithoutEventInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type EventRegistrationUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType
  }

  export type EnumRegistrationTypeFieldUpdateOperationsInput = {
    set?: $Enums.RegistrationType
  }

  export type EnumEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.EventStatus
  }

  export type UserUpdateOneRequiredWithoutHostedEventsNestedInput = {
    create?: XOR<UserCreateWithoutHostedEventsInput, UserUncheckedCreateWithoutHostedEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHostedEventsInput
    upsert?: UserUpsertWithoutHostedEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHostedEventsInput, UserUpdateWithoutHostedEventsInput>, UserUncheckedUpdateWithoutHostedEventsInput>
  }

  export type GroupUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<GroupCreateWithoutEventsInput, GroupUncheckedCreateWithoutEventsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutEventsInput
    upsert?: GroupUpsertWithoutEventsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutEventsInput, GroupUpdateWithoutEventsInput>, GroupUncheckedUpdateWithoutEventsInput>
  }

  export type EventRegistrationUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutEventInput | EventRegistrationUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutEventInput | EventRegistrationUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutEventInput | EventRegistrationUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type EventRegistrationUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutEventInput | EventRegistrationUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutEventInput | EventRegistrationUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutEventInput | EventRegistrationUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutRegistrationsInput = {
    create?: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: EventCreateOrConnectWithoutRegistrationsInput
    connect?: EventWhereUniqueInput
  }

  export type EnumEventRegistrationStatusFieldUpdateOperationsInput = {
    set?: $Enums.EventRegistrationStatus
  }

  export type EventUpdateOneRequiredWithoutRegistrationsNestedInput = {
    create?: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: EventCreateOrConnectWithoutRegistrationsInput
    upsert?: EventUpsertWithoutRegistrationsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutRegistrationsInput, EventUpdateWithoutRegistrationsInput>, EventUncheckedUpdateWithoutRegistrationsInput>
  }

  export type ForumCreateattachmentsInput = {
    set: string[]
  }

  export type ForumCreatetagsInput = {
    set: string[]
  }

  export type GroupCreateNestedOneWithoutForumsInput = {
    create?: XOR<GroupCreateWithoutForumsInput, GroupUncheckedCreateWithoutForumsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutForumsInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedForumsInput = {
    create?: XOR<UserCreateWithoutCreatedForumsInput, UserUncheckedCreateWithoutCreatedForumsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedForumsInput
    connect?: UserWhereUniqueInput
  }

  export type ForumTopicCreateNestedManyWithoutForumInput = {
    create?: XOR<ForumTopicCreateWithoutForumInput, ForumTopicUncheckedCreateWithoutForumInput> | ForumTopicCreateWithoutForumInput[] | ForumTopicUncheckedCreateWithoutForumInput[]
    connectOrCreate?: ForumTopicCreateOrConnectWithoutForumInput | ForumTopicCreateOrConnectWithoutForumInput[]
    createMany?: ForumTopicCreateManyForumInputEnvelope
    connect?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
  }

  export type ForumReplyCreateNestedManyWithoutForumInput = {
    create?: XOR<ForumReplyCreateWithoutForumInput, ForumReplyUncheckedCreateWithoutForumInput> | ForumReplyCreateWithoutForumInput[] | ForumReplyUncheckedCreateWithoutForumInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutForumInput | ForumReplyCreateOrConnectWithoutForumInput[]
    createMany?: ForumReplyCreateManyForumInputEnvelope
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
  }

  export type ForumTopicUncheckedCreateNestedManyWithoutForumInput = {
    create?: XOR<ForumTopicCreateWithoutForumInput, ForumTopicUncheckedCreateWithoutForumInput> | ForumTopicCreateWithoutForumInput[] | ForumTopicUncheckedCreateWithoutForumInput[]
    connectOrCreate?: ForumTopicCreateOrConnectWithoutForumInput | ForumTopicCreateOrConnectWithoutForumInput[]
    createMany?: ForumTopicCreateManyForumInputEnvelope
    connect?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
  }

  export type ForumReplyUncheckedCreateNestedManyWithoutForumInput = {
    create?: XOR<ForumReplyCreateWithoutForumInput, ForumReplyUncheckedCreateWithoutForumInput> | ForumReplyCreateWithoutForumInput[] | ForumReplyUncheckedCreateWithoutForumInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutForumInput | ForumReplyCreateOrConnectWithoutForumInput[]
    createMany?: ForumReplyCreateManyForumInputEnvelope
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
  }

  export type EnumForumTypeFieldUpdateOperationsInput = {
    set?: $Enums.ForumType
  }

  export type EnumForumPrivacyFieldUpdateOperationsInput = {
    set?: $Enums.ForumPrivacy
  }

  export type ForumUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ForumUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GroupUpdateOneRequiredWithoutForumsNestedInput = {
    create?: XOR<GroupCreateWithoutForumsInput, GroupUncheckedCreateWithoutForumsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutForumsInput
    upsert?: GroupUpsertWithoutForumsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutForumsInput, GroupUpdateWithoutForumsInput>, GroupUncheckedUpdateWithoutForumsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedForumsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedForumsInput, UserUncheckedCreateWithoutCreatedForumsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedForumsInput
    upsert?: UserUpsertWithoutCreatedForumsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedForumsInput, UserUpdateWithoutCreatedForumsInput>, UserUncheckedUpdateWithoutCreatedForumsInput>
  }

  export type ForumTopicUpdateManyWithoutForumNestedInput = {
    create?: XOR<ForumTopicCreateWithoutForumInput, ForumTopicUncheckedCreateWithoutForumInput> | ForumTopicCreateWithoutForumInput[] | ForumTopicUncheckedCreateWithoutForumInput[]
    connectOrCreate?: ForumTopicCreateOrConnectWithoutForumInput | ForumTopicCreateOrConnectWithoutForumInput[]
    upsert?: ForumTopicUpsertWithWhereUniqueWithoutForumInput | ForumTopicUpsertWithWhereUniqueWithoutForumInput[]
    createMany?: ForumTopicCreateManyForumInputEnvelope
    set?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    disconnect?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    delete?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    connect?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    update?: ForumTopicUpdateWithWhereUniqueWithoutForumInput | ForumTopicUpdateWithWhereUniqueWithoutForumInput[]
    updateMany?: ForumTopicUpdateManyWithWhereWithoutForumInput | ForumTopicUpdateManyWithWhereWithoutForumInput[]
    deleteMany?: ForumTopicScalarWhereInput | ForumTopicScalarWhereInput[]
  }

  export type ForumReplyUpdateManyWithoutForumNestedInput = {
    create?: XOR<ForumReplyCreateWithoutForumInput, ForumReplyUncheckedCreateWithoutForumInput> | ForumReplyCreateWithoutForumInput[] | ForumReplyUncheckedCreateWithoutForumInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutForumInput | ForumReplyCreateOrConnectWithoutForumInput[]
    upsert?: ForumReplyUpsertWithWhereUniqueWithoutForumInput | ForumReplyUpsertWithWhereUniqueWithoutForumInput[]
    createMany?: ForumReplyCreateManyForumInputEnvelope
    set?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    disconnect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    delete?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    update?: ForumReplyUpdateWithWhereUniqueWithoutForumInput | ForumReplyUpdateWithWhereUniqueWithoutForumInput[]
    updateMany?: ForumReplyUpdateManyWithWhereWithoutForumInput | ForumReplyUpdateManyWithWhereWithoutForumInput[]
    deleteMany?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
  }

  export type ForumTopicUncheckedUpdateManyWithoutForumNestedInput = {
    create?: XOR<ForumTopicCreateWithoutForumInput, ForumTopicUncheckedCreateWithoutForumInput> | ForumTopicCreateWithoutForumInput[] | ForumTopicUncheckedCreateWithoutForumInput[]
    connectOrCreate?: ForumTopicCreateOrConnectWithoutForumInput | ForumTopicCreateOrConnectWithoutForumInput[]
    upsert?: ForumTopicUpsertWithWhereUniqueWithoutForumInput | ForumTopicUpsertWithWhereUniqueWithoutForumInput[]
    createMany?: ForumTopicCreateManyForumInputEnvelope
    set?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    disconnect?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    delete?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    connect?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    update?: ForumTopicUpdateWithWhereUniqueWithoutForumInput | ForumTopicUpdateWithWhereUniqueWithoutForumInput[]
    updateMany?: ForumTopicUpdateManyWithWhereWithoutForumInput | ForumTopicUpdateManyWithWhereWithoutForumInput[]
    deleteMany?: ForumTopicScalarWhereInput | ForumTopicScalarWhereInput[]
  }

  export type ForumReplyUncheckedUpdateManyWithoutForumNestedInput = {
    create?: XOR<ForumReplyCreateWithoutForumInput, ForumReplyUncheckedCreateWithoutForumInput> | ForumReplyCreateWithoutForumInput[] | ForumReplyUncheckedCreateWithoutForumInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutForumInput | ForumReplyCreateOrConnectWithoutForumInput[]
    upsert?: ForumReplyUpsertWithWhereUniqueWithoutForumInput | ForumReplyUpsertWithWhereUniqueWithoutForumInput[]
    createMany?: ForumReplyCreateManyForumInputEnvelope
    set?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    disconnect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    delete?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    update?: ForumReplyUpdateWithWhereUniqueWithoutForumInput | ForumReplyUpdateWithWhereUniqueWithoutForumInput[]
    updateMany?: ForumReplyUpdateManyWithWhereWithoutForumInput | ForumReplyUpdateManyWithWhereWithoutForumInput[]
    deleteMany?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
  }

  export type ForumCreateNestedOneWithoutTopicsInput = {
    create?: XOR<ForumCreateWithoutTopicsInput, ForumUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: ForumCreateOrConnectWithoutTopicsInput
    connect?: ForumWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedForumTopicsInput = {
    create?: XOR<UserCreateWithoutCreatedForumTopicsInput, UserUncheckedCreateWithoutCreatedForumTopicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedForumTopicsInput
    connect?: UserWhereUniqueInput
  }

  export type ForumPostCreateNestedManyWithoutTopicInput = {
    create?: XOR<ForumPostCreateWithoutTopicInput, ForumPostUncheckedCreateWithoutTopicInput> | ForumPostCreateWithoutTopicInput[] | ForumPostUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutTopicInput | ForumPostCreateOrConnectWithoutTopicInput[]
    createMany?: ForumPostCreateManyTopicInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumReplyCreateNestedManyWithoutTopicInput = {
    create?: XOR<ForumReplyCreateWithoutTopicInput, ForumReplyUncheckedCreateWithoutTopicInput> | ForumReplyCreateWithoutTopicInput[] | ForumReplyUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutTopicInput | ForumReplyCreateOrConnectWithoutTopicInput[]
    createMany?: ForumReplyCreateManyTopicInputEnvelope
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
  }

  export type ForumPostUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<ForumPostCreateWithoutTopicInput, ForumPostUncheckedCreateWithoutTopicInput> | ForumPostCreateWithoutTopicInput[] | ForumPostUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutTopicInput | ForumPostCreateOrConnectWithoutTopicInput[]
    createMany?: ForumPostCreateManyTopicInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumReplyUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<ForumReplyCreateWithoutTopicInput, ForumReplyUncheckedCreateWithoutTopicInput> | ForumReplyCreateWithoutTopicInput[] | ForumReplyUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutTopicInput | ForumReplyCreateOrConnectWithoutTopicInput[]
    createMany?: ForumReplyCreateManyTopicInputEnvelope
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
  }

  export type EnumTopicTypeFieldUpdateOperationsInput = {
    set?: $Enums.TopicType
  }

  export type EnumTopicStatusFieldUpdateOperationsInput = {
    set?: $Enums.TopicStatus
  }

  export type ForumUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<ForumCreateWithoutTopicsInput, ForumUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: ForumCreateOrConnectWithoutTopicsInput
    upsert?: ForumUpsertWithoutTopicsInput
    connect?: ForumWhereUniqueInput
    update?: XOR<XOR<ForumUpdateToOneWithWhereWithoutTopicsInput, ForumUpdateWithoutTopicsInput>, ForumUncheckedUpdateWithoutTopicsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedForumTopicsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedForumTopicsInput, UserUncheckedCreateWithoutCreatedForumTopicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedForumTopicsInput
    upsert?: UserUpsertWithoutCreatedForumTopicsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedForumTopicsInput, UserUpdateWithoutCreatedForumTopicsInput>, UserUncheckedUpdateWithoutCreatedForumTopicsInput>
  }

  export type ForumPostUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ForumPostCreateWithoutTopicInput, ForumPostUncheckedCreateWithoutTopicInput> | ForumPostCreateWithoutTopicInput[] | ForumPostUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutTopicInput | ForumPostCreateOrConnectWithoutTopicInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutTopicInput | ForumPostUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ForumPostCreateManyTopicInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutTopicInput | ForumPostUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutTopicInput | ForumPostUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumReplyUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ForumReplyCreateWithoutTopicInput, ForumReplyUncheckedCreateWithoutTopicInput> | ForumReplyCreateWithoutTopicInput[] | ForumReplyUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutTopicInput | ForumReplyCreateOrConnectWithoutTopicInput[]
    upsert?: ForumReplyUpsertWithWhereUniqueWithoutTopicInput | ForumReplyUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ForumReplyCreateManyTopicInputEnvelope
    set?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    disconnect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    delete?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    update?: ForumReplyUpdateWithWhereUniqueWithoutTopicInput | ForumReplyUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ForumReplyUpdateManyWithWhereWithoutTopicInput | ForumReplyUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
  }

  export type ForumPostUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ForumPostCreateWithoutTopicInput, ForumPostUncheckedCreateWithoutTopicInput> | ForumPostCreateWithoutTopicInput[] | ForumPostUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutTopicInput | ForumPostCreateOrConnectWithoutTopicInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutTopicInput | ForumPostUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ForumPostCreateManyTopicInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutTopicInput | ForumPostUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutTopicInput | ForumPostUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumReplyUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ForumReplyCreateWithoutTopicInput, ForumReplyUncheckedCreateWithoutTopicInput> | ForumReplyCreateWithoutTopicInput[] | ForumReplyUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutTopicInput | ForumReplyCreateOrConnectWithoutTopicInput[]
    upsert?: ForumReplyUpsertWithWhereUniqueWithoutTopicInput | ForumReplyUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ForumReplyCreateManyTopicInputEnvelope
    set?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    disconnect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    delete?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    update?: ForumReplyUpdateWithWhereUniqueWithoutTopicInput | ForumReplyUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ForumReplyUpdateManyWithWhereWithoutTopicInput | ForumReplyUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
  }

  export type ForumReplyCreateattachmentsInput = {
    set: string[]
  }

  export type ForumCreateNestedOneWithoutForumRepliesInput = {
    create?: XOR<ForumCreateWithoutForumRepliesInput, ForumUncheckedCreateWithoutForumRepliesInput>
    connectOrCreate?: ForumCreateOrConnectWithoutForumRepliesInput
    connect?: ForumWhereUniqueInput
  }

  export type ForumTopicCreateNestedOneWithoutRepliesInput = {
    create?: XOR<ForumTopicCreateWithoutRepliesInput, ForumTopicUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ForumTopicCreateOrConnectWithoutRepliesInput
    connect?: ForumTopicWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutForumRepliesInput = {
    create?: XOR<UserCreateWithoutForumRepliesInput, UserUncheckedCreateWithoutForumRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumRepliesInput
    connect?: UserWhereUniqueInput
  }

  export type ForumReplyReactionCreateNestedManyWithoutForumReplyInput = {
    create?: XOR<ForumReplyReactionCreateWithoutForumReplyInput, ForumReplyReactionUncheckedCreateWithoutForumReplyInput> | ForumReplyReactionCreateWithoutForumReplyInput[] | ForumReplyReactionUncheckedCreateWithoutForumReplyInput[]
    connectOrCreate?: ForumReplyReactionCreateOrConnectWithoutForumReplyInput | ForumReplyReactionCreateOrConnectWithoutForumReplyInput[]
    createMany?: ForumReplyReactionCreateManyForumReplyInputEnvelope
    connect?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
  }

  export type ForumReplyCreateNestedOneWithoutChildRepliesInput = {
    create?: XOR<ForumReplyCreateWithoutChildRepliesInput, ForumReplyUncheckedCreateWithoutChildRepliesInput>
    connectOrCreate?: ForumReplyCreateOrConnectWithoutChildRepliesInput
    connect?: ForumReplyWhereUniqueInput
  }

  export type ForumReplyCreateNestedManyWithoutParentReplyInput = {
    create?: XOR<ForumReplyCreateWithoutParentReplyInput, ForumReplyUncheckedCreateWithoutParentReplyInput> | ForumReplyCreateWithoutParentReplyInput[] | ForumReplyUncheckedCreateWithoutParentReplyInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutParentReplyInput | ForumReplyCreateOrConnectWithoutParentReplyInput[]
    createMany?: ForumReplyCreateManyParentReplyInputEnvelope
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
  }

  export type ForumReplyReactionUncheckedCreateNestedManyWithoutForumReplyInput = {
    create?: XOR<ForumReplyReactionCreateWithoutForumReplyInput, ForumReplyReactionUncheckedCreateWithoutForumReplyInput> | ForumReplyReactionCreateWithoutForumReplyInput[] | ForumReplyReactionUncheckedCreateWithoutForumReplyInput[]
    connectOrCreate?: ForumReplyReactionCreateOrConnectWithoutForumReplyInput | ForumReplyReactionCreateOrConnectWithoutForumReplyInput[]
    createMany?: ForumReplyReactionCreateManyForumReplyInputEnvelope
    connect?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
  }

  export type ForumReplyUncheckedCreateNestedManyWithoutParentReplyInput = {
    create?: XOR<ForumReplyCreateWithoutParentReplyInput, ForumReplyUncheckedCreateWithoutParentReplyInput> | ForumReplyCreateWithoutParentReplyInput[] | ForumReplyUncheckedCreateWithoutParentReplyInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutParentReplyInput | ForumReplyCreateOrConnectWithoutParentReplyInput[]
    createMany?: ForumReplyCreateManyParentReplyInputEnvelope
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
  }

  export type ForumReplyUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ForumUpdateOneRequiredWithoutForumRepliesNestedInput = {
    create?: XOR<ForumCreateWithoutForumRepliesInput, ForumUncheckedCreateWithoutForumRepliesInput>
    connectOrCreate?: ForumCreateOrConnectWithoutForumRepliesInput
    upsert?: ForumUpsertWithoutForumRepliesInput
    connect?: ForumWhereUniqueInput
    update?: XOR<XOR<ForumUpdateToOneWithWhereWithoutForumRepliesInput, ForumUpdateWithoutForumRepliesInput>, ForumUncheckedUpdateWithoutForumRepliesInput>
  }

  export type ForumTopicUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<ForumTopicCreateWithoutRepliesInput, ForumTopicUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ForumTopicCreateOrConnectWithoutRepliesInput
    upsert?: ForumTopicUpsertWithoutRepliesInput
    connect?: ForumTopicWhereUniqueInput
    update?: XOR<XOR<ForumTopicUpdateToOneWithWhereWithoutRepliesInput, ForumTopicUpdateWithoutRepliesInput>, ForumTopicUncheckedUpdateWithoutRepliesInput>
  }

  export type UserUpdateOneRequiredWithoutForumRepliesNestedInput = {
    create?: XOR<UserCreateWithoutForumRepliesInput, UserUncheckedCreateWithoutForumRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumRepliesInput
    upsert?: UserUpsertWithoutForumRepliesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutForumRepliesInput, UserUpdateWithoutForumRepliesInput>, UserUncheckedUpdateWithoutForumRepliesInput>
  }

  export type ForumReplyReactionUpdateManyWithoutForumReplyNestedInput = {
    create?: XOR<ForumReplyReactionCreateWithoutForumReplyInput, ForumReplyReactionUncheckedCreateWithoutForumReplyInput> | ForumReplyReactionCreateWithoutForumReplyInput[] | ForumReplyReactionUncheckedCreateWithoutForumReplyInput[]
    connectOrCreate?: ForumReplyReactionCreateOrConnectWithoutForumReplyInput | ForumReplyReactionCreateOrConnectWithoutForumReplyInput[]
    upsert?: ForumReplyReactionUpsertWithWhereUniqueWithoutForumReplyInput | ForumReplyReactionUpsertWithWhereUniqueWithoutForumReplyInput[]
    createMany?: ForumReplyReactionCreateManyForumReplyInputEnvelope
    set?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    disconnect?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    delete?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    connect?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    update?: ForumReplyReactionUpdateWithWhereUniqueWithoutForumReplyInput | ForumReplyReactionUpdateWithWhereUniqueWithoutForumReplyInput[]
    updateMany?: ForumReplyReactionUpdateManyWithWhereWithoutForumReplyInput | ForumReplyReactionUpdateManyWithWhereWithoutForumReplyInput[]
    deleteMany?: ForumReplyReactionScalarWhereInput | ForumReplyReactionScalarWhereInput[]
  }

  export type ForumReplyUpdateOneWithoutChildRepliesNestedInput = {
    create?: XOR<ForumReplyCreateWithoutChildRepliesInput, ForumReplyUncheckedCreateWithoutChildRepliesInput>
    connectOrCreate?: ForumReplyCreateOrConnectWithoutChildRepliesInput
    upsert?: ForumReplyUpsertWithoutChildRepliesInput
    disconnect?: ForumReplyWhereInput | boolean
    delete?: ForumReplyWhereInput | boolean
    connect?: ForumReplyWhereUniqueInput
    update?: XOR<XOR<ForumReplyUpdateToOneWithWhereWithoutChildRepliesInput, ForumReplyUpdateWithoutChildRepliesInput>, ForumReplyUncheckedUpdateWithoutChildRepliesInput>
  }

  export type ForumReplyUpdateManyWithoutParentReplyNestedInput = {
    create?: XOR<ForumReplyCreateWithoutParentReplyInput, ForumReplyUncheckedCreateWithoutParentReplyInput> | ForumReplyCreateWithoutParentReplyInput[] | ForumReplyUncheckedCreateWithoutParentReplyInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutParentReplyInput | ForumReplyCreateOrConnectWithoutParentReplyInput[]
    upsert?: ForumReplyUpsertWithWhereUniqueWithoutParentReplyInput | ForumReplyUpsertWithWhereUniqueWithoutParentReplyInput[]
    createMany?: ForumReplyCreateManyParentReplyInputEnvelope
    set?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    disconnect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    delete?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    update?: ForumReplyUpdateWithWhereUniqueWithoutParentReplyInput | ForumReplyUpdateWithWhereUniqueWithoutParentReplyInput[]
    updateMany?: ForumReplyUpdateManyWithWhereWithoutParentReplyInput | ForumReplyUpdateManyWithWhereWithoutParentReplyInput[]
    deleteMany?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
  }

  export type ForumReplyReactionUncheckedUpdateManyWithoutForumReplyNestedInput = {
    create?: XOR<ForumReplyReactionCreateWithoutForumReplyInput, ForumReplyReactionUncheckedCreateWithoutForumReplyInput> | ForumReplyReactionCreateWithoutForumReplyInput[] | ForumReplyReactionUncheckedCreateWithoutForumReplyInput[]
    connectOrCreate?: ForumReplyReactionCreateOrConnectWithoutForumReplyInput | ForumReplyReactionCreateOrConnectWithoutForumReplyInput[]
    upsert?: ForumReplyReactionUpsertWithWhereUniqueWithoutForumReplyInput | ForumReplyReactionUpsertWithWhereUniqueWithoutForumReplyInput[]
    createMany?: ForumReplyReactionCreateManyForumReplyInputEnvelope
    set?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    disconnect?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    delete?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    connect?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    update?: ForumReplyReactionUpdateWithWhereUniqueWithoutForumReplyInput | ForumReplyReactionUpdateWithWhereUniqueWithoutForumReplyInput[]
    updateMany?: ForumReplyReactionUpdateManyWithWhereWithoutForumReplyInput | ForumReplyReactionUpdateManyWithWhereWithoutForumReplyInput[]
    deleteMany?: ForumReplyReactionScalarWhereInput | ForumReplyReactionScalarWhereInput[]
  }

  export type ForumReplyUncheckedUpdateManyWithoutParentReplyNestedInput = {
    create?: XOR<ForumReplyCreateWithoutParentReplyInput, ForumReplyUncheckedCreateWithoutParentReplyInput> | ForumReplyCreateWithoutParentReplyInput[] | ForumReplyUncheckedCreateWithoutParentReplyInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutParentReplyInput | ForumReplyCreateOrConnectWithoutParentReplyInput[]
    upsert?: ForumReplyUpsertWithWhereUniqueWithoutParentReplyInput | ForumReplyUpsertWithWhereUniqueWithoutParentReplyInput[]
    createMany?: ForumReplyCreateManyParentReplyInputEnvelope
    set?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    disconnect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    delete?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    update?: ForumReplyUpdateWithWhereUniqueWithoutParentReplyInput | ForumReplyUpdateWithWhereUniqueWithoutParentReplyInput[]
    updateMany?: ForumReplyUpdateManyWithWhereWithoutParentReplyInput | ForumReplyUpdateManyWithWhereWithoutParentReplyInput[]
    deleteMany?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
  }

  export type ForumTopicCreateNestedOneWithoutPostsInput = {
    create?: XOR<ForumTopicCreateWithoutPostsInput, ForumTopicUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ForumTopicCreateOrConnectWithoutPostsInput
    connect?: ForumTopicWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutForumPostsInput = {
    create?: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumPostsInput
    connect?: UserWhereUniqueInput
  }

  export type ForumPostReactionCreateNestedManyWithoutForumPostInput = {
    create?: XOR<ForumPostReactionCreateWithoutForumPostInput, ForumPostReactionUncheckedCreateWithoutForumPostInput> | ForumPostReactionCreateWithoutForumPostInput[] | ForumPostReactionUncheckedCreateWithoutForumPostInput[]
    connectOrCreate?: ForumPostReactionCreateOrConnectWithoutForumPostInput | ForumPostReactionCreateOrConnectWithoutForumPostInput[]
    createMany?: ForumPostReactionCreateManyForumPostInputEnvelope
    connect?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
  }

  export type ForumPostCreateNestedOneWithoutRepliesInput = {
    create?: XOR<ForumPostCreateWithoutRepliesInput, ForumPostUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ForumPostCreateOrConnectWithoutRepliesInput
    connect?: ForumPostWhereUniqueInput
  }

  export type ForumPostCreateNestedManyWithoutParentPostInput = {
    create?: XOR<ForumPostCreateWithoutParentPostInput, ForumPostUncheckedCreateWithoutParentPostInput> | ForumPostCreateWithoutParentPostInput[] | ForumPostUncheckedCreateWithoutParentPostInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutParentPostInput | ForumPostCreateOrConnectWithoutParentPostInput[]
    createMany?: ForumPostCreateManyParentPostInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumPostReactionUncheckedCreateNestedManyWithoutForumPostInput = {
    create?: XOR<ForumPostReactionCreateWithoutForumPostInput, ForumPostReactionUncheckedCreateWithoutForumPostInput> | ForumPostReactionCreateWithoutForumPostInput[] | ForumPostReactionUncheckedCreateWithoutForumPostInput[]
    connectOrCreate?: ForumPostReactionCreateOrConnectWithoutForumPostInput | ForumPostReactionCreateOrConnectWithoutForumPostInput[]
    createMany?: ForumPostReactionCreateManyForumPostInputEnvelope
    connect?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
  }

  export type ForumPostUncheckedCreateNestedManyWithoutParentPostInput = {
    create?: XOR<ForumPostCreateWithoutParentPostInput, ForumPostUncheckedCreateWithoutParentPostInput> | ForumPostCreateWithoutParentPostInput[] | ForumPostUncheckedCreateWithoutParentPostInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutParentPostInput | ForumPostCreateOrConnectWithoutParentPostInput[]
    createMany?: ForumPostCreateManyParentPostInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumTopicUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<ForumTopicCreateWithoutPostsInput, ForumTopicUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ForumTopicCreateOrConnectWithoutPostsInput
    upsert?: ForumTopicUpsertWithoutPostsInput
    connect?: ForumTopicWhereUniqueInput
    update?: XOR<XOR<ForumTopicUpdateToOneWithWhereWithoutPostsInput, ForumTopicUpdateWithoutPostsInput>, ForumTopicUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateOneRequiredWithoutForumPostsNestedInput = {
    create?: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumPostsInput
    upsert?: UserUpsertWithoutForumPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutForumPostsInput, UserUpdateWithoutForumPostsInput>, UserUncheckedUpdateWithoutForumPostsInput>
  }

  export type ForumPostReactionUpdateManyWithoutForumPostNestedInput = {
    create?: XOR<ForumPostReactionCreateWithoutForumPostInput, ForumPostReactionUncheckedCreateWithoutForumPostInput> | ForumPostReactionCreateWithoutForumPostInput[] | ForumPostReactionUncheckedCreateWithoutForumPostInput[]
    connectOrCreate?: ForumPostReactionCreateOrConnectWithoutForumPostInput | ForumPostReactionCreateOrConnectWithoutForumPostInput[]
    upsert?: ForumPostReactionUpsertWithWhereUniqueWithoutForumPostInput | ForumPostReactionUpsertWithWhereUniqueWithoutForumPostInput[]
    createMany?: ForumPostReactionCreateManyForumPostInputEnvelope
    set?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    disconnect?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    delete?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    connect?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    update?: ForumPostReactionUpdateWithWhereUniqueWithoutForumPostInput | ForumPostReactionUpdateWithWhereUniqueWithoutForumPostInput[]
    updateMany?: ForumPostReactionUpdateManyWithWhereWithoutForumPostInput | ForumPostReactionUpdateManyWithWhereWithoutForumPostInput[]
    deleteMany?: ForumPostReactionScalarWhereInput | ForumPostReactionScalarWhereInput[]
  }

  export type ForumPostUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<ForumPostCreateWithoutRepliesInput, ForumPostUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ForumPostCreateOrConnectWithoutRepliesInput
    upsert?: ForumPostUpsertWithoutRepliesInput
    disconnect?: ForumPostWhereInput | boolean
    delete?: ForumPostWhereInput | boolean
    connect?: ForumPostWhereUniqueInput
    update?: XOR<XOR<ForumPostUpdateToOneWithWhereWithoutRepliesInput, ForumPostUpdateWithoutRepliesInput>, ForumPostUncheckedUpdateWithoutRepliesInput>
  }

  export type ForumPostUpdateManyWithoutParentPostNestedInput = {
    create?: XOR<ForumPostCreateWithoutParentPostInput, ForumPostUncheckedCreateWithoutParentPostInput> | ForumPostCreateWithoutParentPostInput[] | ForumPostUncheckedCreateWithoutParentPostInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutParentPostInput | ForumPostCreateOrConnectWithoutParentPostInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutParentPostInput | ForumPostUpsertWithWhereUniqueWithoutParentPostInput[]
    createMany?: ForumPostCreateManyParentPostInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutParentPostInput | ForumPostUpdateWithWhereUniqueWithoutParentPostInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutParentPostInput | ForumPostUpdateManyWithWhereWithoutParentPostInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumPostReactionUncheckedUpdateManyWithoutForumPostNestedInput = {
    create?: XOR<ForumPostReactionCreateWithoutForumPostInput, ForumPostReactionUncheckedCreateWithoutForumPostInput> | ForumPostReactionCreateWithoutForumPostInput[] | ForumPostReactionUncheckedCreateWithoutForumPostInput[]
    connectOrCreate?: ForumPostReactionCreateOrConnectWithoutForumPostInput | ForumPostReactionCreateOrConnectWithoutForumPostInput[]
    upsert?: ForumPostReactionUpsertWithWhereUniqueWithoutForumPostInput | ForumPostReactionUpsertWithWhereUniqueWithoutForumPostInput[]
    createMany?: ForumPostReactionCreateManyForumPostInputEnvelope
    set?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    disconnect?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    delete?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    connect?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    update?: ForumPostReactionUpdateWithWhereUniqueWithoutForumPostInput | ForumPostReactionUpdateWithWhereUniqueWithoutForumPostInput[]
    updateMany?: ForumPostReactionUpdateManyWithWhereWithoutForumPostInput | ForumPostReactionUpdateManyWithWhereWithoutForumPostInput[]
    deleteMany?: ForumPostReactionScalarWhereInput | ForumPostReactionScalarWhereInput[]
  }

  export type ForumPostUncheckedUpdateManyWithoutParentPostNestedInput = {
    create?: XOR<ForumPostCreateWithoutParentPostInput, ForumPostUncheckedCreateWithoutParentPostInput> | ForumPostCreateWithoutParentPostInput[] | ForumPostUncheckedCreateWithoutParentPostInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutParentPostInput | ForumPostCreateOrConnectWithoutParentPostInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutParentPostInput | ForumPostUpsertWithWhereUniqueWithoutParentPostInput[]
    createMany?: ForumPostCreateManyParentPostInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutParentPostInput | ForumPostUpdateWithWhereUniqueWithoutParentPostInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutParentPostInput | ForumPostUpdateManyWithWhereWithoutParentPostInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumReplyCreateNestedOneWithoutReactionsInput = {
    create?: XOR<ForumReplyCreateWithoutReactionsInput, ForumReplyUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: ForumReplyCreateOrConnectWithoutReactionsInput
    connect?: ForumReplyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutForumReplyReactionsInput = {
    create?: XOR<UserCreateWithoutForumReplyReactionsInput, UserUncheckedCreateWithoutForumReplyReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumReplyReactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReactionType
  }

  export type ForumReplyUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<ForumReplyCreateWithoutReactionsInput, ForumReplyUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: ForumReplyCreateOrConnectWithoutReactionsInput
    upsert?: ForumReplyUpsertWithoutReactionsInput
    connect?: ForumReplyWhereUniqueInput
    update?: XOR<XOR<ForumReplyUpdateToOneWithWhereWithoutReactionsInput, ForumReplyUpdateWithoutReactionsInput>, ForumReplyUncheckedUpdateWithoutReactionsInput>
  }

  export type UserUpdateOneRequiredWithoutForumReplyReactionsNestedInput = {
    create?: XOR<UserCreateWithoutForumReplyReactionsInput, UserUncheckedCreateWithoutForumReplyReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumReplyReactionsInput
    upsert?: UserUpsertWithoutForumReplyReactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutForumReplyReactionsInput, UserUpdateWithoutForumReplyReactionsInput>, UserUncheckedUpdateWithoutForumReplyReactionsInput>
  }

  export type ForumPostCreateNestedOneWithoutReactionsInput = {
    create?: XOR<ForumPostCreateWithoutReactionsInput, ForumPostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: ForumPostCreateOrConnectWithoutReactionsInput
    connect?: ForumPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutForumPostReactionsInput = {
    create?: XOR<UserCreateWithoutForumPostReactionsInput, UserUncheckedCreateWithoutForumPostReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumPostReactionsInput
    connect?: UserWhereUniqueInput
  }

  export type ForumPostUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<ForumPostCreateWithoutReactionsInput, ForumPostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: ForumPostCreateOrConnectWithoutReactionsInput
    upsert?: ForumPostUpsertWithoutReactionsInput
    connect?: ForumPostWhereUniqueInput
    update?: XOR<XOR<ForumPostUpdateToOneWithWhereWithoutReactionsInput, ForumPostUpdateWithoutReactionsInput>, ForumPostUncheckedUpdateWithoutReactionsInput>
  }

  export type UserUpdateOneRequiredWithoutForumPostReactionsNestedInput = {
    create?: XOR<UserCreateWithoutForumPostReactionsInput, UserUncheckedCreateWithoutForumPostReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumPostReactionsInput
    upsert?: UserUpsertWithoutForumPostReactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutForumPostReactionsInput, UserUpdateWithoutForumPostReactionsInput>, UserUncheckedUpdateWithoutForumPostReactionsInput>
  }

  export type ArticleCreateimagesInput = {
    set: string[]
  }

  export type ArticleCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutArticlesInput = {
    create?: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticlesInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutArticlesInput = {
    create?: XOR<GroupCreateWithoutArticlesInput, GroupUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutArticlesInput
    connect?: GroupWhereUniqueInput
  }

  export type VoteCreateNestedManyWithoutArticleInput = {
    create?: XOR<VoteCreateWithoutArticleInput, VoteUncheckedCreateWithoutArticleInput> | VoteCreateWithoutArticleInput[] | VoteUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutArticleInput | VoteCreateOrConnectWithoutArticleInput[]
    createMany?: VoteCreateManyArticleInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<VoteCreateWithoutArticleInput, VoteUncheckedCreateWithoutArticleInput> | VoteCreateWithoutArticleInput[] | VoteUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutArticleInput | VoteCreateOrConnectWithoutArticleInput[]
    createMany?: VoteCreateManyArticleInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type ArticleUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ArticleUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumArticleTypeFieldUpdateOperationsInput = {
    set?: $Enums.ArticleType
  }

  export type EnumArticleStatusFieldUpdateOperationsInput = {
    set?: $Enums.ArticleStatus
  }

  export type UserUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticlesInput
    upsert?: UserUpsertWithoutArticlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutArticlesInput, UserUpdateWithoutArticlesInput>, UserUncheckedUpdateWithoutArticlesInput>
  }

  export type GroupUpdateOneWithoutArticlesNestedInput = {
    create?: XOR<GroupCreateWithoutArticlesInput, GroupUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: GroupCreateOrConnectWithoutArticlesInput
    upsert?: GroupUpsertWithoutArticlesInput
    disconnect?: GroupWhereInput | boolean
    delete?: GroupWhereInput | boolean
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutArticlesInput, GroupUpdateWithoutArticlesInput>, GroupUncheckedUpdateWithoutArticlesInput>
  }

  export type VoteUpdateManyWithoutArticleNestedInput = {
    create?: XOR<VoteCreateWithoutArticleInput, VoteUncheckedCreateWithoutArticleInput> | VoteCreateWithoutArticleInput[] | VoteUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutArticleInput | VoteCreateOrConnectWithoutArticleInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutArticleInput | VoteUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: VoteCreateManyArticleInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutArticleInput | VoteUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutArticleInput | VoteUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<VoteCreateWithoutArticleInput, VoteUncheckedCreateWithoutArticleInput> | VoteCreateWithoutArticleInput[] | VoteUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutArticleInput | VoteCreateOrConnectWithoutArticleInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutArticleInput | VoteUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: VoteCreateManyArticleInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutArticleInput | VoteUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutArticleInput | VoteUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutFavCoursesInput = {
    create?: XOR<UserCreateWithoutFavCoursesInput, UserUncheckedCreateWithoutFavCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutFavByUsersInput = {
    create?: XOR<CourseCreateWithoutFavByUsersInput, CourseUncheckedCreateWithoutFavByUsersInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFavByUsersInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavCoursesNestedInput = {
    create?: XOR<UserCreateWithoutFavCoursesInput, UserUncheckedCreateWithoutFavCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavCoursesInput
    upsert?: UserUpsertWithoutFavCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavCoursesInput, UserUpdateWithoutFavCoursesInput>, UserUncheckedUpdateWithoutFavCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutFavByUsersNestedInput = {
    create?: XOR<CourseCreateWithoutFavByUsersInput, CourseUncheckedCreateWithoutFavByUsersInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFavByUsersInput
    upsert?: CourseUpsertWithoutFavByUsersInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutFavByUsersInput, CourseUpdateWithoutFavByUsersInput>, CourseUncheckedUpdateWithoutFavByUsersInput>
  }

  export type FavCourseCreateNestedManyWithoutUserInput = {
    create?: XOR<FavCourseCreateWithoutUserInput, FavCourseUncheckedCreateWithoutUserInput> | FavCourseCreateWithoutUserInput[] | FavCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavCourseCreateOrConnectWithoutUserInput | FavCourseCreateOrConnectWithoutUserInput[]
    createMany?: FavCourseCreateManyUserInputEnvelope
    connect?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
  }

  export type QuizAnswerCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizAnswerCreateWithoutUserInput, QuizAnswerUncheckedCreateWithoutUserInput> | QuizAnswerCreateWithoutUserInput[] | QuizAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutUserInput | QuizAnswerCreateOrConnectWithoutUserInput[]
    createMany?: QuizAnswerCreateManyUserInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type ForumCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ForumCreateWithoutCreatorInput, ForumUncheckedCreateWithoutCreatorInput> | ForumCreateWithoutCreatorInput[] | ForumUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ForumCreateOrConnectWithoutCreatorInput | ForumCreateOrConnectWithoutCreatorInput[]
    createMany?: ForumCreateManyCreatorInputEnvelope
    connect?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
  }

  export type ForumTopicCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ForumTopicCreateWithoutCreatorInput, ForumTopicUncheckedCreateWithoutCreatorInput> | ForumTopicCreateWithoutCreatorInput[] | ForumTopicUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ForumTopicCreateOrConnectWithoutCreatorInput | ForumTopicCreateOrConnectWithoutCreatorInput[]
    createMany?: ForumTopicCreateManyCreatorInputEnvelope
    connect?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
  }

  export type ForumReplyCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumReplyCreateWithoutUserInput, ForumReplyUncheckedCreateWithoutUserInput> | ForumReplyCreateWithoutUserInput[] | ForumReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutUserInput | ForumReplyCreateOrConnectWithoutUserInput[]
    createMany?: ForumReplyCreateManyUserInputEnvelope
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
  }

  export type ForumPostCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ForumPostCreateWithoutCreatorInput, ForumPostUncheckedCreateWithoutCreatorInput> | ForumPostCreateWithoutCreatorInput[] | ForumPostUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutCreatorInput | ForumPostCreateOrConnectWithoutCreatorInput[]
    createMany?: ForumPostCreateManyCreatorInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumReplyReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumReplyReactionCreateWithoutUserInput, ForumReplyReactionUncheckedCreateWithoutUserInput> | ForumReplyReactionCreateWithoutUserInput[] | ForumReplyReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumReplyReactionCreateOrConnectWithoutUserInput | ForumReplyReactionCreateOrConnectWithoutUserInput[]
    createMany?: ForumReplyReactionCreateManyUserInputEnvelope
    connect?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
  }

  export type ForumPostReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumPostReactionCreateWithoutUserInput, ForumPostReactionUncheckedCreateWithoutUserInput> | ForumPostReactionCreateWithoutUserInput[] | ForumPostReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostReactionCreateOrConnectWithoutUserInput | ForumPostReactionCreateOrConnectWithoutUserInput[]
    createMany?: ForumPostReactionCreateManyUserInputEnvelope
    connect?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
  }

  export type UniversityCreateNestedOneWithoutUsersInput = {
    create?: XOR<UniversityCreateWithoutUsersInput, UniversityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutUsersInput
    connect?: UniversityWhereUniqueInput
  }

  export type LoanApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<LoanApplicationCreateWithoutUserInput, LoanApplicationUncheckedCreateWithoutUserInput> | LoanApplicationCreateWithoutUserInput[] | LoanApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutUserInput | LoanApplicationCreateOrConnectWithoutUserInput[]
    createMany?: LoanApplicationCreateManyUserInputEnvelope
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
  }

  export type AccommodationRatingCreateNestedManyWithoutUserInput = {
    create?: XOR<AccommodationRatingCreateWithoutUserInput, AccommodationRatingUncheckedCreateWithoutUserInput> | AccommodationRatingCreateWithoutUserInput[] | AccommodationRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccommodationRatingCreateOrConnectWithoutUserInput | AccommodationRatingCreateOrConnectWithoutUserInput[]
    createMany?: AccommodationRatingCreateManyUserInputEnvelope
    connect?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
  }

  export type UniversityApplicationsCreateNestedManyWithoutUserInput = {
    create?: XOR<UniversityApplicationsCreateWithoutUserInput, UniversityApplicationsUncheckedCreateWithoutUserInput> | UniversityApplicationsCreateWithoutUserInput[] | UniversityApplicationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UniversityApplicationsCreateOrConnectWithoutUserInput | UniversityApplicationsCreateOrConnectWithoutUserInput[]
    createMany?: UniversityApplicationsCreateManyUserInputEnvelope
    connect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
  }

  export type TokenCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type AccommodationCreateNestedManyWithoutLandlordInput = {
    create?: XOR<AccommodationCreateWithoutLandlordInput, AccommodationUncheckedCreateWithoutLandlordInput> | AccommodationCreateWithoutLandlordInput[] | AccommodationUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: AccommodationCreateOrConnectWithoutLandlordInput | AccommodationCreateOrConnectWithoutLandlordInput[]
    createMany?: AccommodationCreateManyLandlordInputEnvelope
    connect?: AccommodationWhereUniqueInput | AccommodationWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type OTPCreateNestedManyWithoutUserInput = {
    create?: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput> | OTPCreateWithoutUserInput[] | OTPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OTPCreateOrConnectWithoutUserInput | OTPCreateOrConnectWithoutUserInput[]
    createMany?: OTPCreateManyUserInputEnvelope
    connect?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<GroupCreateWithoutCreatedByInput, GroupUncheckedCreateWithoutCreatedByInput> | GroupCreateWithoutCreatedByInput[] | GroupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCreatedByInput | GroupCreateOrConnectWithoutCreatedByInput[]
    createMany?: GroupCreateManyCreatedByInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutModeratorsInput = {
    create?: XOR<GroupCreateWithoutModeratorsInput, GroupUncheckedCreateWithoutModeratorsInput> | GroupCreateWithoutModeratorsInput[] | GroupUncheckedCreateWithoutModeratorsInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutModeratorsInput | GroupCreateOrConnectWithoutModeratorsInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type GroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutContactByInput = {
    create?: XOR<EventCreateWithoutContactByInput, EventUncheckedCreateWithoutContactByInput> | EventCreateWithoutContactByInput[] | EventUncheckedCreateWithoutContactByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutContactByInput | EventCreateOrConnectWithoutContactByInput[]
    createMany?: EventCreateManyContactByInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ArticleCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ArticleCreateWithoutCreatorInput, ArticleUncheckedCreateWithoutCreatorInput> | ArticleCreateWithoutCreatorInput[] | ArticleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutCreatorInput | ArticleCreateOrConnectWithoutCreatorInput[]
    createMany?: ArticleCreateManyCreatorInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type AccommodationReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<AccommodationReviewCreateWithoutUserInput, AccommodationReviewUncheckedCreateWithoutUserInput> | AccommodationReviewCreateWithoutUserInput[] | AccommodationReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccommodationReviewCreateOrConnectWithoutUserInput | AccommodationReviewCreateOrConnectWithoutUserInput[]
    createMany?: AccommodationReviewCreateManyUserInputEnvelope
    connect?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
  }

  export type LikedAccommodationsCreateNestedManyWithoutUserInput = {
    create?: XOR<LikedAccommodationsCreateWithoutUserInput, LikedAccommodationsUncheckedCreateWithoutUserInput> | LikedAccommodationsCreateWithoutUserInput[] | LikedAccommodationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikedAccommodationsCreateOrConnectWithoutUserInput | LikedAccommodationsCreateOrConnectWithoutUserInput[]
    createMany?: LikedAccommodationsCreateManyUserInputEnvelope
    connect?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
  }

  export type FavCourseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavCourseCreateWithoutUserInput, FavCourseUncheckedCreateWithoutUserInput> | FavCourseCreateWithoutUserInput[] | FavCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavCourseCreateOrConnectWithoutUserInput | FavCourseCreateOrConnectWithoutUserInput[]
    createMany?: FavCourseCreateManyUserInputEnvelope
    connect?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
  }

  export type QuizAnswerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizAnswerCreateWithoutUserInput, QuizAnswerUncheckedCreateWithoutUserInput> | QuizAnswerCreateWithoutUserInput[] | QuizAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutUserInput | QuizAnswerCreateOrConnectWithoutUserInput[]
    createMany?: QuizAnswerCreateManyUserInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type ForumUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ForumCreateWithoutCreatorInput, ForumUncheckedCreateWithoutCreatorInput> | ForumCreateWithoutCreatorInput[] | ForumUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ForumCreateOrConnectWithoutCreatorInput | ForumCreateOrConnectWithoutCreatorInput[]
    createMany?: ForumCreateManyCreatorInputEnvelope
    connect?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
  }

  export type ForumTopicUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ForumTopicCreateWithoutCreatorInput, ForumTopicUncheckedCreateWithoutCreatorInput> | ForumTopicCreateWithoutCreatorInput[] | ForumTopicUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ForumTopicCreateOrConnectWithoutCreatorInput | ForumTopicCreateOrConnectWithoutCreatorInput[]
    createMany?: ForumTopicCreateManyCreatorInputEnvelope
    connect?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
  }

  export type ForumReplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumReplyCreateWithoutUserInput, ForumReplyUncheckedCreateWithoutUserInput> | ForumReplyCreateWithoutUserInput[] | ForumReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutUserInput | ForumReplyCreateOrConnectWithoutUserInput[]
    createMany?: ForumReplyCreateManyUserInputEnvelope
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
  }

  export type ForumPostUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ForumPostCreateWithoutCreatorInput, ForumPostUncheckedCreateWithoutCreatorInput> | ForumPostCreateWithoutCreatorInput[] | ForumPostUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutCreatorInput | ForumPostCreateOrConnectWithoutCreatorInput[]
    createMany?: ForumPostCreateManyCreatorInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumReplyReactionCreateWithoutUserInput, ForumReplyReactionUncheckedCreateWithoutUserInput> | ForumReplyReactionCreateWithoutUserInput[] | ForumReplyReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumReplyReactionCreateOrConnectWithoutUserInput | ForumReplyReactionCreateOrConnectWithoutUserInput[]
    createMany?: ForumReplyReactionCreateManyUserInputEnvelope
    connect?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
  }

  export type ForumPostReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumPostReactionCreateWithoutUserInput, ForumPostReactionUncheckedCreateWithoutUserInput> | ForumPostReactionCreateWithoutUserInput[] | ForumPostReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostReactionCreateOrConnectWithoutUserInput | ForumPostReactionCreateOrConnectWithoutUserInput[]
    createMany?: ForumPostReactionCreateManyUserInputEnvelope
    connect?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
  }

  export type LoanApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LoanApplicationCreateWithoutUserInput, LoanApplicationUncheckedCreateWithoutUserInput> | LoanApplicationCreateWithoutUserInput[] | LoanApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutUserInput | LoanApplicationCreateOrConnectWithoutUserInput[]
    createMany?: LoanApplicationCreateManyUserInputEnvelope
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
  }

  export type AccommodationRatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccommodationRatingCreateWithoutUserInput, AccommodationRatingUncheckedCreateWithoutUserInput> | AccommodationRatingCreateWithoutUserInput[] | AccommodationRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccommodationRatingCreateOrConnectWithoutUserInput | AccommodationRatingCreateOrConnectWithoutUserInput[]
    createMany?: AccommodationRatingCreateManyUserInputEnvelope
    connect?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
  }

  export type UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UniversityApplicationsCreateWithoutUserInput, UniversityApplicationsUncheckedCreateWithoutUserInput> | UniversityApplicationsCreateWithoutUserInput[] | UniversityApplicationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UniversityApplicationsCreateOrConnectWithoutUserInput | UniversityApplicationsCreateOrConnectWithoutUserInput[]
    createMany?: UniversityApplicationsCreateManyUserInputEnvelope
    connect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type AccommodationUncheckedCreateNestedManyWithoutLandlordInput = {
    create?: XOR<AccommodationCreateWithoutLandlordInput, AccommodationUncheckedCreateWithoutLandlordInput> | AccommodationCreateWithoutLandlordInput[] | AccommodationUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: AccommodationCreateOrConnectWithoutLandlordInput | AccommodationCreateOrConnectWithoutLandlordInput[]
    createMany?: AccommodationCreateManyLandlordInputEnvelope
    connect?: AccommodationWhereUniqueInput | AccommodationWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type OTPUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput> | OTPCreateWithoutUserInput[] | OTPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OTPCreateOrConnectWithoutUserInput | OTPCreateOrConnectWithoutUserInput[]
    createMany?: OTPCreateManyUserInputEnvelope
    connect?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<GroupCreateWithoutCreatedByInput, GroupUncheckedCreateWithoutCreatedByInput> | GroupCreateWithoutCreatedByInput[] | GroupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCreatedByInput | GroupCreateOrConnectWithoutCreatedByInput[]
    createMany?: GroupCreateManyCreatedByInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutModeratorsInput = {
    create?: XOR<GroupCreateWithoutModeratorsInput, GroupUncheckedCreateWithoutModeratorsInput> | GroupCreateWithoutModeratorsInput[] | GroupUncheckedCreateWithoutModeratorsInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutModeratorsInput | GroupCreateOrConnectWithoutModeratorsInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutContactByInput = {
    create?: XOR<EventCreateWithoutContactByInput, EventUncheckedCreateWithoutContactByInput> | EventCreateWithoutContactByInput[] | EventUncheckedCreateWithoutContactByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutContactByInput | EventCreateOrConnectWithoutContactByInput[]
    createMany?: EventCreateManyContactByInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ArticleUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ArticleCreateWithoutCreatorInput, ArticleUncheckedCreateWithoutCreatorInput> | ArticleCreateWithoutCreatorInput[] | ArticleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutCreatorInput | ArticleCreateOrConnectWithoutCreatorInput[]
    createMany?: ArticleCreateManyCreatorInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type AccommodationReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccommodationReviewCreateWithoutUserInput, AccommodationReviewUncheckedCreateWithoutUserInput> | AccommodationReviewCreateWithoutUserInput[] | AccommodationReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccommodationReviewCreateOrConnectWithoutUserInput | AccommodationReviewCreateOrConnectWithoutUserInput[]
    createMany?: AccommodationReviewCreateManyUserInputEnvelope
    connect?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
  }

  export type LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikedAccommodationsCreateWithoutUserInput, LikedAccommodationsUncheckedCreateWithoutUserInput> | LikedAccommodationsCreateWithoutUserInput[] | LikedAccommodationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikedAccommodationsCreateOrConnectWithoutUserInput | LikedAccommodationsCreateOrConnectWithoutUserInput[]
    createMany?: LikedAccommodationsCreateManyUserInputEnvelope
    connect?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type FavCourseUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavCourseCreateWithoutUserInput, FavCourseUncheckedCreateWithoutUserInput> | FavCourseCreateWithoutUserInput[] | FavCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavCourseCreateOrConnectWithoutUserInput | FavCourseCreateOrConnectWithoutUserInput[]
    upsert?: FavCourseUpsertWithWhereUniqueWithoutUserInput | FavCourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavCourseCreateManyUserInputEnvelope
    set?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    disconnect?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    delete?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    connect?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    update?: FavCourseUpdateWithWhereUniqueWithoutUserInput | FavCourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavCourseUpdateManyWithWhereWithoutUserInput | FavCourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavCourseScalarWhereInput | FavCourseScalarWhereInput[]
  }

  export type QuizAnswerUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutUserInput, QuizAnswerUncheckedCreateWithoutUserInput> | QuizAnswerCreateWithoutUserInput[] | QuizAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutUserInput | QuizAnswerCreateOrConnectWithoutUserInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutUserInput | QuizAnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizAnswerCreateManyUserInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutUserInput | QuizAnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutUserInput | QuizAnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type ForumUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ForumCreateWithoutCreatorInput, ForumUncheckedCreateWithoutCreatorInput> | ForumCreateWithoutCreatorInput[] | ForumUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ForumCreateOrConnectWithoutCreatorInput | ForumCreateOrConnectWithoutCreatorInput[]
    upsert?: ForumUpsertWithWhereUniqueWithoutCreatorInput | ForumUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ForumCreateManyCreatorInputEnvelope
    set?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    disconnect?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    delete?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    connect?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    update?: ForumUpdateWithWhereUniqueWithoutCreatorInput | ForumUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ForumUpdateManyWithWhereWithoutCreatorInput | ForumUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ForumScalarWhereInput | ForumScalarWhereInput[]
  }

  export type ForumTopicUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ForumTopicCreateWithoutCreatorInput, ForumTopicUncheckedCreateWithoutCreatorInput> | ForumTopicCreateWithoutCreatorInput[] | ForumTopicUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ForumTopicCreateOrConnectWithoutCreatorInput | ForumTopicCreateOrConnectWithoutCreatorInput[]
    upsert?: ForumTopicUpsertWithWhereUniqueWithoutCreatorInput | ForumTopicUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ForumTopicCreateManyCreatorInputEnvelope
    set?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    disconnect?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    delete?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    connect?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    update?: ForumTopicUpdateWithWhereUniqueWithoutCreatorInput | ForumTopicUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ForumTopicUpdateManyWithWhereWithoutCreatorInput | ForumTopicUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ForumTopicScalarWhereInput | ForumTopicScalarWhereInput[]
  }

  export type ForumReplyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumReplyCreateWithoutUserInput, ForumReplyUncheckedCreateWithoutUserInput> | ForumReplyCreateWithoutUserInput[] | ForumReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutUserInput | ForumReplyCreateOrConnectWithoutUserInput[]
    upsert?: ForumReplyUpsertWithWhereUniqueWithoutUserInput | ForumReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumReplyCreateManyUserInputEnvelope
    set?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    disconnect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    delete?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    update?: ForumReplyUpdateWithWhereUniqueWithoutUserInput | ForumReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumReplyUpdateManyWithWhereWithoutUserInput | ForumReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
  }

  export type ForumPostUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ForumPostCreateWithoutCreatorInput, ForumPostUncheckedCreateWithoutCreatorInput> | ForumPostCreateWithoutCreatorInput[] | ForumPostUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutCreatorInput | ForumPostCreateOrConnectWithoutCreatorInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutCreatorInput | ForumPostUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ForumPostCreateManyCreatorInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutCreatorInput | ForumPostUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutCreatorInput | ForumPostUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumReplyReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumReplyReactionCreateWithoutUserInput, ForumReplyReactionUncheckedCreateWithoutUserInput> | ForumReplyReactionCreateWithoutUserInput[] | ForumReplyReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumReplyReactionCreateOrConnectWithoutUserInput | ForumReplyReactionCreateOrConnectWithoutUserInput[]
    upsert?: ForumReplyReactionUpsertWithWhereUniqueWithoutUserInput | ForumReplyReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumReplyReactionCreateManyUserInputEnvelope
    set?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    disconnect?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    delete?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    connect?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    update?: ForumReplyReactionUpdateWithWhereUniqueWithoutUserInput | ForumReplyReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumReplyReactionUpdateManyWithWhereWithoutUserInput | ForumReplyReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumReplyReactionScalarWhereInput | ForumReplyReactionScalarWhereInput[]
  }

  export type ForumPostReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumPostReactionCreateWithoutUserInput, ForumPostReactionUncheckedCreateWithoutUserInput> | ForumPostReactionCreateWithoutUserInput[] | ForumPostReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostReactionCreateOrConnectWithoutUserInput | ForumPostReactionCreateOrConnectWithoutUserInput[]
    upsert?: ForumPostReactionUpsertWithWhereUniqueWithoutUserInput | ForumPostReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumPostReactionCreateManyUserInputEnvelope
    set?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    disconnect?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    delete?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    connect?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    update?: ForumPostReactionUpdateWithWhereUniqueWithoutUserInput | ForumPostReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumPostReactionUpdateManyWithWhereWithoutUserInput | ForumPostReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumPostReactionScalarWhereInput | ForumPostReactionScalarWhereInput[]
  }

  export type UniversityUpdateOneWithoutUsersNestedInput = {
    create?: XOR<UniversityCreateWithoutUsersInput, UniversityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: UniversityCreateOrConnectWithoutUsersInput
    upsert?: UniversityUpsertWithoutUsersInput
    disconnect?: UniversityWhereInput | boolean
    delete?: UniversityWhereInput | boolean
    connect?: UniversityWhereUniqueInput
    update?: XOR<XOR<UniversityUpdateToOneWithWhereWithoutUsersInput, UniversityUpdateWithoutUsersInput>, UniversityUncheckedUpdateWithoutUsersInput>
  }

  export type LoanApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutUserInput, LoanApplicationUncheckedCreateWithoutUserInput> | LoanApplicationCreateWithoutUserInput[] | LoanApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutUserInput | LoanApplicationCreateOrConnectWithoutUserInput[]
    upsert?: LoanApplicationUpsertWithWhereUniqueWithoutUserInput | LoanApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LoanApplicationCreateManyUserInputEnvelope
    set?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    disconnect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    delete?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    update?: LoanApplicationUpdateWithWhereUniqueWithoutUserInput | LoanApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LoanApplicationUpdateManyWithWhereWithoutUserInput | LoanApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
  }

  export type AccommodationRatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccommodationRatingCreateWithoutUserInput, AccommodationRatingUncheckedCreateWithoutUserInput> | AccommodationRatingCreateWithoutUserInput[] | AccommodationRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccommodationRatingCreateOrConnectWithoutUserInput | AccommodationRatingCreateOrConnectWithoutUserInput[]
    upsert?: AccommodationRatingUpsertWithWhereUniqueWithoutUserInput | AccommodationRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccommodationRatingCreateManyUserInputEnvelope
    set?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    disconnect?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    delete?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    connect?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    update?: AccommodationRatingUpdateWithWhereUniqueWithoutUserInput | AccommodationRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccommodationRatingUpdateManyWithWhereWithoutUserInput | AccommodationRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccommodationRatingScalarWhereInput | AccommodationRatingScalarWhereInput[]
  }

  export type UniversityApplicationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UniversityApplicationsCreateWithoutUserInput, UniversityApplicationsUncheckedCreateWithoutUserInput> | UniversityApplicationsCreateWithoutUserInput[] | UniversityApplicationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UniversityApplicationsCreateOrConnectWithoutUserInput | UniversityApplicationsCreateOrConnectWithoutUserInput[]
    upsert?: UniversityApplicationsUpsertWithWhereUniqueWithoutUserInput | UniversityApplicationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UniversityApplicationsCreateManyUserInputEnvelope
    set?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    disconnect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    delete?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    connect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    update?: UniversityApplicationsUpdateWithWhereUniqueWithoutUserInput | UniversityApplicationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UniversityApplicationsUpdateManyWithWhereWithoutUserInput | UniversityApplicationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UniversityApplicationsScalarWhereInput | UniversityApplicationsScalarWhereInput[]
  }

  export type TokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type AccommodationUpdateManyWithoutLandlordNestedInput = {
    create?: XOR<AccommodationCreateWithoutLandlordInput, AccommodationUncheckedCreateWithoutLandlordInput> | AccommodationCreateWithoutLandlordInput[] | AccommodationUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: AccommodationCreateOrConnectWithoutLandlordInput | AccommodationCreateOrConnectWithoutLandlordInput[]
    upsert?: AccommodationUpsertWithWhereUniqueWithoutLandlordInput | AccommodationUpsertWithWhereUniqueWithoutLandlordInput[]
    createMany?: AccommodationCreateManyLandlordInputEnvelope
    set?: AccommodationWhereUniqueInput | AccommodationWhereUniqueInput[]
    disconnect?: AccommodationWhereUniqueInput | AccommodationWhereUniqueInput[]
    delete?: AccommodationWhereUniqueInput | AccommodationWhereUniqueInput[]
    connect?: AccommodationWhereUniqueInput | AccommodationWhereUniqueInput[]
    update?: AccommodationUpdateWithWhereUniqueWithoutLandlordInput | AccommodationUpdateWithWhereUniqueWithoutLandlordInput[]
    updateMany?: AccommodationUpdateManyWithWhereWithoutLandlordInput | AccommodationUpdateManyWithWhereWithoutLandlordInput[]
    deleteMany?: AccommodationScalarWhereInput | AccommodationScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type OTPUpdateManyWithoutUserNestedInput = {
    create?: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput> | OTPCreateWithoutUserInput[] | OTPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OTPCreateOrConnectWithoutUserInput | OTPCreateOrConnectWithoutUserInput[]
    upsert?: OTPUpsertWithWhereUniqueWithoutUserInput | OTPUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OTPCreateManyUserInputEnvelope
    set?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    disconnect?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    delete?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    connect?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    update?: OTPUpdateWithWhereUniqueWithoutUserInput | OTPUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OTPUpdateManyWithWhereWithoutUserInput | OTPUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OTPScalarWhereInput | OTPScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<GroupCreateWithoutCreatedByInput, GroupUncheckedCreateWithoutCreatedByInput> | GroupCreateWithoutCreatedByInput[] | GroupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCreatedByInput | GroupCreateOrConnectWithoutCreatedByInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutCreatedByInput | GroupUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: GroupCreateManyCreatedByInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutCreatedByInput | GroupUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutCreatedByInput | GroupUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutModeratorsNestedInput = {
    create?: XOR<GroupCreateWithoutModeratorsInput, GroupUncheckedCreateWithoutModeratorsInput> | GroupCreateWithoutModeratorsInput[] | GroupUncheckedCreateWithoutModeratorsInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutModeratorsInput | GroupCreateOrConnectWithoutModeratorsInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutModeratorsInput | GroupUpsertWithWhereUniqueWithoutModeratorsInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutModeratorsInput | GroupUpdateWithWhereUniqueWithoutModeratorsInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutModeratorsInput | GroupUpdateManyWithWhereWithoutModeratorsInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type GroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type EventUpdateManyWithoutContactByNestedInput = {
    create?: XOR<EventCreateWithoutContactByInput, EventUncheckedCreateWithoutContactByInput> | EventCreateWithoutContactByInput[] | EventUncheckedCreateWithoutContactByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutContactByInput | EventCreateOrConnectWithoutContactByInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutContactByInput | EventUpsertWithWhereUniqueWithoutContactByInput[]
    createMany?: EventCreateManyContactByInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutContactByInput | EventUpdateWithWhereUniqueWithoutContactByInput[]
    updateMany?: EventUpdateManyWithWhereWithoutContactByInput | EventUpdateManyWithWhereWithoutContactByInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ArticleUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ArticleCreateWithoutCreatorInput, ArticleUncheckedCreateWithoutCreatorInput> | ArticleCreateWithoutCreatorInput[] | ArticleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutCreatorInput | ArticleCreateOrConnectWithoutCreatorInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutCreatorInput | ArticleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ArticleCreateManyCreatorInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutCreatorInput | ArticleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutCreatorInput | ArticleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type AccommodationReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccommodationReviewCreateWithoutUserInput, AccommodationReviewUncheckedCreateWithoutUserInput> | AccommodationReviewCreateWithoutUserInput[] | AccommodationReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccommodationReviewCreateOrConnectWithoutUserInput | AccommodationReviewCreateOrConnectWithoutUserInput[]
    upsert?: AccommodationReviewUpsertWithWhereUniqueWithoutUserInput | AccommodationReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccommodationReviewCreateManyUserInputEnvelope
    set?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    disconnect?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    delete?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    connect?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    update?: AccommodationReviewUpdateWithWhereUniqueWithoutUserInput | AccommodationReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccommodationReviewUpdateManyWithWhereWithoutUserInput | AccommodationReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccommodationReviewScalarWhereInput | AccommodationReviewScalarWhereInput[]
  }

  export type LikedAccommodationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikedAccommodationsCreateWithoutUserInput, LikedAccommodationsUncheckedCreateWithoutUserInput> | LikedAccommodationsCreateWithoutUserInput[] | LikedAccommodationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikedAccommodationsCreateOrConnectWithoutUserInput | LikedAccommodationsCreateOrConnectWithoutUserInput[]
    upsert?: LikedAccommodationsUpsertWithWhereUniqueWithoutUserInput | LikedAccommodationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikedAccommodationsCreateManyUserInputEnvelope
    set?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    disconnect?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    delete?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    connect?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    update?: LikedAccommodationsUpdateWithWhereUniqueWithoutUserInput | LikedAccommodationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikedAccommodationsUpdateManyWithWhereWithoutUserInput | LikedAccommodationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikedAccommodationsScalarWhereInput | LikedAccommodationsScalarWhereInput[]
  }

  export type FavCourseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavCourseCreateWithoutUserInput, FavCourseUncheckedCreateWithoutUserInput> | FavCourseCreateWithoutUserInput[] | FavCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavCourseCreateOrConnectWithoutUserInput | FavCourseCreateOrConnectWithoutUserInput[]
    upsert?: FavCourseUpsertWithWhereUniqueWithoutUserInput | FavCourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavCourseCreateManyUserInputEnvelope
    set?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    disconnect?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    delete?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    connect?: FavCourseWhereUniqueInput | FavCourseWhereUniqueInput[]
    update?: FavCourseUpdateWithWhereUniqueWithoutUserInput | FavCourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavCourseUpdateManyWithWhereWithoutUserInput | FavCourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavCourseScalarWhereInput | FavCourseScalarWhereInput[]
  }

  export type QuizAnswerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutUserInput, QuizAnswerUncheckedCreateWithoutUserInput> | QuizAnswerCreateWithoutUserInput[] | QuizAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutUserInput | QuizAnswerCreateOrConnectWithoutUserInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutUserInput | QuizAnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizAnswerCreateManyUserInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutUserInput | QuizAnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutUserInput | QuizAnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type ForumUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ForumCreateWithoutCreatorInput, ForumUncheckedCreateWithoutCreatorInput> | ForumCreateWithoutCreatorInput[] | ForumUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ForumCreateOrConnectWithoutCreatorInput | ForumCreateOrConnectWithoutCreatorInput[]
    upsert?: ForumUpsertWithWhereUniqueWithoutCreatorInput | ForumUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ForumCreateManyCreatorInputEnvelope
    set?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    disconnect?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    delete?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    connect?: ForumWhereUniqueInput | ForumWhereUniqueInput[]
    update?: ForumUpdateWithWhereUniqueWithoutCreatorInput | ForumUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ForumUpdateManyWithWhereWithoutCreatorInput | ForumUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ForumScalarWhereInput | ForumScalarWhereInput[]
  }

  export type ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ForumTopicCreateWithoutCreatorInput, ForumTopicUncheckedCreateWithoutCreatorInput> | ForumTopicCreateWithoutCreatorInput[] | ForumTopicUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ForumTopicCreateOrConnectWithoutCreatorInput | ForumTopicCreateOrConnectWithoutCreatorInput[]
    upsert?: ForumTopicUpsertWithWhereUniqueWithoutCreatorInput | ForumTopicUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ForumTopicCreateManyCreatorInputEnvelope
    set?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    disconnect?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    delete?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    connect?: ForumTopicWhereUniqueInput | ForumTopicWhereUniqueInput[]
    update?: ForumTopicUpdateWithWhereUniqueWithoutCreatorInput | ForumTopicUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ForumTopicUpdateManyWithWhereWithoutCreatorInput | ForumTopicUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ForumTopicScalarWhereInput | ForumTopicScalarWhereInput[]
  }

  export type ForumReplyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumReplyCreateWithoutUserInput, ForumReplyUncheckedCreateWithoutUserInput> | ForumReplyCreateWithoutUserInput[] | ForumReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumReplyCreateOrConnectWithoutUserInput | ForumReplyCreateOrConnectWithoutUserInput[]
    upsert?: ForumReplyUpsertWithWhereUniqueWithoutUserInput | ForumReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumReplyCreateManyUserInputEnvelope
    set?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    disconnect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    delete?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    connect?: ForumReplyWhereUniqueInput | ForumReplyWhereUniqueInput[]
    update?: ForumReplyUpdateWithWhereUniqueWithoutUserInput | ForumReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumReplyUpdateManyWithWhereWithoutUserInput | ForumReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
  }

  export type ForumPostUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ForumPostCreateWithoutCreatorInput, ForumPostUncheckedCreateWithoutCreatorInput> | ForumPostCreateWithoutCreatorInput[] | ForumPostUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutCreatorInput | ForumPostCreateOrConnectWithoutCreatorInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutCreatorInput | ForumPostUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ForumPostCreateManyCreatorInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutCreatorInput | ForumPostUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutCreatorInput | ForumPostUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumReplyReactionCreateWithoutUserInput, ForumReplyReactionUncheckedCreateWithoutUserInput> | ForumReplyReactionCreateWithoutUserInput[] | ForumReplyReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumReplyReactionCreateOrConnectWithoutUserInput | ForumReplyReactionCreateOrConnectWithoutUserInput[]
    upsert?: ForumReplyReactionUpsertWithWhereUniqueWithoutUserInput | ForumReplyReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumReplyReactionCreateManyUserInputEnvelope
    set?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    disconnect?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    delete?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    connect?: ForumReplyReactionWhereUniqueInput | ForumReplyReactionWhereUniqueInput[]
    update?: ForumReplyReactionUpdateWithWhereUniqueWithoutUserInput | ForumReplyReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumReplyReactionUpdateManyWithWhereWithoutUserInput | ForumReplyReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumReplyReactionScalarWhereInput | ForumReplyReactionScalarWhereInput[]
  }

  export type ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumPostReactionCreateWithoutUserInput, ForumPostReactionUncheckedCreateWithoutUserInput> | ForumPostReactionCreateWithoutUserInput[] | ForumPostReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostReactionCreateOrConnectWithoutUserInput | ForumPostReactionCreateOrConnectWithoutUserInput[]
    upsert?: ForumPostReactionUpsertWithWhereUniqueWithoutUserInput | ForumPostReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumPostReactionCreateManyUserInputEnvelope
    set?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    disconnect?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    delete?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    connect?: ForumPostReactionWhereUniqueInput | ForumPostReactionWhereUniqueInput[]
    update?: ForumPostReactionUpdateWithWhereUniqueWithoutUserInput | ForumPostReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumPostReactionUpdateManyWithWhereWithoutUserInput | ForumPostReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumPostReactionScalarWhereInput | ForumPostReactionScalarWhereInput[]
  }

  export type LoanApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LoanApplicationCreateWithoutUserInput, LoanApplicationUncheckedCreateWithoutUserInput> | LoanApplicationCreateWithoutUserInput[] | LoanApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoanApplicationCreateOrConnectWithoutUserInput | LoanApplicationCreateOrConnectWithoutUserInput[]
    upsert?: LoanApplicationUpsertWithWhereUniqueWithoutUserInput | LoanApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LoanApplicationCreateManyUserInputEnvelope
    set?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    disconnect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    delete?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    connect?: LoanApplicationWhereUniqueInput | LoanApplicationWhereUniqueInput[]
    update?: LoanApplicationUpdateWithWhereUniqueWithoutUserInput | LoanApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LoanApplicationUpdateManyWithWhereWithoutUserInput | LoanApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
  }

  export type AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccommodationRatingCreateWithoutUserInput, AccommodationRatingUncheckedCreateWithoutUserInput> | AccommodationRatingCreateWithoutUserInput[] | AccommodationRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccommodationRatingCreateOrConnectWithoutUserInput | AccommodationRatingCreateOrConnectWithoutUserInput[]
    upsert?: AccommodationRatingUpsertWithWhereUniqueWithoutUserInput | AccommodationRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccommodationRatingCreateManyUserInputEnvelope
    set?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    disconnect?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    delete?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    connect?: AccommodationRatingWhereUniqueInput | AccommodationRatingWhereUniqueInput[]
    update?: AccommodationRatingUpdateWithWhereUniqueWithoutUserInput | AccommodationRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccommodationRatingUpdateManyWithWhereWithoutUserInput | AccommodationRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccommodationRatingScalarWhereInput | AccommodationRatingScalarWhereInput[]
  }

  export type UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UniversityApplicationsCreateWithoutUserInput, UniversityApplicationsUncheckedCreateWithoutUserInput> | UniversityApplicationsCreateWithoutUserInput[] | UniversityApplicationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UniversityApplicationsCreateOrConnectWithoutUserInput | UniversityApplicationsCreateOrConnectWithoutUserInput[]
    upsert?: UniversityApplicationsUpsertWithWhereUniqueWithoutUserInput | UniversityApplicationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UniversityApplicationsCreateManyUserInputEnvelope
    set?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    disconnect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    delete?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    connect?: UniversityApplicationsWhereUniqueInput | UniversityApplicationsWhereUniqueInput[]
    update?: UniversityApplicationsUpdateWithWhereUniqueWithoutUserInput | UniversityApplicationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UniversityApplicationsUpdateManyWithWhereWithoutUserInput | UniversityApplicationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UniversityApplicationsScalarWhereInput | UniversityApplicationsScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type AccommodationUncheckedUpdateManyWithoutLandlordNestedInput = {
    create?: XOR<AccommodationCreateWithoutLandlordInput, AccommodationUncheckedCreateWithoutLandlordInput> | AccommodationCreateWithoutLandlordInput[] | AccommodationUncheckedCreateWithoutLandlordInput[]
    connectOrCreate?: AccommodationCreateOrConnectWithoutLandlordInput | AccommodationCreateOrConnectWithoutLandlordInput[]
    upsert?: AccommodationUpsertWithWhereUniqueWithoutLandlordInput | AccommodationUpsertWithWhereUniqueWithoutLandlordInput[]
    createMany?: AccommodationCreateManyLandlordInputEnvelope
    set?: AccommodationWhereUniqueInput | AccommodationWhereUniqueInput[]
    disconnect?: AccommodationWhereUniqueInput | AccommodationWhereUniqueInput[]
    delete?: AccommodationWhereUniqueInput | AccommodationWhereUniqueInput[]
    connect?: AccommodationWhereUniqueInput | AccommodationWhereUniqueInput[]
    update?: AccommodationUpdateWithWhereUniqueWithoutLandlordInput | AccommodationUpdateWithWhereUniqueWithoutLandlordInput[]
    updateMany?: AccommodationUpdateManyWithWhereWithoutLandlordInput | AccommodationUpdateManyWithWhereWithoutLandlordInput[]
    deleteMany?: AccommodationScalarWhereInput | AccommodationScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type OTPUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput> | OTPCreateWithoutUserInput[] | OTPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OTPCreateOrConnectWithoutUserInput | OTPCreateOrConnectWithoutUserInput[]
    upsert?: OTPUpsertWithWhereUniqueWithoutUserInput | OTPUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OTPCreateManyUserInputEnvelope
    set?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    disconnect?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    delete?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    connect?: OTPWhereUniqueInput | OTPWhereUniqueInput[]
    update?: OTPUpdateWithWhereUniqueWithoutUserInput | OTPUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OTPUpdateManyWithWhereWithoutUserInput | OTPUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OTPScalarWhereInput | OTPScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<GroupCreateWithoutCreatedByInput, GroupUncheckedCreateWithoutCreatedByInput> | GroupCreateWithoutCreatedByInput[] | GroupUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCreatedByInput | GroupCreateOrConnectWithoutCreatedByInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutCreatedByInput | GroupUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: GroupCreateManyCreatedByInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutCreatedByInput | GroupUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutCreatedByInput | GroupUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutModeratorsNestedInput = {
    create?: XOR<GroupCreateWithoutModeratorsInput, GroupUncheckedCreateWithoutModeratorsInput> | GroupCreateWithoutModeratorsInput[] | GroupUncheckedCreateWithoutModeratorsInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutModeratorsInput | GroupCreateOrConnectWithoutModeratorsInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutModeratorsInput | GroupUpsertWithWhereUniqueWithoutModeratorsInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutModeratorsInput | GroupUpdateWithWhereUniqueWithoutModeratorsInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutModeratorsInput | GroupUpdateManyWithWhereWithoutModeratorsInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutContactByNestedInput = {
    create?: XOR<EventCreateWithoutContactByInput, EventUncheckedCreateWithoutContactByInput> | EventCreateWithoutContactByInput[] | EventUncheckedCreateWithoutContactByInput[]
    connectOrCreate?: EventCreateOrConnectWithoutContactByInput | EventCreateOrConnectWithoutContactByInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutContactByInput | EventUpsertWithWhereUniqueWithoutContactByInput[]
    createMany?: EventCreateManyContactByInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutContactByInput | EventUpdateWithWhereUniqueWithoutContactByInput[]
    updateMany?: EventUpdateManyWithWhereWithoutContactByInput | EventUpdateManyWithWhereWithoutContactByInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ArticleUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ArticleCreateWithoutCreatorInput, ArticleUncheckedCreateWithoutCreatorInput> | ArticleCreateWithoutCreatorInput[] | ArticleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutCreatorInput | ArticleCreateOrConnectWithoutCreatorInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutCreatorInput | ArticleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ArticleCreateManyCreatorInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutCreatorInput | ArticleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutCreatorInput | ArticleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccommodationReviewCreateWithoutUserInput, AccommodationReviewUncheckedCreateWithoutUserInput> | AccommodationReviewCreateWithoutUserInput[] | AccommodationReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccommodationReviewCreateOrConnectWithoutUserInput | AccommodationReviewCreateOrConnectWithoutUserInput[]
    upsert?: AccommodationReviewUpsertWithWhereUniqueWithoutUserInput | AccommodationReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccommodationReviewCreateManyUserInputEnvelope
    set?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    disconnect?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    delete?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    connect?: AccommodationReviewWhereUniqueInput | AccommodationReviewWhereUniqueInput[]
    update?: AccommodationReviewUpdateWithWhereUniqueWithoutUserInput | AccommodationReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccommodationReviewUpdateManyWithWhereWithoutUserInput | AccommodationReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccommodationReviewScalarWhereInput | AccommodationReviewScalarWhereInput[]
  }

  export type LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikedAccommodationsCreateWithoutUserInput, LikedAccommodationsUncheckedCreateWithoutUserInput> | LikedAccommodationsCreateWithoutUserInput[] | LikedAccommodationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikedAccommodationsCreateOrConnectWithoutUserInput | LikedAccommodationsCreateOrConnectWithoutUserInput[]
    upsert?: LikedAccommodationsUpsertWithWhereUniqueWithoutUserInput | LikedAccommodationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikedAccommodationsCreateManyUserInputEnvelope
    set?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    disconnect?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    delete?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    connect?: LikedAccommodationsWhereUniqueInput | LikedAccommodationsWhereUniqueInput[]
    update?: LikedAccommodationsUpdateWithWhereUniqueWithoutUserInput | LikedAccommodationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikedAccommodationsUpdateManyWithWhereWithoutUserInput | LikedAccommodationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikedAccommodationsScalarWhereInput | LikedAccommodationsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutQuizAnswersInput = {
    create?: XOR<UserCreateWithoutQuizAnswersInput, UserUncheckedCreateWithoutQuizAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizAnswersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutQuizAnswersNestedInput = {
    create?: XOR<UserCreateWithoutQuizAnswersInput, UserUncheckedCreateWithoutQuizAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizAnswersInput
    upsert?: UserUpsertWithoutQuizAnswersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuizAnswersInput, UserUpdateWithoutQuizAnswersInput>, UserUncheckedUpdateWithoutQuizAnswersInput>
  }

  export type UserCreateNestedOneWithoutLikedAccommodationsInput = {
    create?: XOR<UserCreateWithoutLikedAccommodationsInput, UserUncheckedCreateWithoutLikedAccommodationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedAccommodationsInput
    connect?: UserWhereUniqueInput
  }

  export type AccommodationCreateNestedOneWithoutLikedByInput = {
    create?: XOR<AccommodationCreateWithoutLikedByInput, AccommodationUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: AccommodationCreateOrConnectWithoutLikedByInput
    connect?: AccommodationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikedAccommodationsNestedInput = {
    create?: XOR<UserCreateWithoutLikedAccommodationsInput, UserUncheckedCreateWithoutLikedAccommodationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikedAccommodationsInput
    upsert?: UserUpsertWithoutLikedAccommodationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikedAccommodationsInput, UserUpdateWithoutLikedAccommodationsInput>, UserUncheckedUpdateWithoutLikedAccommodationsInput>
  }

  export type AccommodationUpdateOneRequiredWithoutLikedByNestedInput = {
    create?: XOR<AccommodationCreateWithoutLikedByInput, AccommodationUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: AccommodationCreateOrConnectWithoutLikedByInput
    upsert?: AccommodationUpsertWithoutLikedByInput
    connect?: AccommodationWhereUniqueInput
    update?: XOR<XOR<AccommodationUpdateToOneWithWhereWithoutLikedByInput, AccommodationUpdateWithoutLikedByInput>, AccommodationUncheckedUpdateWithoutLikedByInput>
  }

  export type UserCreateNestedOneWithoutTokensInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTokenTypeFieldUpdateOperationsInput = {
    set?: $Enums.TokenType
  }

  export type UserUpdateOneRequiredWithoutTokensNestedInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    upsert?: UserUpsertWithoutTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokensInput, UserUpdateWithoutTokensInput>, UserUncheckedUpdateWithoutTokensInput>
  }

  export type UserCreateNestedOneWithoutOtpsInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOTPTypeFieldUpdateOperationsInput = {
    set?: $Enums.OTPType
  }

  export type EnumOTPPurposeFieldUpdateOperationsInput = {
    set?: $Enums.OTPPurpose
  }

  export type UserUpdateOneRequiredWithoutOtpsNestedInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    upsert?: UserUpsertWithoutOtpsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtpsInput, UserUpdateWithoutOtpsInput>, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type ContentBlockCreateNestedManyWithoutBlogInput = {
    create?: XOR<ContentBlockCreateWithoutBlogInput, ContentBlockUncheckedCreateWithoutBlogInput> | ContentBlockCreateWithoutBlogInput[] | ContentBlockUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: ContentBlockCreateOrConnectWithoutBlogInput | ContentBlockCreateOrConnectWithoutBlogInput[]
    createMany?: ContentBlockCreateManyBlogInputEnvelope
    connect?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
  }

  export type ContentBlockUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<ContentBlockCreateWithoutBlogInput, ContentBlockUncheckedCreateWithoutBlogInput> | ContentBlockCreateWithoutBlogInput[] | ContentBlockUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: ContentBlockCreateOrConnectWithoutBlogInput | ContentBlockCreateOrConnectWithoutBlogInput[]
    createMany?: ContentBlockCreateManyBlogInputEnvelope
    connect?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
  }

  export type ContentBlockUpdateManyWithoutBlogNestedInput = {
    create?: XOR<ContentBlockCreateWithoutBlogInput, ContentBlockUncheckedCreateWithoutBlogInput> | ContentBlockCreateWithoutBlogInput[] | ContentBlockUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: ContentBlockCreateOrConnectWithoutBlogInput | ContentBlockCreateOrConnectWithoutBlogInput[]
    upsert?: ContentBlockUpsertWithWhereUniqueWithoutBlogInput | ContentBlockUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: ContentBlockCreateManyBlogInputEnvelope
    set?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    disconnect?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    delete?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    connect?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    update?: ContentBlockUpdateWithWhereUniqueWithoutBlogInput | ContentBlockUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: ContentBlockUpdateManyWithWhereWithoutBlogInput | ContentBlockUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: ContentBlockScalarWhereInput | ContentBlockScalarWhereInput[]
  }

  export type ContentBlockUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<ContentBlockCreateWithoutBlogInput, ContentBlockUncheckedCreateWithoutBlogInput> | ContentBlockCreateWithoutBlogInput[] | ContentBlockUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: ContentBlockCreateOrConnectWithoutBlogInput | ContentBlockCreateOrConnectWithoutBlogInput[]
    upsert?: ContentBlockUpsertWithWhereUniqueWithoutBlogInput | ContentBlockUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: ContentBlockCreateManyBlogInputEnvelope
    set?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    disconnect?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    delete?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    connect?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    update?: ContentBlockUpdateWithWhereUniqueWithoutBlogInput | ContentBlockUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: ContentBlockUpdateManyWithWhereWithoutBlogInput | ContentBlockUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: ContentBlockScalarWhereInput | ContentBlockScalarWhereInput[]
  }

  export type BlogCreateNestedOneWithoutContentBlocksInput = {
    create?: XOR<BlogCreateWithoutContentBlocksInput, BlogUncheckedCreateWithoutContentBlocksInput>
    connectOrCreate?: BlogCreateOrConnectWithoutContentBlocksInput
    connect?: BlogWhereUniqueInput
  }

  export type BlogUpdateOneRequiredWithoutContentBlocksNestedInput = {
    create?: XOR<BlogCreateWithoutContentBlocksInput, BlogUncheckedCreateWithoutContentBlocksInput>
    connectOrCreate?: BlogCreateOrConnectWithoutContentBlocksInput
    upsert?: BlogUpsertWithoutContentBlocksInput
    connect?: BlogWhereUniqueInput
    update?: XOR<XOR<BlogUpdateToOneWithWhereWithoutContentBlocksInput, BlogUpdateWithoutContentBlocksInput>, BlogUncheckedUpdateWithoutContentBlocksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAccommodationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccommodationType | EnumAccommodationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccommodationType[] | ListEnumAccommodationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccommodationType[] | ListEnumAccommodationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccommodationTypeFilter<$PrismaModel> | $Enums.AccommodationType
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumFurnishingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FurnishingType | EnumFurnishingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FurnishingType[] | ListEnumFurnishingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FurnishingType[] | ListEnumFurnishingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFurnishingTypeNullableFilter<$PrismaModel> | $Enums.FurnishingType | null
  }

  export type NestedEnumAccommodationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccommodationType | EnumAccommodationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccommodationType[] | ListEnumAccommodationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccommodationType[] | ListEnumAccommodationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccommodationTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccommodationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccommodationTypeFilter<$PrismaModel>
    _max?: NestedEnumAccommodationTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumFurnishingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FurnishingType | EnumFurnishingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FurnishingType[] | ListEnumFurnishingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FurnishingType[] | ListEnumFurnishingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFurnishingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FurnishingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFurnishingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFurnishingTypeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeFilter<$PrismaModel> | $Enums.VoteType
  }

  export type NestedEnumVoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteTypeFilter<$PrismaModel>
    _max?: NestedEnumVoteTypeFilter<$PrismaModel>
  }

  export type NestedEnumGroupPrivacyFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupPrivacy | EnumGroupPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.GroupPrivacy[] | ListEnumGroupPrivacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupPrivacy[] | ListEnumGroupPrivacyFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupPrivacyFilter<$PrismaModel> | $Enums.GroupPrivacy
  }

  export type NestedEnumGroupPrivacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupPrivacy | EnumGroupPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.GroupPrivacy[] | ListEnumGroupPrivacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupPrivacy[] | ListEnumGroupPrivacyFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupPrivacyWithAggregatesFilter<$PrismaModel> | $Enums.GroupPrivacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupPrivacyFilter<$PrismaModel>
    _max?: NestedEnumGroupPrivacyFilter<$PrismaModel>
  }

  export type NestedEnumGroupMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupMemberRole | EnumGroupMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupMemberRoleFilter<$PrismaModel> | $Enums.GroupMemberRole
  }

  export type NestedEnumGroupMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupMemberRole | EnumGroupMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupMemberRole[] | ListEnumGroupMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.GroupMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumGroupMemberRoleFilter<$PrismaModel>
  }

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type NestedEnumRegistrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RegistrationType | EnumRegistrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RegistrationType[] | ListEnumRegistrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RegistrationType[] | ListEnumRegistrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRegistrationTypeFilter<$PrismaModel> | $Enums.RegistrationType
  }

  export type NestedEnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus
  }

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumRegistrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RegistrationType | EnumRegistrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RegistrationType[] | ListEnumRegistrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RegistrationType[] | ListEnumRegistrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRegistrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.RegistrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRegistrationTypeFilter<$PrismaModel>
    _max?: NestedEnumRegistrationTypeFilter<$PrismaModel>
  }

  export type NestedEnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventStatus[] | ListEnumEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventStatusFilter<$PrismaModel>
    _max?: NestedEnumEventStatusFilter<$PrismaModel>
  }

  export type NestedEnumEventRegistrationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventRegistrationStatus | EnumEventRegistrationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventRegistrationStatus[] | ListEnumEventRegistrationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventRegistrationStatus[] | ListEnumEventRegistrationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventRegistrationStatusFilter<$PrismaModel> | $Enums.EventRegistrationStatus
  }

  export type NestedEnumEventRegistrationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventRegistrationStatus | EnumEventRegistrationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EventRegistrationStatus[] | ListEnumEventRegistrationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventRegistrationStatus[] | ListEnumEventRegistrationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEventRegistrationStatusWithAggregatesFilter<$PrismaModel> | $Enums.EventRegistrationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventRegistrationStatusFilter<$PrismaModel>
    _max?: NestedEnumEventRegistrationStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumForumTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ForumType | EnumForumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ForumType[] | ListEnumForumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForumType[] | ListEnumForumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumForumTypeFilter<$PrismaModel> | $Enums.ForumType
  }

  export type NestedEnumForumPrivacyFilter<$PrismaModel = never> = {
    equals?: $Enums.ForumPrivacy | EnumForumPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.ForumPrivacy[] | ListEnumForumPrivacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForumPrivacy[] | ListEnumForumPrivacyFieldRefInput<$PrismaModel>
    not?: NestedEnumForumPrivacyFilter<$PrismaModel> | $Enums.ForumPrivacy
  }

  export type NestedEnumForumTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ForumType | EnumForumTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ForumType[] | ListEnumForumTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForumType[] | ListEnumForumTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumForumTypeWithAggregatesFilter<$PrismaModel> | $Enums.ForumType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumForumTypeFilter<$PrismaModel>
    _max?: NestedEnumForumTypeFilter<$PrismaModel>
  }

  export type NestedEnumForumPrivacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ForumPrivacy | EnumForumPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.ForumPrivacy[] | ListEnumForumPrivacyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ForumPrivacy[] | ListEnumForumPrivacyFieldRefInput<$PrismaModel>
    not?: NestedEnumForumPrivacyWithAggregatesFilter<$PrismaModel> | $Enums.ForumPrivacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumForumPrivacyFilter<$PrismaModel>
    _max?: NestedEnumForumPrivacyFilter<$PrismaModel>
  }

  export type NestedEnumTopicTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicType | EnumTopicTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicTypeFilter<$PrismaModel> | $Enums.TopicType
  }

  export type NestedEnumTopicStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicStatus | EnumTopicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicStatusFilter<$PrismaModel> | $Enums.TopicStatus
  }

  export type NestedEnumTopicTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicType | EnumTopicTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicType[] | ListEnumTopicTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicTypeWithAggregatesFilter<$PrismaModel> | $Enums.TopicType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTopicTypeFilter<$PrismaModel>
    _max?: NestedEnumTopicTypeFilter<$PrismaModel>
  }

  export type NestedEnumTopicStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicStatus | EnumTopicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicStatusWithAggregatesFilter<$PrismaModel> | $Enums.TopicStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTopicStatusFilter<$PrismaModel>
    _max?: NestedEnumTopicStatusFilter<$PrismaModel>
  }

  export type NestedEnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumArticleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleType | EnumArticleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleType[] | ListEnumArticleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArticleType[] | ListEnumArticleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArticleTypeFilter<$PrismaModel> | $Enums.ArticleType
  }

  export type NestedEnumArticleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleStatus | EnumArticleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArticleStatusFilter<$PrismaModel> | $Enums.ArticleStatus
  }

  export type NestedEnumArticleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleType | EnumArticleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleType[] | ListEnumArticleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArticleType[] | ListEnumArticleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArticleTypeWithAggregatesFilter<$PrismaModel> | $Enums.ArticleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArticleTypeFilter<$PrismaModel>
    _max?: NestedEnumArticleTypeFilter<$PrismaModel>
  }

  export type NestedEnumArticleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleStatus | EnumArticleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArticleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ArticleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArticleStatusFilter<$PrismaModel>
    _max?: NestedEnumArticleStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeFilter<$PrismaModel> | $Enums.TokenType
  }

  export type NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.TokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumTokenTypeFilter<$PrismaModel>
  }

  export type NestedEnumOTPTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPType | EnumOTPTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPTypeFilter<$PrismaModel> | $Enums.OTPType
  }

  export type NestedEnumOTPPurposeFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPPurpose | EnumOTPPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPPurposeFilter<$PrismaModel> | $Enums.OTPPurpose
  }

  export type NestedEnumOTPTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPType | EnumOTPTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPType[] | ListEnumOTPTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPTypeWithAggregatesFilter<$PrismaModel> | $Enums.OTPType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOTPTypeFilter<$PrismaModel>
    _max?: NestedEnumOTPTypeFilter<$PrismaModel>
  }

  export type NestedEnumOTPPurposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OTPPurpose | EnumOTPPurposeFieldRefInput<$PrismaModel>
    in?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OTPPurpose[] | ListEnumOTPPurposeFieldRefInput<$PrismaModel>
    not?: NestedEnumOTPPurposeWithAggregatesFilter<$PrismaModel> | $Enums.OTPPurpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOTPPurposeFilter<$PrismaModel>
    _max?: NestedEnumOTPPurposeFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccommodationRatingsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccommodationRatingsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccommodationRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccommodationRatingsInput, UserUncheckedCreateWithoutAccommodationRatingsInput>
  }

  export type AccommodationCreateWithoutRatingsInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    landlord: UserCreateNestedOneWithoutAccommodationsInput
    reviews?: AccommodationReviewCreateNestedManyWithoutAccommodationInput
    likedBy?: LikedAccommodationsCreateNestedManyWithoutAccommodationInput
    pricingPlans?: PricingPlanCreateNestedManyWithoutAccommodationInput
  }

  export type AccommodationUncheckedCreateWithoutRatingsInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    landlordId: string
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: AccommodationReviewUncheckedCreateNestedManyWithoutAccommodationInput
    likedBy?: LikedAccommodationsUncheckedCreateNestedManyWithoutAccommodationInput
    pricingPlans?: PricingPlanUncheckedCreateNestedManyWithoutAccommodationInput
  }

  export type AccommodationCreateOrConnectWithoutRatingsInput = {
    where: AccommodationWhereUniqueInput
    create: XOR<AccommodationCreateWithoutRatingsInput, AccommodationUncheckedCreateWithoutRatingsInput>
  }

  export type UserUpsertWithoutAccommodationRatingsInput = {
    update: XOR<UserUpdateWithoutAccommodationRatingsInput, UserUncheckedUpdateWithoutAccommodationRatingsInput>
    create: XOR<UserCreateWithoutAccommodationRatingsInput, UserUncheckedCreateWithoutAccommodationRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccommodationRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccommodationRatingsInput, UserUncheckedUpdateWithoutAccommodationRatingsInput>
  }

  export type UserUpdateWithoutAccommodationRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccommodationRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccommodationUpsertWithoutRatingsInput = {
    update: XOR<AccommodationUpdateWithoutRatingsInput, AccommodationUncheckedUpdateWithoutRatingsInput>
    create: XOR<AccommodationCreateWithoutRatingsInput, AccommodationUncheckedCreateWithoutRatingsInput>
    where?: AccommodationWhereInput
  }

  export type AccommodationUpdateToOneWithWhereWithoutRatingsInput = {
    where?: AccommodationWhereInput
    data: XOR<AccommodationUpdateWithoutRatingsInput, AccommodationUncheckedUpdateWithoutRatingsInput>
  }

  export type AccommodationUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    landlord?: UserUpdateOneRequiredWithoutAccommodationsNestedInput
    reviews?: AccommodationReviewUpdateManyWithoutAccommodationNestedInput
    likedBy?: LikedAccommodationsUpdateManyWithoutAccommodationNestedInput
    pricingPlans?: PricingPlanUpdateManyWithoutAccommodationNestedInput
  }

  export type AccommodationUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    landlordId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: AccommodationReviewUncheckedUpdateManyWithoutAccommodationNestedInput
    likedBy?: LikedAccommodationsUncheckedUpdateManyWithoutAccommodationNestedInput
    pricingPlans?: PricingPlanUncheckedUpdateManyWithoutAccommodationNestedInput
  }

  export type UniversityCreateWithoutCareerOutcomesInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    faqs?: FaqCreateNestedManyWithoutUniversityInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUniversityInput
    loans?: LoanCreateNestedManyWithoutUniversityInput
    users?: UserCreateNestedManyWithoutUniversityInput
    courses?: CourseCreateNestedManyWithoutUniversityInput
  }

  export type UniversityUncheckedCreateWithoutCareerOutcomesInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    faqs?: FaqUncheckedCreateNestedManyWithoutUniversityInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUniversityInput
    loans?: LoanUncheckedCreateNestedManyWithoutUniversityInput
    users?: UserUncheckedCreateNestedManyWithoutUniversityInput
    courses?: CourseUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityCreateOrConnectWithoutCareerOutcomesInput = {
    where: UniversityWhereUniqueInput
    create: XOR<UniversityCreateWithoutCareerOutcomesInput, UniversityUncheckedCreateWithoutCareerOutcomesInput>
  }

  export type UniversityUpsertWithoutCareerOutcomesInput = {
    update: XOR<UniversityUpdateWithoutCareerOutcomesInput, UniversityUncheckedUpdateWithoutCareerOutcomesInput>
    create: XOR<UniversityCreateWithoutCareerOutcomesInput, UniversityUncheckedCreateWithoutCareerOutcomesInput>
    where?: UniversityWhereInput
  }

  export type UniversityUpdateToOneWithWhereWithoutCareerOutcomesInput = {
    where?: UniversityWhereInput
    data: XOR<UniversityUpdateWithoutCareerOutcomesInput, UniversityUncheckedUpdateWithoutCareerOutcomesInput>
  }

  export type UniversityUpdateWithoutCareerOutcomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faqs?: FaqUpdateManyWithoutUniversityNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUniversityNestedInput
    loans?: LoanUpdateManyWithoutUniversityNestedInput
    users?: UserUpdateManyWithoutUniversityNestedInput
    courses?: CourseUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityUncheckedUpdateWithoutCareerOutcomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faqs?: FaqUncheckedUpdateManyWithoutUniversityNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUniversityNestedInput
    loans?: LoanUncheckedUpdateManyWithoutUniversityNestedInput
    users?: UserUncheckedUpdateManyWithoutUniversityNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityCreateWithoutFaqsInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    careerOutcomes?: CareerOutcomeCreateNestedManyWithoutUniversityInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUniversityInput
    loans?: LoanCreateNestedManyWithoutUniversityInput
    users?: UserCreateNestedManyWithoutUniversityInput
    courses?: CourseCreateNestedManyWithoutUniversityInput
  }

  export type UniversityUncheckedCreateWithoutFaqsInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    careerOutcomes?: CareerOutcomeUncheckedCreateNestedManyWithoutUniversityInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUniversityInput
    loans?: LoanUncheckedCreateNestedManyWithoutUniversityInput
    users?: UserUncheckedCreateNestedManyWithoutUniversityInput
    courses?: CourseUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityCreateOrConnectWithoutFaqsInput = {
    where: UniversityWhereUniqueInput
    create: XOR<UniversityCreateWithoutFaqsInput, UniversityUncheckedCreateWithoutFaqsInput>
  }

  export type UniversityUpsertWithoutFaqsInput = {
    update: XOR<UniversityUpdateWithoutFaqsInput, UniversityUncheckedUpdateWithoutFaqsInput>
    create: XOR<UniversityCreateWithoutFaqsInput, UniversityUncheckedCreateWithoutFaqsInput>
    where?: UniversityWhereInput
  }

  export type UniversityUpdateToOneWithWhereWithoutFaqsInput = {
    where?: UniversityWhereInput
    data: XOR<UniversityUpdateWithoutFaqsInput, UniversityUncheckedUpdateWithoutFaqsInput>
  }

  export type UniversityUpdateWithoutFaqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerOutcomes?: CareerOutcomeUpdateManyWithoutUniversityNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUniversityNestedInput
    loans?: LoanUpdateManyWithoutUniversityNestedInput
    users?: UserUpdateManyWithoutUniversityNestedInput
    courses?: CourseUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityUncheckedUpdateWithoutFaqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerOutcomes?: CareerOutcomeUncheckedUpdateManyWithoutUniversityNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUniversityNestedInput
    loans?: LoanUncheckedUpdateManyWithoutUniversityNestedInput
    users?: UserUncheckedUpdateManyWithoutUniversityNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type CareerOutcomeCreateWithoutUniversityInput = {
    id?: string
    iconName: string
    iconImage: string
    title: string
    value: string
    description: string
    details: string
    color: string
    bgColor: string
  }

  export type CareerOutcomeUncheckedCreateWithoutUniversityInput = {
    id?: string
    iconName: string
    iconImage: string
    title: string
    value: string
    description: string
    details: string
    color: string
    bgColor: string
  }

  export type CareerOutcomeCreateOrConnectWithoutUniversityInput = {
    where: CareerOutcomeWhereUniqueInput
    create: XOR<CareerOutcomeCreateWithoutUniversityInput, CareerOutcomeUncheckedCreateWithoutUniversityInput>
  }

  export type CareerOutcomeCreateManyUniversityInputEnvelope = {
    data: CareerOutcomeCreateManyUniversityInput | CareerOutcomeCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type FaqCreateWithoutUniversityInput = {
    id?: string
    question: string
    answer: string
  }

  export type FaqUncheckedCreateWithoutUniversityInput = {
    id?: string
    question: string
    answer: string
  }

  export type FaqCreateOrConnectWithoutUniversityInput = {
    where: FaqWhereUniqueInput
    create: XOR<FaqCreateWithoutUniversityInput, FaqUncheckedCreateWithoutUniversityInput>
  }

  export type FaqCreateManyUniversityInputEnvelope = {
    data: FaqCreateManyUniversityInput | FaqCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type UniversityApplicationsCreateWithoutUniversityInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    appliedAt?: Date | string
    loanRequired?: boolean
    documents?: UniversityApplicationsCreatedocumentsInput | string[]
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutApplicationsInput
    course: CourseCreateNestedOneWithoutApplicationsInput
  }

  export type UniversityApplicationsUncheckedCreateWithoutUniversityInput = {
    id?: string
    userId: string
    courseId: string
    status?: $Enums.ApplicationStatus
    appliedAt?: Date | string
    loanRequired?: boolean
    documents?: UniversityApplicationsCreatedocumentsInput | string[]
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityApplicationsCreateOrConnectWithoutUniversityInput = {
    where: UniversityApplicationsWhereUniqueInput
    create: XOR<UniversityApplicationsCreateWithoutUniversityInput, UniversityApplicationsUncheckedCreateWithoutUniversityInput>
  }

  export type UniversityApplicationsCreateManyUniversityInputEnvelope = {
    data: UniversityApplicationsCreateManyUniversityInput | UniversityApplicationsCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type LoanCreateWithoutUniversityInput = {
    id?: string
    title: string
    description: string
    amount: number
    interestRate: number
    duration: number
    eligibilityCriteria?: LoanCreateeligibilityCriteriaInput | string[]
    documents?: LoanCreatedocumentsInput | string[]
    deadline?: Date | string | null
    maxApplications?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: LoanApplicationCreateNestedManyWithoutLoanInput
  }

  export type LoanUncheckedCreateWithoutUniversityInput = {
    id?: string
    title: string
    description: string
    amount: number
    interestRate: number
    duration: number
    eligibilityCriteria?: LoanCreateeligibilityCriteriaInput | string[]
    documents?: LoanCreatedocumentsInput | string[]
    deadline?: Date | string | null
    maxApplications?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: LoanApplicationUncheckedCreateNestedManyWithoutLoanInput
  }

  export type LoanCreateOrConnectWithoutUniversityInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutUniversityInput, LoanUncheckedCreateWithoutUniversityInput>
  }

  export type LoanCreateManyUniversityInputEnvelope = {
    data: LoanCreateManyUniversityInput | LoanCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutUniversityInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUniversityInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUniversityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUniversityInput, UserUncheckedCreateWithoutUniversityInput>
  }

  export type UserCreateManyUniversityInputEnvelope = {
    data: UserCreateManyUniversityInput | UserCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutUniversityInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    fees?: string | null
    duration?: string | null
    degreeType?: string | null
    ieltsScore?: string | null
    ranking?: string | null
    intake?: CourseCreateintakeInput | string[]
    websiteLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: UniversityApplicationsCreateNestedManyWithoutCourseInput
    favByUsers?: FavCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutUniversityInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    fees?: string | null
    duration?: string | null
    degreeType?: string | null
    ieltsScore?: string | null
    ranking?: string | null
    intake?: CourseCreateintakeInput | string[]
    websiteLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutCourseInput
    favByUsers?: FavCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutUniversityInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutUniversityInput, CourseUncheckedCreateWithoutUniversityInput>
  }

  export type CourseCreateManyUniversityInputEnvelope = {
    data: CourseCreateManyUniversityInput | CourseCreateManyUniversityInput[]
    skipDuplicates?: boolean
  }

  export type CareerOutcomeUpsertWithWhereUniqueWithoutUniversityInput = {
    where: CareerOutcomeWhereUniqueInput
    update: XOR<CareerOutcomeUpdateWithoutUniversityInput, CareerOutcomeUncheckedUpdateWithoutUniversityInput>
    create: XOR<CareerOutcomeCreateWithoutUniversityInput, CareerOutcomeUncheckedCreateWithoutUniversityInput>
  }

  export type CareerOutcomeUpdateWithWhereUniqueWithoutUniversityInput = {
    where: CareerOutcomeWhereUniqueInput
    data: XOR<CareerOutcomeUpdateWithoutUniversityInput, CareerOutcomeUncheckedUpdateWithoutUniversityInput>
  }

  export type CareerOutcomeUpdateManyWithWhereWithoutUniversityInput = {
    where: CareerOutcomeScalarWhereInput
    data: XOR<CareerOutcomeUpdateManyMutationInput, CareerOutcomeUncheckedUpdateManyWithoutUniversityInput>
  }

  export type CareerOutcomeScalarWhereInput = {
    AND?: CareerOutcomeScalarWhereInput | CareerOutcomeScalarWhereInput[]
    OR?: CareerOutcomeScalarWhereInput[]
    NOT?: CareerOutcomeScalarWhereInput | CareerOutcomeScalarWhereInput[]
    id?: StringFilter<"CareerOutcome"> | string
    iconName?: StringFilter<"CareerOutcome"> | string
    iconImage?: StringFilter<"CareerOutcome"> | string
    title?: StringFilter<"CareerOutcome"> | string
    value?: StringFilter<"CareerOutcome"> | string
    description?: StringFilter<"CareerOutcome"> | string
    details?: StringFilter<"CareerOutcome"> | string
    color?: StringFilter<"CareerOutcome"> | string
    bgColor?: StringFilter<"CareerOutcome"> | string
    universityId?: StringFilter<"CareerOutcome"> | string
  }

  export type FaqUpsertWithWhereUniqueWithoutUniversityInput = {
    where: FaqWhereUniqueInput
    update: XOR<FaqUpdateWithoutUniversityInput, FaqUncheckedUpdateWithoutUniversityInput>
    create: XOR<FaqCreateWithoutUniversityInput, FaqUncheckedCreateWithoutUniversityInput>
  }

  export type FaqUpdateWithWhereUniqueWithoutUniversityInput = {
    where: FaqWhereUniqueInput
    data: XOR<FaqUpdateWithoutUniversityInput, FaqUncheckedUpdateWithoutUniversityInput>
  }

  export type FaqUpdateManyWithWhereWithoutUniversityInput = {
    where: FaqScalarWhereInput
    data: XOR<FaqUpdateManyMutationInput, FaqUncheckedUpdateManyWithoutUniversityInput>
  }

  export type FaqScalarWhereInput = {
    AND?: FaqScalarWhereInput | FaqScalarWhereInput[]
    OR?: FaqScalarWhereInput[]
    NOT?: FaqScalarWhereInput | FaqScalarWhereInput[]
    id?: StringFilter<"Faq"> | string
    question?: StringFilter<"Faq"> | string
    answer?: StringFilter<"Faq"> | string
    universityId?: StringFilter<"Faq"> | string
  }

  export type UniversityApplicationsUpsertWithWhereUniqueWithoutUniversityInput = {
    where: UniversityApplicationsWhereUniqueInput
    update: XOR<UniversityApplicationsUpdateWithoutUniversityInput, UniversityApplicationsUncheckedUpdateWithoutUniversityInput>
    create: XOR<UniversityApplicationsCreateWithoutUniversityInput, UniversityApplicationsUncheckedCreateWithoutUniversityInput>
  }

  export type UniversityApplicationsUpdateWithWhereUniqueWithoutUniversityInput = {
    where: UniversityApplicationsWhereUniqueInput
    data: XOR<UniversityApplicationsUpdateWithoutUniversityInput, UniversityApplicationsUncheckedUpdateWithoutUniversityInput>
  }

  export type UniversityApplicationsUpdateManyWithWhereWithoutUniversityInput = {
    where: UniversityApplicationsScalarWhereInput
    data: XOR<UniversityApplicationsUpdateManyMutationInput, UniversityApplicationsUncheckedUpdateManyWithoutUniversityInput>
  }

  export type UniversityApplicationsScalarWhereInput = {
    AND?: UniversityApplicationsScalarWhereInput | UniversityApplicationsScalarWhereInput[]
    OR?: UniversityApplicationsScalarWhereInput[]
    NOT?: UniversityApplicationsScalarWhereInput | UniversityApplicationsScalarWhereInput[]
    id?: StringFilter<"UniversityApplications"> | string
    userId?: StringFilter<"UniversityApplications"> | string
    universityId?: StringFilter<"UniversityApplications"> | string
    courseId?: StringFilter<"UniversityApplications"> | string
    status?: EnumApplicationStatusFilter<"UniversityApplications"> | $Enums.ApplicationStatus
    appliedAt?: DateTimeFilter<"UniversityApplications"> | Date | string
    loanRequired?: BoolFilter<"UniversityApplications"> | boolean
    documents?: StringNullableListFilter<"UniversityApplications">
    additionalNotes?: StringNullableFilter<"UniversityApplications"> | string | null
    createdAt?: DateTimeFilter<"UniversityApplications"> | Date | string
    updatedAt?: DateTimeFilter<"UniversityApplications"> | Date | string
  }

  export type LoanUpsertWithWhereUniqueWithoutUniversityInput = {
    where: LoanWhereUniqueInput
    update: XOR<LoanUpdateWithoutUniversityInput, LoanUncheckedUpdateWithoutUniversityInput>
    create: XOR<LoanCreateWithoutUniversityInput, LoanUncheckedCreateWithoutUniversityInput>
  }

  export type LoanUpdateWithWhereUniqueWithoutUniversityInput = {
    where: LoanWhereUniqueInput
    data: XOR<LoanUpdateWithoutUniversityInput, LoanUncheckedUpdateWithoutUniversityInput>
  }

  export type LoanUpdateManyWithWhereWithoutUniversityInput = {
    where: LoanScalarWhereInput
    data: XOR<LoanUpdateManyMutationInput, LoanUncheckedUpdateManyWithoutUniversityInput>
  }

  export type LoanScalarWhereInput = {
    AND?: LoanScalarWhereInput | LoanScalarWhereInput[]
    OR?: LoanScalarWhereInput[]
    NOT?: LoanScalarWhereInput | LoanScalarWhereInput[]
    id?: StringFilter<"Loan"> | string
    title?: StringFilter<"Loan"> | string
    description?: StringFilter<"Loan"> | string
    amount?: FloatFilter<"Loan"> | number
    interestRate?: FloatFilter<"Loan"> | number
    duration?: IntFilter<"Loan"> | number
    eligibilityCriteria?: StringNullableListFilter<"Loan">
    documents?: StringNullableListFilter<"Loan">
    deadline?: DateTimeNullableFilter<"Loan"> | Date | string | null
    maxApplications?: IntNullableFilter<"Loan"> | number | null
    isActive?: BoolFilter<"Loan"> | boolean
    universityId?: StringNullableFilter<"Loan"> | string | null
    createdAt?: DateTimeFilter<"Loan"> | Date | string
    updatedAt?: DateTimeFilter<"Loan"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutUniversityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutUniversityInput, UserUncheckedUpdateWithoutUniversityInput>
    create: XOR<UserCreateWithoutUniversityInput, UserUncheckedCreateWithoutUniversityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutUniversityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutUniversityInput, UserUncheckedUpdateWithoutUniversityInput>
  }

  export type UserUpdateManyWithWhereWithoutUniversityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUniversityInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    countryCode?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    header?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    banner?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    googleAccessToken?: StringNullableFilter<"User"> | string | null
    googleRefreshToken?: StringNullableFilter<"User"> | string | null
    googleTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordToken?: StringNullableFilter<"User"> | string | null
    resetPasswordExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    lastPasswordChangeAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isPhoneVerified?: BoolFilter<"User"> | boolean
    isEmailVerified?: BoolFilter<"User"> | boolean
    otpRetryCount?: IntFilter<"User"> | number
    otpLastSentAt?: DateTimeNullableFilter<"User"> | Date | string | null
    otpBlockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    followersCount?: IntFilter<"User"> | number
    followingCount?: IntFilter<"User"> | number
    universityId?: StringNullableFilter<"User"> | string | null
    department?: StringNullableFilter<"User"> | string | null
    program?: StringNullableFilter<"User"> | string | null
    graduationYear?: IntNullableFilter<"User"> | number | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    loginAttempts?: IntFilter<"User"> | number
    isLocked?: BoolFilter<"User"> | boolean
    lockUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    isLandlordVerified?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type CourseUpsertWithWhereUniqueWithoutUniversityInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutUniversityInput, CourseUncheckedUpdateWithoutUniversityInput>
    create: XOR<CourseCreateWithoutUniversityInput, CourseUncheckedCreateWithoutUniversityInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutUniversityInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutUniversityInput, CourseUncheckedUpdateWithoutUniversityInput>
  }

  export type CourseUpdateManyWithWhereWithoutUniversityInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutUniversityInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    description?: StringNullableFilter<"Course"> | string | null
    image?: StringNullableFilter<"Course"> | string | null
    fees?: StringNullableFilter<"Course"> | string | null
    duration?: StringNullableFilter<"Course"> | string | null
    degreeType?: StringNullableFilter<"Course"> | string | null
    ieltsScore?: StringNullableFilter<"Course"> | string | null
    ranking?: StringNullableFilter<"Course"> | string | null
    intake?: StringNullableListFilter<"Course">
    websiteLink?: StringNullableFilter<"Course"> | string | null
    universityId?: StringFilter<"Course"> | string
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
  }

  export type UniversityApplicationsCreateWithoutCourseInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    appliedAt?: Date | string
    loanRequired?: boolean
    documents?: UniversityApplicationsCreatedocumentsInput | string[]
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutApplicationsInput
    university: UniversityCreateNestedOneWithoutApplicationsInput
  }

  export type UniversityApplicationsUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    universityId: string
    status?: $Enums.ApplicationStatus
    appliedAt?: Date | string
    loanRequired?: boolean
    documents?: UniversityApplicationsCreatedocumentsInput | string[]
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityApplicationsCreateOrConnectWithoutCourseInput = {
    where: UniversityApplicationsWhereUniqueInput
    create: XOR<UniversityApplicationsCreateWithoutCourseInput, UniversityApplicationsUncheckedCreateWithoutCourseInput>
  }

  export type UniversityApplicationsCreateManyCourseInputEnvelope = {
    data: UniversityApplicationsCreateManyCourseInput | UniversityApplicationsCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type FavCourseCreateWithoutCourseInput = {
    id?: string
    universityId?: string | null
    universityName?: string | null
    courseName?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavCoursesInput
  }

  export type FavCourseUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    universityId?: string | null
    universityName?: string | null
    courseName?: string | null
    createdAt?: Date | string
  }

  export type FavCourseCreateOrConnectWithoutCourseInput = {
    where: FavCourseWhereUniqueInput
    create: XOR<FavCourseCreateWithoutCourseInput, FavCourseUncheckedCreateWithoutCourseInput>
  }

  export type FavCourseCreateManyCourseInputEnvelope = {
    data: FavCourseCreateManyCourseInput | FavCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UniversityCreateWithoutCoursesInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    careerOutcomes?: CareerOutcomeCreateNestedManyWithoutUniversityInput
    faqs?: FaqCreateNestedManyWithoutUniversityInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUniversityInput
    loans?: LoanCreateNestedManyWithoutUniversityInput
    users?: UserCreateNestedManyWithoutUniversityInput
  }

  export type UniversityUncheckedCreateWithoutCoursesInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    careerOutcomes?: CareerOutcomeUncheckedCreateNestedManyWithoutUniversityInput
    faqs?: FaqUncheckedCreateNestedManyWithoutUniversityInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUniversityInput
    loans?: LoanUncheckedCreateNestedManyWithoutUniversityInput
    users?: UserUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityCreateOrConnectWithoutCoursesInput = {
    where: UniversityWhereUniqueInput
    create: XOR<UniversityCreateWithoutCoursesInput, UniversityUncheckedCreateWithoutCoursesInput>
  }

  export type UniversityApplicationsUpsertWithWhereUniqueWithoutCourseInput = {
    where: UniversityApplicationsWhereUniqueInput
    update: XOR<UniversityApplicationsUpdateWithoutCourseInput, UniversityApplicationsUncheckedUpdateWithoutCourseInput>
    create: XOR<UniversityApplicationsCreateWithoutCourseInput, UniversityApplicationsUncheckedCreateWithoutCourseInput>
  }

  export type UniversityApplicationsUpdateWithWhereUniqueWithoutCourseInput = {
    where: UniversityApplicationsWhereUniqueInput
    data: XOR<UniversityApplicationsUpdateWithoutCourseInput, UniversityApplicationsUncheckedUpdateWithoutCourseInput>
  }

  export type UniversityApplicationsUpdateManyWithWhereWithoutCourseInput = {
    where: UniversityApplicationsScalarWhereInput
    data: XOR<UniversityApplicationsUpdateManyMutationInput, UniversityApplicationsUncheckedUpdateManyWithoutCourseInput>
  }

  export type FavCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: FavCourseWhereUniqueInput
    update: XOR<FavCourseUpdateWithoutCourseInput, FavCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<FavCourseCreateWithoutCourseInput, FavCourseUncheckedCreateWithoutCourseInput>
  }

  export type FavCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: FavCourseWhereUniqueInput
    data: XOR<FavCourseUpdateWithoutCourseInput, FavCourseUncheckedUpdateWithoutCourseInput>
  }

  export type FavCourseUpdateManyWithWhereWithoutCourseInput = {
    where: FavCourseScalarWhereInput
    data: XOR<FavCourseUpdateManyMutationInput, FavCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type FavCourseScalarWhereInput = {
    AND?: FavCourseScalarWhereInput | FavCourseScalarWhereInput[]
    OR?: FavCourseScalarWhereInput[]
    NOT?: FavCourseScalarWhereInput | FavCourseScalarWhereInput[]
    id?: StringFilter<"FavCourse"> | string
    userId?: StringFilter<"FavCourse"> | string
    universityId?: StringNullableFilter<"FavCourse"> | string | null
    universityName?: StringNullableFilter<"FavCourse"> | string | null
    courseName?: StringNullableFilter<"FavCourse"> | string | null
    courseId?: StringFilter<"FavCourse"> | string
    createdAt?: DateTimeFilter<"FavCourse"> | Date | string
  }

  export type UniversityUpsertWithoutCoursesInput = {
    update: XOR<UniversityUpdateWithoutCoursesInput, UniversityUncheckedUpdateWithoutCoursesInput>
    create: XOR<UniversityCreateWithoutCoursesInput, UniversityUncheckedCreateWithoutCoursesInput>
    where?: UniversityWhereInput
  }

  export type UniversityUpdateToOneWithWhereWithoutCoursesInput = {
    where?: UniversityWhereInput
    data: XOR<UniversityUpdateWithoutCoursesInput, UniversityUncheckedUpdateWithoutCoursesInput>
  }

  export type UniversityUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerOutcomes?: CareerOutcomeUpdateManyWithoutUniversityNestedInput
    faqs?: FaqUpdateManyWithoutUniversityNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUniversityNestedInput
    loans?: LoanUpdateManyWithoutUniversityNestedInput
    users?: UserUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerOutcomes?: CareerOutcomeUncheckedUpdateManyWithoutUniversityNestedInput
    faqs?: FaqUncheckedUpdateManyWithoutUniversityNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUniversityNestedInput
    loans?: LoanUncheckedUpdateManyWithoutUniversityNestedInput
    users?: UserUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type UserCreateWithoutApplicationsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApplicationsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
  }

  export type UniversityCreateWithoutApplicationsInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    careerOutcomes?: CareerOutcomeCreateNestedManyWithoutUniversityInput
    faqs?: FaqCreateNestedManyWithoutUniversityInput
    loans?: LoanCreateNestedManyWithoutUniversityInput
    users?: UserCreateNestedManyWithoutUniversityInput
    courses?: CourseCreateNestedManyWithoutUniversityInput
  }

  export type UniversityUncheckedCreateWithoutApplicationsInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    careerOutcomes?: CareerOutcomeUncheckedCreateNestedManyWithoutUniversityInput
    faqs?: FaqUncheckedCreateNestedManyWithoutUniversityInput
    loans?: LoanUncheckedCreateNestedManyWithoutUniversityInput
    users?: UserUncheckedCreateNestedManyWithoutUniversityInput
    courses?: CourseUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityCreateOrConnectWithoutApplicationsInput = {
    where: UniversityWhereUniqueInput
    create: XOR<UniversityCreateWithoutApplicationsInput, UniversityUncheckedCreateWithoutApplicationsInput>
  }

  export type CourseCreateWithoutApplicationsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    fees?: string | null
    duration?: string | null
    degreeType?: string | null
    ieltsScore?: string | null
    ranking?: string | null
    intake?: CourseCreateintakeInput | string[]
    websiteLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favByUsers?: FavCourseCreateNestedManyWithoutCourseInput
    university: UniversityCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutApplicationsInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    fees?: string | null
    duration?: string | null
    degreeType?: string | null
    ieltsScore?: string | null
    ranking?: string | null
    intake?: CourseCreateintakeInput | string[]
    websiteLink?: string | null
    universityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    favByUsers?: FavCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutApplicationsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutApplicationsInput, CourseUncheckedCreateWithoutApplicationsInput>
  }

  export type UserUpsertWithoutApplicationsInput = {
    update: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type UserUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UniversityUpsertWithoutApplicationsInput = {
    update: XOR<UniversityUpdateWithoutApplicationsInput, UniversityUncheckedUpdateWithoutApplicationsInput>
    create: XOR<UniversityCreateWithoutApplicationsInput, UniversityUncheckedCreateWithoutApplicationsInput>
    where?: UniversityWhereInput
  }

  export type UniversityUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: UniversityWhereInput
    data: XOR<UniversityUpdateWithoutApplicationsInput, UniversityUncheckedUpdateWithoutApplicationsInput>
  }

  export type UniversityUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerOutcomes?: CareerOutcomeUpdateManyWithoutUniversityNestedInput
    faqs?: FaqUpdateManyWithoutUniversityNestedInput
    loans?: LoanUpdateManyWithoutUniversityNestedInput
    users?: UserUpdateManyWithoutUniversityNestedInput
    courses?: CourseUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerOutcomes?: CareerOutcomeUncheckedUpdateManyWithoutUniversityNestedInput
    faqs?: FaqUncheckedUpdateManyWithoutUniversityNestedInput
    loans?: LoanUncheckedUpdateManyWithoutUniversityNestedInput
    users?: UserUncheckedUpdateManyWithoutUniversityNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type CourseUpsertWithoutApplicationsInput = {
    update: XOR<CourseUpdateWithoutApplicationsInput, CourseUncheckedUpdateWithoutApplicationsInput>
    create: XOR<CourseCreateWithoutApplicationsInput, CourseUncheckedCreateWithoutApplicationsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutApplicationsInput, CourseUncheckedUpdateWithoutApplicationsInput>
  }

  export type CourseUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: NullableStringFieldUpdateOperationsInput | string | null
    ieltsScore?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableStringFieldUpdateOperationsInput | string | null
    intake?: CourseUpdateintakeInput | string[]
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favByUsers?: FavCourseUpdateManyWithoutCourseNestedInput
    university?: UniversityUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: NullableStringFieldUpdateOperationsInput | string | null
    ieltsScore?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableStringFieldUpdateOperationsInput | string | null
    intake?: CourseUpdateintakeInput | string[]
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    universityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favByUsers?: FavCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutAccommodationsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccommodationsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccommodationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccommodationsInput, UserUncheckedCreateWithoutAccommodationsInput>
  }

  export type AccommodationReviewCreateWithoutAccommodationInput = {
    id?: string
    rating: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccommodationReviewsInput
  }

  export type AccommodationReviewUncheckedCreateWithoutAccommodationInput = {
    id?: string
    rating: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type AccommodationReviewCreateOrConnectWithoutAccommodationInput = {
    where: AccommodationReviewWhereUniqueInput
    create: XOR<AccommodationReviewCreateWithoutAccommodationInput, AccommodationReviewUncheckedCreateWithoutAccommodationInput>
  }

  export type AccommodationReviewCreateManyAccommodationInputEnvelope = {
    data: AccommodationReviewCreateManyAccommodationInput | AccommodationReviewCreateManyAccommodationInput[]
    skipDuplicates?: boolean
  }

  export type AccommodationRatingCreateWithoutAccommodationInput = {
    id?: string
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccommodationRatingsInput
  }

  export type AccommodationRatingUncheckedCreateWithoutAccommodationInput = {
    id?: string
    rating: number
    review?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccommodationRatingCreateOrConnectWithoutAccommodationInput = {
    where: AccommodationRatingWhereUniqueInput
    create: XOR<AccommodationRatingCreateWithoutAccommodationInput, AccommodationRatingUncheckedCreateWithoutAccommodationInput>
  }

  export type AccommodationRatingCreateManyAccommodationInputEnvelope = {
    data: AccommodationRatingCreateManyAccommodationInput | AccommodationRatingCreateManyAccommodationInput[]
    skipDuplicates?: boolean
  }

  export type LikedAccommodationsCreateWithoutAccommodationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLikedAccommodationsInput
  }

  export type LikedAccommodationsUncheckedCreateWithoutAccommodationInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikedAccommodationsCreateOrConnectWithoutAccommodationInput = {
    where: LikedAccommodationsWhereUniqueInput
    create: XOR<LikedAccommodationsCreateWithoutAccommodationInput, LikedAccommodationsUncheckedCreateWithoutAccommodationInput>
  }

  export type LikedAccommodationsCreateManyAccommodationInputEnvelope = {
    data: LikedAccommodationsCreateManyAccommodationInput | LikedAccommodationsCreateManyAccommodationInput[]
    skipDuplicates?: boolean
  }

  export type PricingPlanCreateWithoutAccommodationInput = {
    id?: string
    type: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingPlanUncheckedCreateWithoutAccommodationInput = {
    id?: string
    type: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingPlanCreateOrConnectWithoutAccommodationInput = {
    where: PricingPlanWhereUniqueInput
    create: XOR<PricingPlanCreateWithoutAccommodationInput, PricingPlanUncheckedCreateWithoutAccommodationInput>
  }

  export type PricingPlanCreateManyAccommodationInputEnvelope = {
    data: PricingPlanCreateManyAccommodationInput | PricingPlanCreateManyAccommodationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAccommodationsInput = {
    update: XOR<UserUpdateWithoutAccommodationsInput, UserUncheckedUpdateWithoutAccommodationsInput>
    create: XOR<UserCreateWithoutAccommodationsInput, UserUncheckedCreateWithoutAccommodationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccommodationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccommodationsInput, UserUncheckedUpdateWithoutAccommodationsInput>
  }

  export type UserUpdateWithoutAccommodationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccommodationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccommodationReviewUpsertWithWhereUniqueWithoutAccommodationInput = {
    where: AccommodationReviewWhereUniqueInput
    update: XOR<AccommodationReviewUpdateWithoutAccommodationInput, AccommodationReviewUncheckedUpdateWithoutAccommodationInput>
    create: XOR<AccommodationReviewCreateWithoutAccommodationInput, AccommodationReviewUncheckedCreateWithoutAccommodationInput>
  }

  export type AccommodationReviewUpdateWithWhereUniqueWithoutAccommodationInput = {
    where: AccommodationReviewWhereUniqueInput
    data: XOR<AccommodationReviewUpdateWithoutAccommodationInput, AccommodationReviewUncheckedUpdateWithoutAccommodationInput>
  }

  export type AccommodationReviewUpdateManyWithWhereWithoutAccommodationInput = {
    where: AccommodationReviewScalarWhereInput
    data: XOR<AccommodationReviewUpdateManyMutationInput, AccommodationReviewUncheckedUpdateManyWithoutAccommodationInput>
  }

  export type AccommodationReviewScalarWhereInput = {
    AND?: AccommodationReviewScalarWhereInput | AccommodationReviewScalarWhereInput[]
    OR?: AccommodationReviewScalarWhereInput[]
    NOT?: AccommodationReviewScalarWhereInput | AccommodationReviewScalarWhereInput[]
    id?: StringFilter<"AccommodationReview"> | string
    rating?: FloatFilter<"AccommodationReview"> | number
    review?: StringFilter<"AccommodationReview"> | string
    createdAt?: DateTimeFilter<"AccommodationReview"> | Date | string
    updatedAt?: DateTimeFilter<"AccommodationReview"> | Date | string
    accommodationId?: StringFilter<"AccommodationReview"> | string
    userId?: StringFilter<"AccommodationReview"> | string
  }

  export type AccommodationRatingUpsertWithWhereUniqueWithoutAccommodationInput = {
    where: AccommodationRatingWhereUniqueInput
    update: XOR<AccommodationRatingUpdateWithoutAccommodationInput, AccommodationRatingUncheckedUpdateWithoutAccommodationInput>
    create: XOR<AccommodationRatingCreateWithoutAccommodationInput, AccommodationRatingUncheckedCreateWithoutAccommodationInput>
  }

  export type AccommodationRatingUpdateWithWhereUniqueWithoutAccommodationInput = {
    where: AccommodationRatingWhereUniqueInput
    data: XOR<AccommodationRatingUpdateWithoutAccommodationInput, AccommodationRatingUncheckedUpdateWithoutAccommodationInput>
  }

  export type AccommodationRatingUpdateManyWithWhereWithoutAccommodationInput = {
    where: AccommodationRatingScalarWhereInput
    data: XOR<AccommodationRatingUpdateManyMutationInput, AccommodationRatingUncheckedUpdateManyWithoutAccommodationInput>
  }

  export type AccommodationRatingScalarWhereInput = {
    AND?: AccommodationRatingScalarWhereInput | AccommodationRatingScalarWhereInput[]
    OR?: AccommodationRatingScalarWhereInput[]
    NOT?: AccommodationRatingScalarWhereInput | AccommodationRatingScalarWhereInput[]
    id?: StringFilter<"AccommodationRating"> | string
    rating?: FloatFilter<"AccommodationRating"> | number
    review?: StringNullableFilter<"AccommodationRating"> | string | null
    userId?: StringFilter<"AccommodationRating"> | string
    accommodationId?: StringFilter<"AccommodationRating"> | string
    createdAt?: DateTimeFilter<"AccommodationRating"> | Date | string
    updatedAt?: DateTimeFilter<"AccommodationRating"> | Date | string
  }

  export type LikedAccommodationsUpsertWithWhereUniqueWithoutAccommodationInput = {
    where: LikedAccommodationsWhereUniqueInput
    update: XOR<LikedAccommodationsUpdateWithoutAccommodationInput, LikedAccommodationsUncheckedUpdateWithoutAccommodationInput>
    create: XOR<LikedAccommodationsCreateWithoutAccommodationInput, LikedAccommodationsUncheckedCreateWithoutAccommodationInput>
  }

  export type LikedAccommodationsUpdateWithWhereUniqueWithoutAccommodationInput = {
    where: LikedAccommodationsWhereUniqueInput
    data: XOR<LikedAccommodationsUpdateWithoutAccommodationInput, LikedAccommodationsUncheckedUpdateWithoutAccommodationInput>
  }

  export type LikedAccommodationsUpdateManyWithWhereWithoutAccommodationInput = {
    where: LikedAccommodationsScalarWhereInput
    data: XOR<LikedAccommodationsUpdateManyMutationInput, LikedAccommodationsUncheckedUpdateManyWithoutAccommodationInput>
  }

  export type LikedAccommodationsScalarWhereInput = {
    AND?: LikedAccommodationsScalarWhereInput | LikedAccommodationsScalarWhereInput[]
    OR?: LikedAccommodationsScalarWhereInput[]
    NOT?: LikedAccommodationsScalarWhereInput | LikedAccommodationsScalarWhereInput[]
    id?: StringFilter<"LikedAccommodations"> | string
    userId?: StringFilter<"LikedAccommodations"> | string
    accommodationId?: StringFilter<"LikedAccommodations"> | string
    createdAt?: DateTimeFilter<"LikedAccommodations"> | Date | string
    updatedAt?: DateTimeFilter<"LikedAccommodations"> | Date | string
  }

  export type PricingPlanUpsertWithWhereUniqueWithoutAccommodationInput = {
    where: PricingPlanWhereUniqueInput
    update: XOR<PricingPlanUpdateWithoutAccommodationInput, PricingPlanUncheckedUpdateWithoutAccommodationInput>
    create: XOR<PricingPlanCreateWithoutAccommodationInput, PricingPlanUncheckedCreateWithoutAccommodationInput>
  }

  export type PricingPlanUpdateWithWhereUniqueWithoutAccommodationInput = {
    where: PricingPlanWhereUniqueInput
    data: XOR<PricingPlanUpdateWithoutAccommodationInput, PricingPlanUncheckedUpdateWithoutAccommodationInput>
  }

  export type PricingPlanUpdateManyWithWhereWithoutAccommodationInput = {
    where: PricingPlanScalarWhereInput
    data: XOR<PricingPlanUpdateManyMutationInput, PricingPlanUncheckedUpdateManyWithoutAccommodationInput>
  }

  export type PricingPlanScalarWhereInput = {
    AND?: PricingPlanScalarWhereInput | PricingPlanScalarWhereInput[]
    OR?: PricingPlanScalarWhereInput[]
    NOT?: PricingPlanScalarWhereInput | PricingPlanScalarWhereInput[]
    id?: StringFilter<"PricingPlan"> | string
    accommodationId?: StringFilter<"PricingPlan"> | string
    type?: StringFilter<"PricingPlan"> | string
    price?: FloatFilter<"PricingPlan"> | number
    createdAt?: DateTimeFilter<"PricingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"PricingPlan"> | Date | string
  }

  export type AccommodationCreateWithoutPricingPlansInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    landlord: UserCreateNestedOneWithoutAccommodationsInput
    reviews?: AccommodationReviewCreateNestedManyWithoutAccommodationInput
    ratings?: AccommodationRatingCreateNestedManyWithoutAccommodationInput
    likedBy?: LikedAccommodationsCreateNestedManyWithoutAccommodationInput
  }

  export type AccommodationUncheckedCreateWithoutPricingPlansInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    landlordId: string
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: AccommodationReviewUncheckedCreateNestedManyWithoutAccommodationInput
    ratings?: AccommodationRatingUncheckedCreateNestedManyWithoutAccommodationInput
    likedBy?: LikedAccommodationsUncheckedCreateNestedManyWithoutAccommodationInput
  }

  export type AccommodationCreateOrConnectWithoutPricingPlansInput = {
    where: AccommodationWhereUniqueInput
    create: XOR<AccommodationCreateWithoutPricingPlansInput, AccommodationUncheckedCreateWithoutPricingPlansInput>
  }

  export type AccommodationUpsertWithoutPricingPlansInput = {
    update: XOR<AccommodationUpdateWithoutPricingPlansInput, AccommodationUncheckedUpdateWithoutPricingPlansInput>
    create: XOR<AccommodationCreateWithoutPricingPlansInput, AccommodationUncheckedCreateWithoutPricingPlansInput>
    where?: AccommodationWhereInput
  }

  export type AccommodationUpdateToOneWithWhereWithoutPricingPlansInput = {
    where?: AccommodationWhereInput
    data: XOR<AccommodationUpdateWithoutPricingPlansInput, AccommodationUncheckedUpdateWithoutPricingPlansInput>
  }

  export type AccommodationUpdateWithoutPricingPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    landlord?: UserUpdateOneRequiredWithoutAccommodationsNestedInput
    reviews?: AccommodationReviewUpdateManyWithoutAccommodationNestedInput
    ratings?: AccommodationRatingUpdateManyWithoutAccommodationNestedInput
    likedBy?: LikedAccommodationsUpdateManyWithoutAccommodationNestedInput
  }

  export type AccommodationUncheckedUpdateWithoutPricingPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    landlordId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: AccommodationReviewUncheckedUpdateManyWithoutAccommodationNestedInput
    ratings?: AccommodationRatingUncheckedUpdateManyWithoutAccommodationNestedInput
    likedBy?: LikedAccommodationsUncheckedUpdateManyWithoutAccommodationNestedInput
  }

  export type AccommodationCreateWithoutReviewsInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    landlord: UserCreateNestedOneWithoutAccommodationsInput
    ratings?: AccommodationRatingCreateNestedManyWithoutAccommodationInput
    likedBy?: LikedAccommodationsCreateNestedManyWithoutAccommodationInput
    pricingPlans?: PricingPlanCreateNestedManyWithoutAccommodationInput
  }

  export type AccommodationUncheckedCreateWithoutReviewsInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    landlordId: string
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ratings?: AccommodationRatingUncheckedCreateNestedManyWithoutAccommodationInput
    likedBy?: LikedAccommodationsUncheckedCreateNestedManyWithoutAccommodationInput
    pricingPlans?: PricingPlanUncheckedCreateNestedManyWithoutAccommodationInput
  }

  export type AccommodationCreateOrConnectWithoutReviewsInput = {
    where: AccommodationWhereUniqueInput
    create: XOR<AccommodationCreateWithoutReviewsInput, AccommodationUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutAccommodationReviewsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccommodationReviewsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccommodationReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccommodationReviewsInput, UserUncheckedCreateWithoutAccommodationReviewsInput>
  }

  export type AccommodationUpsertWithoutReviewsInput = {
    update: XOR<AccommodationUpdateWithoutReviewsInput, AccommodationUncheckedUpdateWithoutReviewsInput>
    create: XOR<AccommodationCreateWithoutReviewsInput, AccommodationUncheckedCreateWithoutReviewsInput>
    where?: AccommodationWhereInput
  }

  export type AccommodationUpdateToOneWithWhereWithoutReviewsInput = {
    where?: AccommodationWhereInput
    data: XOR<AccommodationUpdateWithoutReviewsInput, AccommodationUncheckedUpdateWithoutReviewsInput>
  }

  export type AccommodationUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    landlord?: UserUpdateOneRequiredWithoutAccommodationsNestedInput
    ratings?: AccommodationRatingUpdateManyWithoutAccommodationNestedInput
    likedBy?: LikedAccommodationsUpdateManyWithoutAccommodationNestedInput
    pricingPlans?: PricingPlanUpdateManyWithoutAccommodationNestedInput
  }

  export type AccommodationUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    landlordId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: AccommodationRatingUncheckedUpdateManyWithoutAccommodationNestedInput
    likedBy?: LikedAccommodationsUncheckedUpdateManyWithoutAccommodationNestedInput
    pricingPlans?: PricingPlanUncheckedUpdateManyWithoutAccommodationNestedInput
  }

  export type UserUpsertWithoutAccommodationReviewsInput = {
    update: XOR<UserUpdateWithoutAccommodationReviewsInput, UserUncheckedUpdateWithoutAccommodationReviewsInput>
    create: XOR<UserCreateWithoutAccommodationReviewsInput, UserUncheckedCreateWithoutAccommodationReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccommodationReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccommodationReviewsInput, UserUncheckedUpdateWithoutAccommodationReviewsInput>
  }

  export type UserUpdateWithoutAccommodationReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccommodationReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFollowersInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UniversityCreateWithoutLoansInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    careerOutcomes?: CareerOutcomeCreateNestedManyWithoutUniversityInput
    faqs?: FaqCreateNestedManyWithoutUniversityInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUniversityInput
    users?: UserCreateNestedManyWithoutUniversityInput
    courses?: CourseCreateNestedManyWithoutUniversityInput
  }

  export type UniversityUncheckedCreateWithoutLoansInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    careerOutcomes?: CareerOutcomeUncheckedCreateNestedManyWithoutUniversityInput
    faqs?: FaqUncheckedCreateNestedManyWithoutUniversityInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUniversityInput
    users?: UserUncheckedCreateNestedManyWithoutUniversityInput
    courses?: CourseUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityCreateOrConnectWithoutLoansInput = {
    where: UniversityWhereUniqueInput
    create: XOR<UniversityCreateWithoutLoansInput, UniversityUncheckedCreateWithoutLoansInput>
  }

  export type LoanApplicationCreateWithoutLoanInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    documents?: LoanApplicationCreatedocumentsInput | string[]
    academicInfo: JsonNullValueInput | InputJsonValue
    financialInfo: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLoanApplicationsInput
  }

  export type LoanApplicationUncheckedCreateWithoutLoanInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    documents?: LoanApplicationCreatedocumentsInput | string[]
    academicInfo: JsonNullValueInput | InputJsonValue
    financialInfo: JsonNullValueInput | InputJsonValue
    notes?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationCreateOrConnectWithoutLoanInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutLoanInput, LoanApplicationUncheckedCreateWithoutLoanInput>
  }

  export type LoanApplicationCreateManyLoanInputEnvelope = {
    data: LoanApplicationCreateManyLoanInput | LoanApplicationCreateManyLoanInput[]
    skipDuplicates?: boolean
  }

  export type UniversityUpsertWithoutLoansInput = {
    update: XOR<UniversityUpdateWithoutLoansInput, UniversityUncheckedUpdateWithoutLoansInput>
    create: XOR<UniversityCreateWithoutLoansInput, UniversityUncheckedCreateWithoutLoansInput>
    where?: UniversityWhereInput
  }

  export type UniversityUpdateToOneWithWhereWithoutLoansInput = {
    where?: UniversityWhereInput
    data: XOR<UniversityUpdateWithoutLoansInput, UniversityUncheckedUpdateWithoutLoansInput>
  }

  export type UniversityUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerOutcomes?: CareerOutcomeUpdateManyWithoutUniversityNestedInput
    faqs?: FaqUpdateManyWithoutUniversityNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUniversityNestedInput
    users?: UserUpdateManyWithoutUniversityNestedInput
    courses?: CourseUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityUncheckedUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerOutcomes?: CareerOutcomeUncheckedUpdateManyWithoutUniversityNestedInput
    faqs?: FaqUncheckedUpdateManyWithoutUniversityNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUniversityNestedInput
    users?: UserUncheckedUpdateManyWithoutUniversityNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type LoanApplicationUpsertWithWhereUniqueWithoutLoanInput = {
    where: LoanApplicationWhereUniqueInput
    update: XOR<LoanApplicationUpdateWithoutLoanInput, LoanApplicationUncheckedUpdateWithoutLoanInput>
    create: XOR<LoanApplicationCreateWithoutLoanInput, LoanApplicationUncheckedCreateWithoutLoanInput>
  }

  export type LoanApplicationUpdateWithWhereUniqueWithoutLoanInput = {
    where: LoanApplicationWhereUniqueInput
    data: XOR<LoanApplicationUpdateWithoutLoanInput, LoanApplicationUncheckedUpdateWithoutLoanInput>
  }

  export type LoanApplicationUpdateManyWithWhereWithoutLoanInput = {
    where: LoanApplicationScalarWhereInput
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyWithoutLoanInput>
  }

  export type LoanApplicationScalarWhereInput = {
    AND?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
    OR?: LoanApplicationScalarWhereInput[]
    NOT?: LoanApplicationScalarWhereInput | LoanApplicationScalarWhereInput[]
    id?: StringFilter<"LoanApplication"> | string
    status?: EnumApplicationStatusFilter<"LoanApplication"> | $Enums.ApplicationStatus
    documents?: StringNullableListFilter<"LoanApplication">
    academicInfo?: JsonFilter<"LoanApplication">
    financialInfo?: JsonFilter<"LoanApplication">
    notes?: StringNullableFilter<"LoanApplication"> | string | null
    loanId?: StringFilter<"LoanApplication"> | string
    userId?: StringFilter<"LoanApplication"> | string
    createdAt?: DateTimeFilter<"LoanApplication"> | Date | string
    updatedAt?: DateTimeFilter<"LoanApplication"> | Date | string
  }

  export type LoanCreateWithoutApplicationsInput = {
    id?: string
    title: string
    description: string
    amount: number
    interestRate: number
    duration: number
    eligibilityCriteria?: LoanCreateeligibilityCriteriaInput | string[]
    documents?: LoanCreatedocumentsInput | string[]
    deadline?: Date | string | null
    maxApplications?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    university?: UniversityCreateNestedOneWithoutLoansInput
  }

  export type LoanUncheckedCreateWithoutApplicationsInput = {
    id?: string
    title: string
    description: string
    amount: number
    interestRate: number
    duration: number
    eligibilityCriteria?: LoanCreateeligibilityCriteriaInput | string[]
    documents?: LoanCreatedocumentsInput | string[]
    deadline?: Date | string | null
    maxApplications?: number | null
    isActive?: boolean
    universityId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanCreateOrConnectWithoutApplicationsInput = {
    where: LoanWhereUniqueInput
    create: XOR<LoanCreateWithoutApplicationsInput, LoanUncheckedCreateWithoutApplicationsInput>
  }

  export type UserCreateWithoutLoanApplicationsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLoanApplicationsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLoanApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoanApplicationsInput, UserUncheckedCreateWithoutLoanApplicationsInput>
  }

  export type LoanUpsertWithoutApplicationsInput = {
    update: XOR<LoanUpdateWithoutApplicationsInput, LoanUncheckedUpdateWithoutApplicationsInput>
    create: XOR<LoanCreateWithoutApplicationsInput, LoanUncheckedCreateWithoutApplicationsInput>
    where?: LoanWhereInput
  }

  export type LoanUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: LoanWhereInput
    data: XOR<LoanUpdateWithoutApplicationsInput, LoanUncheckedUpdateWithoutApplicationsInput>
  }

  export type LoanUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    eligibilityCriteria?: LoanUpdateeligibilityCriteriaInput | string[]
    documents?: LoanUpdatedocumentsInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxApplications?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    university?: UniversityUpdateOneWithoutLoansNestedInput
  }

  export type LoanUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    eligibilityCriteria?: LoanUpdateeligibilityCriteriaInput | string[]
    documents?: LoanUpdatedocumentsInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxApplications?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutLoanApplicationsInput = {
    update: XOR<UserUpdateWithoutLoanApplicationsInput, UserUncheckedUpdateWithoutLoanApplicationsInput>
    create: XOR<UserCreateWithoutLoanApplicationsInput, UserUncheckedCreateWithoutLoanApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLoanApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLoanApplicationsInput, UserUncheckedUpdateWithoutLoanApplicationsInput>
  }

  export type UserUpdateWithoutLoanApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLoanApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ArticleCreateWithoutVotesInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    bannerImg?: string | null
    images?: ArticleCreateimagesInput | string[]
    tags?: ArticleCreatetagsInput | string[]
    type?: $Enums.ArticleType
    status?: $Enums.ArticleStatus
    upVotes?: number
    downVotes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutArticlesInput
    group?: GroupCreateNestedOneWithoutArticlesInput
  }

  export type ArticleUncheckedCreateWithoutVotesInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    bannerImg?: string | null
    images?: ArticleCreateimagesInput | string[]
    tags?: ArticleCreatetagsInput | string[]
    type?: $Enums.ArticleType
    status?: $Enums.ArticleStatus
    creatorId: string
    groupId?: string | null
    upVotes?: number
    downVotes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleCreateOrConnectWithoutVotesInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutVotesInput, ArticleUncheckedCreateWithoutVotesInput>
  }

  export type ArticleUpsertWithoutVotesInput = {
    update: XOR<ArticleUpdateWithoutVotesInput, ArticleUncheckedUpdateWithoutVotesInput>
    create: XOR<ArticleCreateWithoutVotesInput, ArticleUncheckedCreateWithoutVotesInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutVotesInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutVotesInput, ArticleUncheckedUpdateWithoutVotesInput>
  }

  export type ArticleUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    bannerImg?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleUpdateimagesInput | string[]
    tags?: ArticleUpdatetagsInput | string[]
    type?: EnumArticleTypeFieldUpdateOperationsInput | $Enums.ArticleType
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    upVotes?: IntFieldUpdateOperationsInput | number
    downVotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutArticlesNestedInput
    group?: GroupUpdateOneWithoutArticlesNestedInput
  }

  export type ArticleUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    bannerImg?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleUpdateimagesInput | string[]
    tags?: ArticleUpdatetagsInput | string[]
    type?: EnumArticleTypeFieldUpdateOperationsInput | $Enums.ArticleType
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    upVotes?: IntFieldUpdateOperationsInput | number
    downVotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCreatedGroupsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedGroupsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
  }

  export type EventCreateWithoutGroupInput = {
    id?: string
    title: string
    slug: string
    description: string
    date: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    image?: string | null
    location: string
    eventType?: $Enums.EventType
    registrationType?: $Enums.RegistrationType
    totalSlots: number
    registeredSlots?: number
    waitlistSlots?: number | null
    ticketPrice?: number | null
    currency?: string | null
    address?: string | null
    virtualLink?: string | null
    status?: $Enums.EventStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contactBy: UserCreateNestedOneWithoutHostedEventsInput
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutGroupInput = {
    id?: string
    title: string
    slug: string
    description: string
    date: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    image?: string | null
    location: string
    eventType?: $Enums.EventType
    registrationType?: $Enums.RegistrationType
    totalSlots: number
    registeredSlots?: number
    waitlistSlots?: number | null
    ticketPrice?: number | null
    currency?: string | null
    address?: string | null
    virtualLink?: string | null
    contactById: string
    status?: $Enums.EventStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutGroupInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutGroupInput, EventUncheckedCreateWithoutGroupInput>
  }

  export type EventCreateManyGroupInputEnvelope = {
    data: EventCreateManyGroupInput | EventCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCreateWithoutGroupInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    bannerImg?: string | null
    images?: ArticleCreateimagesInput | string[]
    tags?: ArticleCreatetagsInput | string[]
    type?: $Enums.ArticleType
    status?: $Enums.ArticleStatus
    upVotes?: number
    downVotes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutArticlesInput
    votes?: VoteCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutGroupInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    bannerImg?: string | null
    images?: ArticleCreateimagesInput | string[]
    tags?: ArticleCreatetagsInput | string[]
    type?: $Enums.ArticleType
    status?: $Enums.ArticleStatus
    creatorId: string
    upVotes?: number
    downVotes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutGroupInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutGroupInput, ArticleUncheckedCreateWithoutGroupInput>
  }

  export type ArticleCreateManyGroupInputEnvelope = {
    data: ArticleCreateManyGroupInput | ArticleCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type ForumCreateWithoutGroupInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedForumsInput
    topics?: ForumTopicCreateNestedManyWithoutForumInput
    forumReplies?: ForumReplyCreateNestedManyWithoutForumInput
  }

  export type ForumUncheckedCreateWithoutGroupInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    creatorId: string
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: ForumTopicUncheckedCreateNestedManyWithoutForumInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutForumInput
  }

  export type ForumCreateOrConnectWithoutGroupInput = {
    where: ForumWhereUniqueInput
    create: XOR<ForumCreateWithoutGroupInput, ForumUncheckedCreateWithoutGroupInput>
  }

  export type ForumCreateManyGroupInputEnvelope = {
    data: ForumCreateManyGroupInput | ForumCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type GroupMemberCreateWithoutGroupInput = {
    id?: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutGroupMembershipsInput
  }

  export type GroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberCreateManyGroupInputEnvelope = {
    data: GroupMemberCreateManyGroupInput | GroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAdminOfInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminOfInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminOfInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminOfInput, UserUncheckedCreateWithoutAdminOfInput>
  }

  export type UserUpsertWithoutCreatedGroupsInput = {
    update: XOR<UserUpdateWithoutCreatedGroupsInput, UserUncheckedUpdateWithoutCreatedGroupsInput>
    create: XOR<UserCreateWithoutCreatedGroupsInput, UserUncheckedCreateWithoutCreatedGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedGroupsInput, UserUncheckedUpdateWithoutCreatedGroupsInput>
  }

  export type UserUpdateWithoutCreatedGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventUpsertWithWhereUniqueWithoutGroupInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutGroupInput, EventUncheckedUpdateWithoutGroupInput>
    create: XOR<EventCreateWithoutGroupInput, EventUncheckedCreateWithoutGroupInput>
  }

  export type EventUpdateWithWhereUniqueWithoutGroupInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutGroupInput, EventUncheckedUpdateWithoutGroupInput>
  }

  export type EventUpdateManyWithWhereWithoutGroupInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutGroupInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    slug?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    date?: DateTimeFilter<"Event"> | Date | string
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeNullableFilter<"Event"> | Date | string | null
    image?: StringNullableFilter<"Event"> | string | null
    location?: StringFilter<"Event"> | string
    eventType?: EnumEventTypeFilter<"Event"> | $Enums.EventType
    registrationType?: EnumRegistrationTypeFilter<"Event"> | $Enums.RegistrationType
    totalSlots?: IntFilter<"Event"> | number
    registeredSlots?: IntFilter<"Event"> | number
    waitlistSlots?: IntNullableFilter<"Event"> | number | null
    ticketPrice?: FloatNullableFilter<"Event"> | number | null
    currency?: StringNullableFilter<"Event"> | string | null
    address?: StringNullableFilter<"Event"> | string | null
    virtualLink?: StringNullableFilter<"Event"> | string | null
    contactById?: StringFilter<"Event"> | string
    groupId?: StringFilter<"Event"> | string
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type ArticleUpsertWithWhereUniqueWithoutGroupInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutGroupInput, ArticleUncheckedUpdateWithoutGroupInput>
    create: XOR<ArticleCreateWithoutGroupInput, ArticleUncheckedCreateWithoutGroupInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutGroupInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutGroupInput, ArticleUncheckedUpdateWithoutGroupInput>
  }

  export type ArticleUpdateManyWithWhereWithoutGroupInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutGroupInput>
  }

  export type ArticleScalarWhereInput = {
    AND?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
    OR?: ArticleScalarWhereInput[]
    NOT?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
    id?: StringFilter<"Article"> | string
    title?: StringFilter<"Article"> | string
    description?: StringNullableFilter<"Article"> | string | null
    content?: StringFilter<"Article"> | string
    bannerImg?: StringNullableFilter<"Article"> | string | null
    images?: StringNullableListFilter<"Article">
    tags?: StringNullableListFilter<"Article">
    type?: EnumArticleTypeFilter<"Article"> | $Enums.ArticleType
    status?: EnumArticleStatusFilter<"Article"> | $Enums.ArticleStatus
    creatorId?: StringFilter<"Article"> | string
    groupId?: StringNullableFilter<"Article"> | string | null
    upVotes?: IntFilter<"Article"> | number
    downVotes?: IntFilter<"Article"> | number
    views?: IntFilter<"Article"> | number
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
  }

  export type ForumUpsertWithWhereUniqueWithoutGroupInput = {
    where: ForumWhereUniqueInput
    update: XOR<ForumUpdateWithoutGroupInput, ForumUncheckedUpdateWithoutGroupInput>
    create: XOR<ForumCreateWithoutGroupInput, ForumUncheckedCreateWithoutGroupInput>
  }

  export type ForumUpdateWithWhereUniqueWithoutGroupInput = {
    where: ForumWhereUniqueInput
    data: XOR<ForumUpdateWithoutGroupInput, ForumUncheckedUpdateWithoutGroupInput>
  }

  export type ForumUpdateManyWithWhereWithoutGroupInput = {
    where: ForumScalarWhereInput
    data: XOR<ForumUpdateManyMutationInput, ForumUncheckedUpdateManyWithoutGroupInput>
  }

  export type ForumScalarWhereInput = {
    AND?: ForumScalarWhereInput | ForumScalarWhereInput[]
    OR?: ForumScalarWhereInput[]
    NOT?: ForumScalarWhereInput | ForumScalarWhereInput[]
    id?: StringFilter<"Forum"> | string
    title?: StringFilter<"Forum"> | string
    description?: StringNullableFilter<"Forum"> | string | null
    groupId?: StringFilter<"Forum"> | string
    type?: EnumForumTypeFilter<"Forum"> | $Enums.ForumType
    privacy?: EnumForumPrivacyFilter<"Forum"> | $Enums.ForumPrivacy
    attachments?: StringNullableListFilter<"Forum">
    creatorId?: StringFilter<"Forum"> | string
    viewCount?: IntFilter<"Forum"> | number
    topicCount?: IntFilter<"Forum"> | number
    replyCount?: IntFilter<"Forum"> | number
    lastReplyAt?: DateTimeNullableFilter<"Forum"> | Date | string | null
    isLocked?: BoolFilter<"Forum"> | boolean
    tags?: StringNullableListFilter<"Forum">
    createdAt?: DateTimeFilter<"Forum"> | Date | string
    updatedAt?: DateTimeFilter<"Forum"> | Date | string
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupMemberScalarWhereInput = {
    AND?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    OR?: GroupMemberScalarWhereInput[]
    NOT?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    role?: EnumGroupMemberRoleFilter<"GroupMember"> | $Enums.GroupMemberRole
    joinedAt?: DateTimeFilter<"GroupMember"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutAdminOfInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAdminOfInput, UserUncheckedUpdateWithoutAdminOfInput>
    create: XOR<UserCreateWithoutAdminOfInput, UserUncheckedCreateWithoutAdminOfInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAdminOfInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAdminOfInput, UserUncheckedUpdateWithoutAdminOfInput>
  }

  export type UserUpdateManyWithWhereWithoutAdminOfInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAdminOfInput>
  }

  export type GroupCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedGroupsInput
    events?: EventCreateNestedManyWithoutGroupInput
    articles?: ArticleCreateNestedManyWithoutGroupInput
    forums?: ForumCreateNestedManyWithoutGroupInput
    moderators?: UserCreateNestedManyWithoutAdminOfInput
  }

  export type GroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    createdById: string
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutGroupInput
    articles?: ArticleUncheckedCreateNestedManyWithoutGroupInput
    forums?: ForumUncheckedCreateNestedManyWithoutGroupInput
    moderators?: UserUncheckedCreateNestedManyWithoutAdminOfInput
  }

  export type GroupCreateOrConnectWithoutMembersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutGroupMembershipsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroupMembershipsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroupMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
  }

  export type GroupUpsertWithoutMembersInput = {
    update: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type GroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    events?: EventUpdateManyWithoutGroupNestedInput
    articles?: ArticleUpdateManyWithoutGroupNestedInput
    forums?: ForumUpdateManyWithoutGroupNestedInput
    moderators?: UserUpdateManyWithoutAdminOfNestedInput
  }

  export type GroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutGroupNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutGroupNestedInput
    forums?: ForumUncheckedUpdateManyWithoutGroupNestedInput
    moderators?: UserUncheckedUpdateManyWithoutAdminOfNestedInput
  }

  export type UserUpsertWithoutGroupMembershipsInput = {
    update: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type UserUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutHostedEventsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHostedEventsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHostedEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHostedEventsInput, UserUncheckedCreateWithoutHostedEventsInput>
  }

  export type GroupCreateWithoutEventsInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedGroupsInput
    articles?: ArticleCreateNestedManyWithoutGroupInput
    forums?: ForumCreateNestedManyWithoutGroupInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    moderators?: UserCreateNestedManyWithoutAdminOfInput
  }

  export type GroupUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    createdById: string
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleUncheckedCreateNestedManyWithoutGroupInput
    forums?: ForumUncheckedCreateNestedManyWithoutGroupInput
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    moderators?: UserUncheckedCreateNestedManyWithoutAdminOfInput
  }

  export type GroupCreateOrConnectWithoutEventsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutEventsInput, GroupUncheckedCreateWithoutEventsInput>
  }

  export type EventRegistrationCreateWithoutEventInput = {
    id?: string
    userId: string
    status?: $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventRegistrationUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    status?: $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventRegistrationCreateOrConnectWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    create: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput>
  }

  export type EventRegistrationCreateManyEventInputEnvelope = {
    data: EventRegistrationCreateManyEventInput | EventRegistrationCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutHostedEventsInput = {
    update: XOR<UserUpdateWithoutHostedEventsInput, UserUncheckedUpdateWithoutHostedEventsInput>
    create: XOR<UserCreateWithoutHostedEventsInput, UserUncheckedCreateWithoutHostedEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHostedEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHostedEventsInput, UserUncheckedUpdateWithoutHostedEventsInput>
  }

  export type UserUpdateWithoutHostedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHostedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupUpsertWithoutEventsInput = {
    update: XOR<GroupUpdateWithoutEventsInput, GroupUncheckedUpdateWithoutEventsInput>
    create: XOR<GroupCreateWithoutEventsInput, GroupUncheckedCreateWithoutEventsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutEventsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutEventsInput, GroupUncheckedUpdateWithoutEventsInput>
  }

  export type GroupUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    articles?: ArticleUpdateManyWithoutGroupNestedInput
    forums?: ForumUpdateManyWithoutGroupNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    moderators?: UserUpdateManyWithoutAdminOfNestedInput
  }

  export type GroupUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleUncheckedUpdateManyWithoutGroupNestedInput
    forums?: ForumUncheckedUpdateManyWithoutGroupNestedInput
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    moderators?: UserUncheckedUpdateManyWithoutAdminOfNestedInput
  }

  export type EventRegistrationUpsertWithWhereUniqueWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    update: XOR<EventRegistrationUpdateWithoutEventInput, EventRegistrationUncheckedUpdateWithoutEventInput>
    create: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput>
  }

  export type EventRegistrationUpdateWithWhereUniqueWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    data: XOR<EventRegistrationUpdateWithoutEventInput, EventRegistrationUncheckedUpdateWithoutEventInput>
  }

  export type EventRegistrationUpdateManyWithWhereWithoutEventInput = {
    where: EventRegistrationScalarWhereInput
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyWithoutEventInput>
  }

  export type EventRegistrationScalarWhereInput = {
    AND?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
    OR?: EventRegistrationScalarWhereInput[]
    NOT?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
    id?: StringFilter<"EventRegistration"> | string
    eventId?: StringFilter<"EventRegistration"> | string
    userId?: StringFilter<"EventRegistration"> | string
    status?: EnumEventRegistrationStatusFilter<"EventRegistration"> | $Enums.EventRegistrationStatus
    additionalInfo?: JsonNullableFilter<"EventRegistration">
    createdAt?: DateTimeFilter<"EventRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"EventRegistration"> | Date | string
  }

  export type EventCreateWithoutRegistrationsInput = {
    id?: string
    title: string
    slug: string
    description: string
    date: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    image?: string | null
    location: string
    eventType?: $Enums.EventType
    registrationType?: $Enums.RegistrationType
    totalSlots: number
    registeredSlots?: number
    waitlistSlots?: number | null
    ticketPrice?: number | null
    currency?: string | null
    address?: string | null
    virtualLink?: string | null
    status?: $Enums.EventStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contactBy: UserCreateNestedOneWithoutHostedEventsInput
    group: GroupCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutRegistrationsInput = {
    id?: string
    title: string
    slug: string
    description: string
    date: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    image?: string | null
    location: string
    eventType?: $Enums.EventType
    registrationType?: $Enums.RegistrationType
    totalSlots: number
    registeredSlots?: number
    waitlistSlots?: number | null
    ticketPrice?: number | null
    currency?: string | null
    address?: string | null
    virtualLink?: string | null
    contactById: string
    groupId: string
    status?: $Enums.EventStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutRegistrationsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
  }

  export type EventUpsertWithoutRegistrationsInput = {
    update: XOR<EventUpdateWithoutRegistrationsInput, EventUncheckedUpdateWithoutRegistrationsInput>
    create: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutRegistrationsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutRegistrationsInput, EventUncheckedUpdateWithoutRegistrationsInput>
  }

  export type EventUpdateWithoutRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    registrationType?: EnumRegistrationTypeFieldUpdateOperationsInput | $Enums.RegistrationType
    totalSlots?: IntFieldUpdateOperationsInput | number
    registeredSlots?: IntFieldUpdateOperationsInput | number
    waitlistSlots?: NullableIntFieldUpdateOperationsInput | number | null
    ticketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactBy?: UserUpdateOneRequiredWithoutHostedEventsNestedInput
    group?: GroupUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    registrationType?: EnumRegistrationTypeFieldUpdateOperationsInput | $Enums.RegistrationType
    totalSlots?: IntFieldUpdateOperationsInput | number
    registeredSlots?: IntFieldUpdateOperationsInput | number
    waitlistSlots?: NullableIntFieldUpdateOperationsInput | number | null
    ticketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    contactById?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateWithoutForumsInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedGroupsInput
    events?: EventCreateNestedManyWithoutGroupInput
    articles?: ArticleCreateNestedManyWithoutGroupInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    moderators?: UserCreateNestedManyWithoutAdminOfInput
  }

  export type GroupUncheckedCreateWithoutForumsInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    createdById: string
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutGroupInput
    articles?: ArticleUncheckedCreateNestedManyWithoutGroupInput
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    moderators?: UserUncheckedCreateNestedManyWithoutAdminOfInput
  }

  export type GroupCreateOrConnectWithoutForumsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutForumsInput, GroupUncheckedCreateWithoutForumsInput>
  }

  export type UserCreateWithoutCreatedForumsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedForumsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedForumsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedForumsInput, UserUncheckedCreateWithoutCreatedForumsInput>
  }

  export type ForumTopicCreateWithoutForumInput = {
    id?: string
    title: string
    content: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedForumTopicsInput
    posts?: ForumPostCreateNestedManyWithoutTopicInput
    replies?: ForumReplyCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicUncheckedCreateWithoutForumInput = {
    id?: string
    title: string
    content: string
    creatorId: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: ForumPostUncheckedCreateNestedManyWithoutTopicInput
    replies?: ForumReplyUncheckedCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicCreateOrConnectWithoutForumInput = {
    where: ForumTopicWhereUniqueInput
    create: XOR<ForumTopicCreateWithoutForumInput, ForumTopicUncheckedCreateWithoutForumInput>
  }

  export type ForumTopicCreateManyForumInputEnvelope = {
    data: ForumTopicCreateManyForumInput | ForumTopicCreateManyForumInput[]
    skipDuplicates?: boolean
  }

  export type ForumReplyCreateWithoutForumInput = {
    id?: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: ForumTopicCreateNestedOneWithoutRepliesInput
    user: UserCreateNestedOneWithoutForumRepliesInput
    reactions?: ForumReplyReactionCreateNestedManyWithoutForumReplyInput
    parentReply?: ForumReplyCreateNestedOneWithoutChildRepliesInput
    childReplies?: ForumReplyCreateNestedManyWithoutParentReplyInput
  }

  export type ForumReplyUncheckedCreateWithoutForumInput = {
    id?: string
    topicId: string
    userId: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    parentReplyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutForumReplyInput
    childReplies?: ForumReplyUncheckedCreateNestedManyWithoutParentReplyInput
  }

  export type ForumReplyCreateOrConnectWithoutForumInput = {
    where: ForumReplyWhereUniqueInput
    create: XOR<ForumReplyCreateWithoutForumInput, ForumReplyUncheckedCreateWithoutForumInput>
  }

  export type ForumReplyCreateManyForumInputEnvelope = {
    data: ForumReplyCreateManyForumInput | ForumReplyCreateManyForumInput[]
    skipDuplicates?: boolean
  }

  export type GroupUpsertWithoutForumsInput = {
    update: XOR<GroupUpdateWithoutForumsInput, GroupUncheckedUpdateWithoutForumsInput>
    create: XOR<GroupCreateWithoutForumsInput, GroupUncheckedCreateWithoutForumsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutForumsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutForumsInput, GroupUncheckedUpdateWithoutForumsInput>
  }

  export type GroupUpdateWithoutForumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    events?: EventUpdateManyWithoutGroupNestedInput
    articles?: ArticleUpdateManyWithoutGroupNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    moderators?: UserUpdateManyWithoutAdminOfNestedInput
  }

  export type GroupUncheckedUpdateWithoutForumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutGroupNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutGroupNestedInput
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    moderators?: UserUncheckedUpdateManyWithoutAdminOfNestedInput
  }

  export type UserUpsertWithoutCreatedForumsInput = {
    update: XOR<UserUpdateWithoutCreatedForumsInput, UserUncheckedUpdateWithoutCreatedForumsInput>
    create: XOR<UserCreateWithoutCreatedForumsInput, UserUncheckedCreateWithoutCreatedForumsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedForumsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedForumsInput, UserUncheckedUpdateWithoutCreatedForumsInput>
  }

  export type UserUpdateWithoutCreatedForumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedForumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumTopicUpsertWithWhereUniqueWithoutForumInput = {
    where: ForumTopicWhereUniqueInput
    update: XOR<ForumTopicUpdateWithoutForumInput, ForumTopicUncheckedUpdateWithoutForumInput>
    create: XOR<ForumTopicCreateWithoutForumInput, ForumTopicUncheckedCreateWithoutForumInput>
  }

  export type ForumTopicUpdateWithWhereUniqueWithoutForumInput = {
    where: ForumTopicWhereUniqueInput
    data: XOR<ForumTopicUpdateWithoutForumInput, ForumTopicUncheckedUpdateWithoutForumInput>
  }

  export type ForumTopicUpdateManyWithWhereWithoutForumInput = {
    where: ForumTopicScalarWhereInput
    data: XOR<ForumTopicUpdateManyMutationInput, ForumTopicUncheckedUpdateManyWithoutForumInput>
  }

  export type ForumTopicScalarWhereInput = {
    AND?: ForumTopicScalarWhereInput | ForumTopicScalarWhereInput[]
    OR?: ForumTopicScalarWhereInput[]
    NOT?: ForumTopicScalarWhereInput | ForumTopicScalarWhereInput[]
    id?: StringFilter<"ForumTopic"> | string
    title?: StringFilter<"ForumTopic"> | string
    content?: StringFilter<"ForumTopic"> | string
    forumId?: StringFilter<"ForumTopic"> | string
    creatorId?: StringFilter<"ForumTopic"> | string
    type?: EnumTopicTypeFilter<"ForumTopic"> | $Enums.TopicType
    isPinned?: BoolFilter<"ForumTopic"> | boolean
    isClosed?: BoolFilter<"ForumTopic"> | boolean
    viewCount?: IntFilter<"ForumTopic"> | number
    replyCount?: IntFilter<"ForumTopic"> | number
    lastReplyAt?: DateTimeNullableFilter<"ForumTopic"> | Date | string | null
    status?: EnumTopicStatusFilter<"ForumTopic"> | $Enums.TopicStatus
    createdAt?: DateTimeFilter<"ForumTopic"> | Date | string
    updatedAt?: DateTimeFilter<"ForumTopic"> | Date | string
  }

  export type ForumReplyUpsertWithWhereUniqueWithoutForumInput = {
    where: ForumReplyWhereUniqueInput
    update: XOR<ForumReplyUpdateWithoutForumInput, ForumReplyUncheckedUpdateWithoutForumInput>
    create: XOR<ForumReplyCreateWithoutForumInput, ForumReplyUncheckedCreateWithoutForumInput>
  }

  export type ForumReplyUpdateWithWhereUniqueWithoutForumInput = {
    where: ForumReplyWhereUniqueInput
    data: XOR<ForumReplyUpdateWithoutForumInput, ForumReplyUncheckedUpdateWithoutForumInput>
  }

  export type ForumReplyUpdateManyWithWhereWithoutForumInput = {
    where: ForumReplyScalarWhereInput
    data: XOR<ForumReplyUpdateManyMutationInput, ForumReplyUncheckedUpdateManyWithoutForumInput>
  }

  export type ForumReplyScalarWhereInput = {
    AND?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
    OR?: ForumReplyScalarWhereInput[]
    NOT?: ForumReplyScalarWhereInput | ForumReplyScalarWhereInput[]
    id?: StringFilter<"ForumReply"> | string
    forumId?: StringFilter<"ForumReply"> | string
    topicId?: StringFilter<"ForumReply"> | string
    userId?: StringFilter<"ForumReply"> | string
    content?: StringFilter<"ForumReply"> | string
    attachments?: StringNullableListFilter<"ForumReply">
    likes?: IntFilter<"ForumReply"> | number
    parentReplyId?: StringNullableFilter<"ForumReply"> | string | null
    createdAt?: DateTimeFilter<"ForumReply"> | Date | string
    updatedAt?: DateTimeFilter<"ForumReply"> | Date | string
  }

  export type ForumCreateWithoutTopicsInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutForumsInput
    creator: UserCreateNestedOneWithoutCreatedForumsInput
    forumReplies?: ForumReplyCreateNestedManyWithoutForumInput
  }

  export type ForumUncheckedCreateWithoutTopicsInput = {
    id?: string
    title: string
    description?: string | null
    groupId: string
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    creatorId: string
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutForumInput
  }

  export type ForumCreateOrConnectWithoutTopicsInput = {
    where: ForumWhereUniqueInput
    create: XOR<ForumCreateWithoutTopicsInput, ForumUncheckedCreateWithoutTopicsInput>
  }

  export type UserCreateWithoutCreatedForumTopicsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedForumTopicsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedForumTopicsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedForumTopicsInput, UserUncheckedCreateWithoutCreatedForumTopicsInput>
  }

  export type ForumPostCreateWithoutTopicInput = {
    id?: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutForumPostsInput
    reactions?: ForumPostReactionCreateNestedManyWithoutForumPostInput
    parentPost?: ForumPostCreateNestedOneWithoutRepliesInput
    replies?: ForumPostCreateNestedManyWithoutParentPostInput
  }

  export type ForumPostUncheckedCreateWithoutTopicInput = {
    id?: string
    content: string
    creatorId: string
    likes?: number
    parentPostId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ForumPostReactionUncheckedCreateNestedManyWithoutForumPostInput
    replies?: ForumPostUncheckedCreateNestedManyWithoutParentPostInput
  }

  export type ForumPostCreateOrConnectWithoutTopicInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutTopicInput, ForumPostUncheckedCreateWithoutTopicInput>
  }

  export type ForumPostCreateManyTopicInputEnvelope = {
    data: ForumPostCreateManyTopicInput | ForumPostCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type ForumReplyCreateWithoutTopicInput = {
    id?: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    forum: ForumCreateNestedOneWithoutForumRepliesInput
    user: UserCreateNestedOneWithoutForumRepliesInput
    reactions?: ForumReplyReactionCreateNestedManyWithoutForumReplyInput
    parentReply?: ForumReplyCreateNestedOneWithoutChildRepliesInput
    childReplies?: ForumReplyCreateNestedManyWithoutParentReplyInput
  }

  export type ForumReplyUncheckedCreateWithoutTopicInput = {
    id?: string
    forumId: string
    userId: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    parentReplyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutForumReplyInput
    childReplies?: ForumReplyUncheckedCreateNestedManyWithoutParentReplyInput
  }

  export type ForumReplyCreateOrConnectWithoutTopicInput = {
    where: ForumReplyWhereUniqueInput
    create: XOR<ForumReplyCreateWithoutTopicInput, ForumReplyUncheckedCreateWithoutTopicInput>
  }

  export type ForumReplyCreateManyTopicInputEnvelope = {
    data: ForumReplyCreateManyTopicInput | ForumReplyCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type ForumUpsertWithoutTopicsInput = {
    update: XOR<ForumUpdateWithoutTopicsInput, ForumUncheckedUpdateWithoutTopicsInput>
    create: XOR<ForumCreateWithoutTopicsInput, ForumUncheckedCreateWithoutTopicsInput>
    where?: ForumWhereInput
  }

  export type ForumUpdateToOneWithWhereWithoutTopicsInput = {
    where?: ForumWhereInput
    data: XOR<ForumUpdateWithoutTopicsInput, ForumUncheckedUpdateWithoutTopicsInput>
  }

  export type ForumUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutForumsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedForumsNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutForumNestedInput
  }

  export type ForumUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: StringFieldUpdateOperationsInput | string
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    creatorId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutForumNestedInput
  }

  export type UserUpsertWithoutCreatedForumTopicsInput = {
    update: XOR<UserUpdateWithoutCreatedForumTopicsInput, UserUncheckedUpdateWithoutCreatedForumTopicsInput>
    create: XOR<UserCreateWithoutCreatedForumTopicsInput, UserUncheckedCreateWithoutCreatedForumTopicsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedForumTopicsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedForumTopicsInput, UserUncheckedUpdateWithoutCreatedForumTopicsInput>
  }

  export type UserUpdateWithoutCreatedForumTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedForumTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumPostUpsertWithWhereUniqueWithoutTopicInput = {
    where: ForumPostWhereUniqueInput
    update: XOR<ForumPostUpdateWithoutTopicInput, ForumPostUncheckedUpdateWithoutTopicInput>
    create: XOR<ForumPostCreateWithoutTopicInput, ForumPostUncheckedCreateWithoutTopicInput>
  }

  export type ForumPostUpdateWithWhereUniqueWithoutTopicInput = {
    where: ForumPostWhereUniqueInput
    data: XOR<ForumPostUpdateWithoutTopicInput, ForumPostUncheckedUpdateWithoutTopicInput>
  }

  export type ForumPostUpdateManyWithWhereWithoutTopicInput = {
    where: ForumPostScalarWhereInput
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyWithoutTopicInput>
  }

  export type ForumPostScalarWhereInput = {
    AND?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
    OR?: ForumPostScalarWhereInput[]
    NOT?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
    id?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    topicId?: StringFilter<"ForumPost"> | string
    creatorId?: StringFilter<"ForumPost"> | string
    likes?: IntFilter<"ForumPost"> | number
    parentPostId?: StringNullableFilter<"ForumPost"> | string | null
    createdAt?: DateTimeFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPost"> | Date | string
  }

  export type ForumReplyUpsertWithWhereUniqueWithoutTopicInput = {
    where: ForumReplyWhereUniqueInput
    update: XOR<ForumReplyUpdateWithoutTopicInput, ForumReplyUncheckedUpdateWithoutTopicInput>
    create: XOR<ForumReplyCreateWithoutTopicInput, ForumReplyUncheckedCreateWithoutTopicInput>
  }

  export type ForumReplyUpdateWithWhereUniqueWithoutTopicInput = {
    where: ForumReplyWhereUniqueInput
    data: XOR<ForumReplyUpdateWithoutTopicInput, ForumReplyUncheckedUpdateWithoutTopicInput>
  }

  export type ForumReplyUpdateManyWithWhereWithoutTopicInput = {
    where: ForumReplyScalarWhereInput
    data: XOR<ForumReplyUpdateManyMutationInput, ForumReplyUncheckedUpdateManyWithoutTopicInput>
  }

  export type ForumCreateWithoutForumRepliesInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutForumsInput
    creator: UserCreateNestedOneWithoutCreatedForumsInput
    topics?: ForumTopicCreateNestedManyWithoutForumInput
  }

  export type ForumUncheckedCreateWithoutForumRepliesInput = {
    id?: string
    title: string
    description?: string | null
    groupId: string
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    creatorId: string
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: ForumTopicUncheckedCreateNestedManyWithoutForumInput
  }

  export type ForumCreateOrConnectWithoutForumRepliesInput = {
    where: ForumWhereUniqueInput
    create: XOR<ForumCreateWithoutForumRepliesInput, ForumUncheckedCreateWithoutForumRepliesInput>
  }

  export type ForumTopicCreateWithoutRepliesInput = {
    id?: string
    title: string
    content: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    forum: ForumCreateNestedOneWithoutTopicsInput
    creator: UserCreateNestedOneWithoutCreatedForumTopicsInput
    posts?: ForumPostCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicUncheckedCreateWithoutRepliesInput = {
    id?: string
    title: string
    content: string
    forumId: string
    creatorId: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: ForumPostUncheckedCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicCreateOrConnectWithoutRepliesInput = {
    where: ForumTopicWhereUniqueInput
    create: XOR<ForumTopicCreateWithoutRepliesInput, ForumTopicUncheckedCreateWithoutRepliesInput>
  }

  export type UserCreateWithoutForumRepliesInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutForumRepliesInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutForumRepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutForumRepliesInput, UserUncheckedCreateWithoutForumRepliesInput>
  }

  export type ForumReplyReactionCreateWithoutForumReplyInput = {
    id?: string
    type: $Enums.ReactionType
    user: UserCreateNestedOneWithoutForumReplyReactionsInput
  }

  export type ForumReplyReactionUncheckedCreateWithoutForumReplyInput = {
    id?: string
    userId: string
    type: $Enums.ReactionType
  }

  export type ForumReplyReactionCreateOrConnectWithoutForumReplyInput = {
    where: ForumReplyReactionWhereUniqueInput
    create: XOR<ForumReplyReactionCreateWithoutForumReplyInput, ForumReplyReactionUncheckedCreateWithoutForumReplyInput>
  }

  export type ForumReplyReactionCreateManyForumReplyInputEnvelope = {
    data: ForumReplyReactionCreateManyForumReplyInput | ForumReplyReactionCreateManyForumReplyInput[]
    skipDuplicates?: boolean
  }

  export type ForumReplyCreateWithoutChildRepliesInput = {
    id?: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    forum: ForumCreateNestedOneWithoutForumRepliesInput
    topic: ForumTopicCreateNestedOneWithoutRepliesInput
    user: UserCreateNestedOneWithoutForumRepliesInput
    reactions?: ForumReplyReactionCreateNestedManyWithoutForumReplyInput
    parentReply?: ForumReplyCreateNestedOneWithoutChildRepliesInput
  }

  export type ForumReplyUncheckedCreateWithoutChildRepliesInput = {
    id?: string
    forumId: string
    topicId: string
    userId: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    parentReplyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutForumReplyInput
  }

  export type ForumReplyCreateOrConnectWithoutChildRepliesInput = {
    where: ForumReplyWhereUniqueInput
    create: XOR<ForumReplyCreateWithoutChildRepliesInput, ForumReplyUncheckedCreateWithoutChildRepliesInput>
  }

  export type ForumReplyCreateWithoutParentReplyInput = {
    id?: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    forum: ForumCreateNestedOneWithoutForumRepliesInput
    topic: ForumTopicCreateNestedOneWithoutRepliesInput
    user: UserCreateNestedOneWithoutForumRepliesInput
    reactions?: ForumReplyReactionCreateNestedManyWithoutForumReplyInput
    childReplies?: ForumReplyCreateNestedManyWithoutParentReplyInput
  }

  export type ForumReplyUncheckedCreateWithoutParentReplyInput = {
    id?: string
    forumId: string
    topicId: string
    userId: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutForumReplyInput
    childReplies?: ForumReplyUncheckedCreateNestedManyWithoutParentReplyInput
  }

  export type ForumReplyCreateOrConnectWithoutParentReplyInput = {
    where: ForumReplyWhereUniqueInput
    create: XOR<ForumReplyCreateWithoutParentReplyInput, ForumReplyUncheckedCreateWithoutParentReplyInput>
  }

  export type ForumReplyCreateManyParentReplyInputEnvelope = {
    data: ForumReplyCreateManyParentReplyInput | ForumReplyCreateManyParentReplyInput[]
    skipDuplicates?: boolean
  }

  export type ForumUpsertWithoutForumRepliesInput = {
    update: XOR<ForumUpdateWithoutForumRepliesInput, ForumUncheckedUpdateWithoutForumRepliesInput>
    create: XOR<ForumCreateWithoutForumRepliesInput, ForumUncheckedCreateWithoutForumRepliesInput>
    where?: ForumWhereInput
  }

  export type ForumUpdateToOneWithWhereWithoutForumRepliesInput = {
    where?: ForumWhereInput
    data: XOR<ForumUpdateWithoutForumRepliesInput, ForumUncheckedUpdateWithoutForumRepliesInput>
  }

  export type ForumUpdateWithoutForumRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutForumsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedForumsNestedInput
    topics?: ForumTopicUpdateManyWithoutForumNestedInput
  }

  export type ForumUncheckedUpdateWithoutForumRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: StringFieldUpdateOperationsInput | string
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    creatorId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: ForumTopicUncheckedUpdateManyWithoutForumNestedInput
  }

  export type ForumTopicUpsertWithoutRepliesInput = {
    update: XOR<ForumTopicUpdateWithoutRepliesInput, ForumTopicUncheckedUpdateWithoutRepliesInput>
    create: XOR<ForumTopicCreateWithoutRepliesInput, ForumTopicUncheckedCreateWithoutRepliesInput>
    where?: ForumTopicWhereInput
  }

  export type ForumTopicUpdateToOneWithWhereWithoutRepliesInput = {
    where?: ForumTopicWhereInput
    data: XOR<ForumTopicUpdateWithoutRepliesInput, ForumTopicUncheckedUpdateWithoutRepliesInput>
  }

  export type ForumTopicUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forum?: ForumUpdateOneRequiredWithoutTopicsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedForumTopicsNestedInput
    posts?: ForumPostUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type UserUpsertWithoutForumRepliesInput = {
    update: XOR<UserUpdateWithoutForumRepliesInput, UserUncheckedUpdateWithoutForumRepliesInput>
    create: XOR<UserCreateWithoutForumRepliesInput, UserUncheckedCreateWithoutForumRepliesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutForumRepliesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutForumRepliesInput, UserUncheckedUpdateWithoutForumRepliesInput>
  }

  export type UserUpdateWithoutForumRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutForumRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumReplyReactionUpsertWithWhereUniqueWithoutForumReplyInput = {
    where: ForumReplyReactionWhereUniqueInput
    update: XOR<ForumReplyReactionUpdateWithoutForumReplyInput, ForumReplyReactionUncheckedUpdateWithoutForumReplyInput>
    create: XOR<ForumReplyReactionCreateWithoutForumReplyInput, ForumReplyReactionUncheckedCreateWithoutForumReplyInput>
  }

  export type ForumReplyReactionUpdateWithWhereUniqueWithoutForumReplyInput = {
    where: ForumReplyReactionWhereUniqueInput
    data: XOR<ForumReplyReactionUpdateWithoutForumReplyInput, ForumReplyReactionUncheckedUpdateWithoutForumReplyInput>
  }

  export type ForumReplyReactionUpdateManyWithWhereWithoutForumReplyInput = {
    where: ForumReplyReactionScalarWhereInput
    data: XOR<ForumReplyReactionUpdateManyMutationInput, ForumReplyReactionUncheckedUpdateManyWithoutForumReplyInput>
  }

  export type ForumReplyReactionScalarWhereInput = {
    AND?: ForumReplyReactionScalarWhereInput | ForumReplyReactionScalarWhereInput[]
    OR?: ForumReplyReactionScalarWhereInput[]
    NOT?: ForumReplyReactionScalarWhereInput | ForumReplyReactionScalarWhereInput[]
    id?: StringFilter<"ForumReplyReaction"> | string
    forumReplyId?: StringFilter<"ForumReplyReaction"> | string
    userId?: StringFilter<"ForumReplyReaction"> | string
    type?: EnumReactionTypeFilter<"ForumReplyReaction"> | $Enums.ReactionType
  }

  export type ForumReplyUpsertWithoutChildRepliesInput = {
    update: XOR<ForumReplyUpdateWithoutChildRepliesInput, ForumReplyUncheckedUpdateWithoutChildRepliesInput>
    create: XOR<ForumReplyCreateWithoutChildRepliesInput, ForumReplyUncheckedCreateWithoutChildRepliesInput>
    where?: ForumReplyWhereInput
  }

  export type ForumReplyUpdateToOneWithWhereWithoutChildRepliesInput = {
    where?: ForumReplyWhereInput
    data: XOR<ForumReplyUpdateWithoutChildRepliesInput, ForumReplyUncheckedUpdateWithoutChildRepliesInput>
  }

  export type ForumReplyUpdateWithoutChildRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forum?: ForumUpdateOneRequiredWithoutForumRepliesNestedInput
    topic?: ForumTopicUpdateOneRequiredWithoutRepliesNestedInput
    user?: UserUpdateOneRequiredWithoutForumRepliesNestedInput
    reactions?: ForumReplyReactionUpdateManyWithoutForumReplyNestedInput
    parentReply?: ForumReplyUpdateOneWithoutChildRepliesNestedInput
  }

  export type ForumReplyUncheckedUpdateWithoutChildRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ForumReplyReactionUncheckedUpdateManyWithoutForumReplyNestedInput
  }

  export type ForumReplyUpsertWithWhereUniqueWithoutParentReplyInput = {
    where: ForumReplyWhereUniqueInput
    update: XOR<ForumReplyUpdateWithoutParentReplyInput, ForumReplyUncheckedUpdateWithoutParentReplyInput>
    create: XOR<ForumReplyCreateWithoutParentReplyInput, ForumReplyUncheckedCreateWithoutParentReplyInput>
  }

  export type ForumReplyUpdateWithWhereUniqueWithoutParentReplyInput = {
    where: ForumReplyWhereUniqueInput
    data: XOR<ForumReplyUpdateWithoutParentReplyInput, ForumReplyUncheckedUpdateWithoutParentReplyInput>
  }

  export type ForumReplyUpdateManyWithWhereWithoutParentReplyInput = {
    where: ForumReplyScalarWhereInput
    data: XOR<ForumReplyUpdateManyMutationInput, ForumReplyUncheckedUpdateManyWithoutParentReplyInput>
  }

  export type ForumTopicCreateWithoutPostsInput = {
    id?: string
    title: string
    content: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    forum: ForumCreateNestedOneWithoutTopicsInput
    creator: UserCreateNestedOneWithoutCreatedForumTopicsInput
    replies?: ForumReplyCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicUncheckedCreateWithoutPostsInput = {
    id?: string
    title: string
    content: string
    forumId: string
    creatorId: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ForumReplyUncheckedCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicCreateOrConnectWithoutPostsInput = {
    where: ForumTopicWhereUniqueInput
    create: XOR<ForumTopicCreateWithoutPostsInput, ForumTopicUncheckedCreateWithoutPostsInput>
  }

  export type UserCreateWithoutForumPostsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutForumPostsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutForumPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
  }

  export type ForumPostReactionCreateWithoutForumPostInput = {
    id?: string
    type: $Enums.ReactionType
    user: UserCreateNestedOneWithoutForumPostReactionsInput
  }

  export type ForumPostReactionUncheckedCreateWithoutForumPostInput = {
    id?: string
    userId: string
    type: $Enums.ReactionType
  }

  export type ForumPostReactionCreateOrConnectWithoutForumPostInput = {
    where: ForumPostReactionWhereUniqueInput
    create: XOR<ForumPostReactionCreateWithoutForumPostInput, ForumPostReactionUncheckedCreateWithoutForumPostInput>
  }

  export type ForumPostReactionCreateManyForumPostInputEnvelope = {
    data: ForumPostReactionCreateManyForumPostInput | ForumPostReactionCreateManyForumPostInput[]
    skipDuplicates?: boolean
  }

  export type ForumPostCreateWithoutRepliesInput = {
    id?: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: ForumTopicCreateNestedOneWithoutPostsInput
    creator: UserCreateNestedOneWithoutForumPostsInput
    reactions?: ForumPostReactionCreateNestedManyWithoutForumPostInput
    parentPost?: ForumPostCreateNestedOneWithoutRepliesInput
  }

  export type ForumPostUncheckedCreateWithoutRepliesInput = {
    id?: string
    content: string
    topicId: string
    creatorId: string
    likes?: number
    parentPostId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ForumPostReactionUncheckedCreateNestedManyWithoutForumPostInput
  }

  export type ForumPostCreateOrConnectWithoutRepliesInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutRepliesInput, ForumPostUncheckedCreateWithoutRepliesInput>
  }

  export type ForumPostCreateWithoutParentPostInput = {
    id?: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: ForumTopicCreateNestedOneWithoutPostsInput
    creator: UserCreateNestedOneWithoutForumPostsInput
    reactions?: ForumPostReactionCreateNestedManyWithoutForumPostInput
    replies?: ForumPostCreateNestedManyWithoutParentPostInput
  }

  export type ForumPostUncheckedCreateWithoutParentPostInput = {
    id?: string
    content: string
    topicId: string
    creatorId: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ForumPostReactionUncheckedCreateNestedManyWithoutForumPostInput
    replies?: ForumPostUncheckedCreateNestedManyWithoutParentPostInput
  }

  export type ForumPostCreateOrConnectWithoutParentPostInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutParentPostInput, ForumPostUncheckedCreateWithoutParentPostInput>
  }

  export type ForumPostCreateManyParentPostInputEnvelope = {
    data: ForumPostCreateManyParentPostInput | ForumPostCreateManyParentPostInput[]
    skipDuplicates?: boolean
  }

  export type ForumTopicUpsertWithoutPostsInput = {
    update: XOR<ForumTopicUpdateWithoutPostsInput, ForumTopicUncheckedUpdateWithoutPostsInput>
    create: XOR<ForumTopicCreateWithoutPostsInput, ForumTopicUncheckedCreateWithoutPostsInput>
    where?: ForumTopicWhereInput
  }

  export type ForumTopicUpdateToOneWithWhereWithoutPostsInput = {
    where?: ForumTopicWhereInput
    data: XOR<ForumTopicUpdateWithoutPostsInput, ForumTopicUncheckedUpdateWithoutPostsInput>
  }

  export type ForumTopicUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forum?: ForumUpdateOneRequiredWithoutTopicsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedForumTopicsNestedInput
    replies?: ForumReplyUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ForumReplyUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type UserUpsertWithoutForumPostsInput = {
    update: XOR<UserUpdateWithoutForumPostsInput, UserUncheckedUpdateWithoutForumPostsInput>
    create: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutForumPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutForumPostsInput, UserUncheckedUpdateWithoutForumPostsInput>
  }

  export type UserUpdateWithoutForumPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutForumPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumPostReactionUpsertWithWhereUniqueWithoutForumPostInput = {
    where: ForumPostReactionWhereUniqueInput
    update: XOR<ForumPostReactionUpdateWithoutForumPostInput, ForumPostReactionUncheckedUpdateWithoutForumPostInput>
    create: XOR<ForumPostReactionCreateWithoutForumPostInput, ForumPostReactionUncheckedCreateWithoutForumPostInput>
  }

  export type ForumPostReactionUpdateWithWhereUniqueWithoutForumPostInput = {
    where: ForumPostReactionWhereUniqueInput
    data: XOR<ForumPostReactionUpdateWithoutForumPostInput, ForumPostReactionUncheckedUpdateWithoutForumPostInput>
  }

  export type ForumPostReactionUpdateManyWithWhereWithoutForumPostInput = {
    where: ForumPostReactionScalarWhereInput
    data: XOR<ForumPostReactionUpdateManyMutationInput, ForumPostReactionUncheckedUpdateManyWithoutForumPostInput>
  }

  export type ForumPostReactionScalarWhereInput = {
    AND?: ForumPostReactionScalarWhereInput | ForumPostReactionScalarWhereInput[]
    OR?: ForumPostReactionScalarWhereInput[]
    NOT?: ForumPostReactionScalarWhereInput | ForumPostReactionScalarWhereInput[]
    id?: StringFilter<"ForumPostReaction"> | string
    forumPostId?: StringFilter<"ForumPostReaction"> | string
    userId?: StringFilter<"ForumPostReaction"> | string
    type?: EnumReactionTypeFilter<"ForumPostReaction"> | $Enums.ReactionType
  }

  export type ForumPostUpsertWithoutRepliesInput = {
    update: XOR<ForumPostUpdateWithoutRepliesInput, ForumPostUncheckedUpdateWithoutRepliesInput>
    create: XOR<ForumPostCreateWithoutRepliesInput, ForumPostUncheckedCreateWithoutRepliesInput>
    where?: ForumPostWhereInput
  }

  export type ForumPostUpdateToOneWithWhereWithoutRepliesInput = {
    where?: ForumPostWhereInput
    data: XOR<ForumPostUpdateWithoutRepliesInput, ForumPostUncheckedUpdateWithoutRepliesInput>
  }

  export type ForumPostUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: ForumTopicUpdateOneRequiredWithoutPostsNestedInput
    creator?: UserUpdateOneRequiredWithoutForumPostsNestedInput
    reactions?: ForumPostReactionUpdateManyWithoutForumPostNestedInput
    parentPost?: ForumPostUpdateOneWithoutRepliesNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    parentPostId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ForumPostReactionUncheckedUpdateManyWithoutForumPostNestedInput
  }

  export type ForumPostUpsertWithWhereUniqueWithoutParentPostInput = {
    where: ForumPostWhereUniqueInput
    update: XOR<ForumPostUpdateWithoutParentPostInput, ForumPostUncheckedUpdateWithoutParentPostInput>
    create: XOR<ForumPostCreateWithoutParentPostInput, ForumPostUncheckedCreateWithoutParentPostInput>
  }

  export type ForumPostUpdateWithWhereUniqueWithoutParentPostInput = {
    where: ForumPostWhereUniqueInput
    data: XOR<ForumPostUpdateWithoutParentPostInput, ForumPostUncheckedUpdateWithoutParentPostInput>
  }

  export type ForumPostUpdateManyWithWhereWithoutParentPostInput = {
    where: ForumPostScalarWhereInput
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyWithoutParentPostInput>
  }

  export type ForumReplyCreateWithoutReactionsInput = {
    id?: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    forum: ForumCreateNestedOneWithoutForumRepliesInput
    topic: ForumTopicCreateNestedOneWithoutRepliesInput
    user: UserCreateNestedOneWithoutForumRepliesInput
    parentReply?: ForumReplyCreateNestedOneWithoutChildRepliesInput
    childReplies?: ForumReplyCreateNestedManyWithoutParentReplyInput
  }

  export type ForumReplyUncheckedCreateWithoutReactionsInput = {
    id?: string
    forumId: string
    topicId: string
    userId: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    parentReplyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    childReplies?: ForumReplyUncheckedCreateNestedManyWithoutParentReplyInput
  }

  export type ForumReplyCreateOrConnectWithoutReactionsInput = {
    where: ForumReplyWhereUniqueInput
    create: XOR<ForumReplyCreateWithoutReactionsInput, ForumReplyUncheckedCreateWithoutReactionsInput>
  }

  export type UserCreateWithoutForumReplyReactionsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutForumReplyReactionsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutForumReplyReactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutForumReplyReactionsInput, UserUncheckedCreateWithoutForumReplyReactionsInput>
  }

  export type ForumReplyUpsertWithoutReactionsInput = {
    update: XOR<ForumReplyUpdateWithoutReactionsInput, ForumReplyUncheckedUpdateWithoutReactionsInput>
    create: XOR<ForumReplyCreateWithoutReactionsInput, ForumReplyUncheckedCreateWithoutReactionsInput>
    where?: ForumReplyWhereInput
  }

  export type ForumReplyUpdateToOneWithWhereWithoutReactionsInput = {
    where?: ForumReplyWhereInput
    data: XOR<ForumReplyUpdateWithoutReactionsInput, ForumReplyUncheckedUpdateWithoutReactionsInput>
  }

  export type ForumReplyUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forum?: ForumUpdateOneRequiredWithoutForumRepliesNestedInput
    topic?: ForumTopicUpdateOneRequiredWithoutRepliesNestedInput
    user?: UserUpdateOneRequiredWithoutForumRepliesNestedInput
    parentReply?: ForumReplyUpdateOneWithoutChildRepliesNestedInput
    childReplies?: ForumReplyUpdateManyWithoutParentReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    childReplies?: ForumReplyUncheckedUpdateManyWithoutParentReplyNestedInput
  }

  export type UserUpsertWithoutForumReplyReactionsInput = {
    update: XOR<UserUpdateWithoutForumReplyReactionsInput, UserUncheckedUpdateWithoutForumReplyReactionsInput>
    create: XOR<UserCreateWithoutForumReplyReactionsInput, UserUncheckedCreateWithoutForumReplyReactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutForumReplyReactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutForumReplyReactionsInput, UserUncheckedUpdateWithoutForumReplyReactionsInput>
  }

  export type UserUpdateWithoutForumReplyReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutForumReplyReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumPostCreateWithoutReactionsInput = {
    id?: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: ForumTopicCreateNestedOneWithoutPostsInput
    creator: UserCreateNestedOneWithoutForumPostsInput
    parentPost?: ForumPostCreateNestedOneWithoutRepliesInput
    replies?: ForumPostCreateNestedManyWithoutParentPostInput
  }

  export type ForumPostUncheckedCreateWithoutReactionsInput = {
    id?: string
    content: string
    topicId: string
    creatorId: string
    likes?: number
    parentPostId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ForumPostUncheckedCreateNestedManyWithoutParentPostInput
  }

  export type ForumPostCreateOrConnectWithoutReactionsInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutReactionsInput, ForumPostUncheckedCreateWithoutReactionsInput>
  }

  export type UserCreateWithoutForumPostReactionsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutForumPostReactionsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutForumPostReactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutForumPostReactionsInput, UserUncheckedCreateWithoutForumPostReactionsInput>
  }

  export type ForumPostUpsertWithoutReactionsInput = {
    update: XOR<ForumPostUpdateWithoutReactionsInput, ForumPostUncheckedUpdateWithoutReactionsInput>
    create: XOR<ForumPostCreateWithoutReactionsInput, ForumPostUncheckedCreateWithoutReactionsInput>
    where?: ForumPostWhereInput
  }

  export type ForumPostUpdateToOneWithWhereWithoutReactionsInput = {
    where?: ForumPostWhereInput
    data: XOR<ForumPostUpdateWithoutReactionsInput, ForumPostUncheckedUpdateWithoutReactionsInput>
  }

  export type ForumPostUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: ForumTopicUpdateOneRequiredWithoutPostsNestedInput
    creator?: UserUpdateOneRequiredWithoutForumPostsNestedInput
    parentPost?: ForumPostUpdateOneWithoutRepliesNestedInput
    replies?: ForumPostUpdateManyWithoutParentPostNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    parentPostId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ForumPostUncheckedUpdateManyWithoutParentPostNestedInput
  }

  export type UserUpsertWithoutForumPostReactionsInput = {
    update: XOR<UserUpdateWithoutForumPostReactionsInput, UserUncheckedUpdateWithoutForumPostReactionsInput>
    create: XOR<UserCreateWithoutForumPostReactionsInput, UserUncheckedCreateWithoutForumPostReactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutForumPostReactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutForumPostReactionsInput, UserUncheckedUpdateWithoutForumPostReactionsInput>
  }

  export type UserUpdateWithoutForumPostReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutForumPostReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutArticlesInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutArticlesInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutArticlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
  }

  export type GroupCreateWithoutArticlesInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedGroupsInput
    events?: EventCreateNestedManyWithoutGroupInput
    forums?: ForumCreateNestedManyWithoutGroupInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    moderators?: UserCreateNestedManyWithoutAdminOfInput
  }

  export type GroupUncheckedCreateWithoutArticlesInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    createdById: string
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutGroupInput
    forums?: ForumUncheckedCreateNestedManyWithoutGroupInput
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    moderators?: UserUncheckedCreateNestedManyWithoutAdminOfInput
  }

  export type GroupCreateOrConnectWithoutArticlesInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutArticlesInput, GroupUncheckedCreateWithoutArticlesInput>
  }

  export type VoteCreateWithoutArticleInput = {
    id?: string
    userId: string
    status: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteUncheckedCreateWithoutArticleInput = {
    id?: string
    userId: string
    status: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteCreateOrConnectWithoutArticleInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutArticleInput, VoteUncheckedCreateWithoutArticleInput>
  }

  export type VoteCreateManyArticleInputEnvelope = {
    data: VoteCreateManyArticleInput | VoteCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutArticlesInput = {
    update: XOR<UserUpdateWithoutArticlesInput, UserUncheckedUpdateWithoutArticlesInput>
    create: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutArticlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutArticlesInput, UserUncheckedUpdateWithoutArticlesInput>
  }

  export type UserUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupUpsertWithoutArticlesInput = {
    update: XOR<GroupUpdateWithoutArticlesInput, GroupUncheckedUpdateWithoutArticlesInput>
    create: XOR<GroupCreateWithoutArticlesInput, GroupUncheckedCreateWithoutArticlesInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutArticlesInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutArticlesInput, GroupUncheckedUpdateWithoutArticlesInput>
  }

  export type GroupUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    events?: EventUpdateManyWithoutGroupNestedInput
    forums?: ForumUpdateManyWithoutGroupNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    moderators?: UserUpdateManyWithoutAdminOfNestedInput
  }

  export type GroupUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutGroupNestedInput
    forums?: ForumUncheckedUpdateManyWithoutGroupNestedInput
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    moderators?: UserUncheckedUpdateManyWithoutAdminOfNestedInput
  }

  export type VoteUpsertWithWhereUniqueWithoutArticleInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutArticleInput, VoteUncheckedUpdateWithoutArticleInput>
    create: XOR<VoteCreateWithoutArticleInput, VoteUncheckedCreateWithoutArticleInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutArticleInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutArticleInput, VoteUncheckedUpdateWithoutArticleInput>
  }

  export type VoteUpdateManyWithWhereWithoutArticleInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutArticleInput>
  }

  export type VoteScalarWhereInput = {
    AND?: VoteScalarWhereInput | VoteScalarWhereInput[]
    OR?: VoteScalarWhereInput[]
    NOT?: VoteScalarWhereInput | VoteScalarWhereInput[]
    id?: StringFilter<"Vote"> | string
    userId?: StringFilter<"Vote"> | string
    articleId?: StringFilter<"Vote"> | string
    status?: EnumVoteTypeFilter<"Vote"> | $Enums.VoteType
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    updatedAt?: DateTimeFilter<"Vote"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFavCoursesInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavCoursesInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavCoursesInput, UserUncheckedCreateWithoutFavCoursesInput>
  }

  export type CourseCreateWithoutFavByUsersInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    fees?: string | null
    duration?: string | null
    degreeType?: string | null
    ieltsScore?: string | null
    ranking?: string | null
    intake?: CourseCreateintakeInput | string[]
    websiteLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: UniversityApplicationsCreateNestedManyWithoutCourseInput
    university: UniversityCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutFavByUsersInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    fees?: string | null
    duration?: string | null
    degreeType?: string | null
    ieltsScore?: string | null
    ranking?: string | null
    intake?: CourseCreateintakeInput | string[]
    websiteLink?: string | null
    universityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutFavByUsersInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutFavByUsersInput, CourseUncheckedCreateWithoutFavByUsersInput>
  }

  export type UserUpsertWithoutFavCoursesInput = {
    update: XOR<UserUpdateWithoutFavCoursesInput, UserUncheckedUpdateWithoutFavCoursesInput>
    create: XOR<UserCreateWithoutFavCoursesInput, UserUncheckedCreateWithoutFavCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavCoursesInput, UserUncheckedUpdateWithoutFavCoursesInput>
  }

  export type UserUpdateWithoutFavCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutFavByUsersInput = {
    update: XOR<CourseUpdateWithoutFavByUsersInput, CourseUncheckedUpdateWithoutFavByUsersInput>
    create: XOR<CourseCreateWithoutFavByUsersInput, CourseUncheckedCreateWithoutFavByUsersInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutFavByUsersInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutFavByUsersInput, CourseUncheckedUpdateWithoutFavByUsersInput>
  }

  export type CourseUpdateWithoutFavByUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: NullableStringFieldUpdateOperationsInput | string | null
    ieltsScore?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableStringFieldUpdateOperationsInput | string | null
    intake?: CourseUpdateintakeInput | string[]
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: UniversityApplicationsUpdateManyWithoutCourseNestedInput
    university?: UniversityUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutFavByUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: NullableStringFieldUpdateOperationsInput | string | null
    ieltsScore?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableStringFieldUpdateOperationsInput | string | null
    intake?: CourseUpdateintakeInput | string[]
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    universityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type FavCourseCreateWithoutUserInput = {
    id?: string
    universityId?: string | null
    universityName?: string | null
    courseName?: string | null
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutFavByUsersInput
  }

  export type FavCourseUncheckedCreateWithoutUserInput = {
    id?: string
    universityId?: string | null
    universityName?: string | null
    courseName?: string | null
    courseId: string
    createdAt?: Date | string
  }

  export type FavCourseCreateOrConnectWithoutUserInput = {
    where: FavCourseWhereUniqueInput
    create: XOR<FavCourseCreateWithoutUserInput, FavCourseUncheckedCreateWithoutUserInput>
  }

  export type FavCourseCreateManyUserInputEnvelope = {
    data: FavCourseCreateManyUserInput | FavCourseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuizAnswerCreateWithoutUserInput = {
    questionId: number
    answer: string
  }

  export type QuizAnswerUncheckedCreateWithoutUserInput = {
    id?: number
    questionId: number
    answer: string
  }

  export type QuizAnswerCreateOrConnectWithoutUserInput = {
    where: QuizAnswerWhereUniqueInput
    create: XOR<QuizAnswerCreateWithoutUserInput, QuizAnswerUncheckedCreateWithoutUserInput>
  }

  export type QuizAnswerCreateManyUserInputEnvelope = {
    data: QuizAnswerCreateManyUserInput | QuizAnswerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ForumCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutForumsInput
    topics?: ForumTopicCreateNestedManyWithoutForumInput
    forumReplies?: ForumReplyCreateNestedManyWithoutForumInput
  }

  export type ForumUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    groupId: string
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: ForumTopicUncheckedCreateNestedManyWithoutForumInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutForumInput
  }

  export type ForumCreateOrConnectWithoutCreatorInput = {
    where: ForumWhereUniqueInput
    create: XOR<ForumCreateWithoutCreatorInput, ForumUncheckedCreateWithoutCreatorInput>
  }

  export type ForumCreateManyCreatorInputEnvelope = {
    data: ForumCreateManyCreatorInput | ForumCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ForumTopicCreateWithoutCreatorInput = {
    id?: string
    title: string
    content: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    forum: ForumCreateNestedOneWithoutTopicsInput
    posts?: ForumPostCreateNestedManyWithoutTopicInput
    replies?: ForumReplyCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    content: string
    forumId: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: ForumPostUncheckedCreateNestedManyWithoutTopicInput
    replies?: ForumReplyUncheckedCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicCreateOrConnectWithoutCreatorInput = {
    where: ForumTopicWhereUniqueInput
    create: XOR<ForumTopicCreateWithoutCreatorInput, ForumTopicUncheckedCreateWithoutCreatorInput>
  }

  export type ForumTopicCreateManyCreatorInputEnvelope = {
    data: ForumTopicCreateManyCreatorInput | ForumTopicCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ForumReplyCreateWithoutUserInput = {
    id?: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    forum: ForumCreateNestedOneWithoutForumRepliesInput
    topic: ForumTopicCreateNestedOneWithoutRepliesInput
    reactions?: ForumReplyReactionCreateNestedManyWithoutForumReplyInput
    parentReply?: ForumReplyCreateNestedOneWithoutChildRepliesInput
    childReplies?: ForumReplyCreateNestedManyWithoutParentReplyInput
  }

  export type ForumReplyUncheckedCreateWithoutUserInput = {
    id?: string
    forumId: string
    topicId: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    parentReplyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutForumReplyInput
    childReplies?: ForumReplyUncheckedCreateNestedManyWithoutParentReplyInput
  }

  export type ForumReplyCreateOrConnectWithoutUserInput = {
    where: ForumReplyWhereUniqueInput
    create: XOR<ForumReplyCreateWithoutUserInput, ForumReplyUncheckedCreateWithoutUserInput>
  }

  export type ForumReplyCreateManyUserInputEnvelope = {
    data: ForumReplyCreateManyUserInput | ForumReplyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ForumPostCreateWithoutCreatorInput = {
    id?: string
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic: ForumTopicCreateNestedOneWithoutPostsInput
    reactions?: ForumPostReactionCreateNestedManyWithoutForumPostInput
    parentPost?: ForumPostCreateNestedOneWithoutRepliesInput
    replies?: ForumPostCreateNestedManyWithoutParentPostInput
  }

  export type ForumPostUncheckedCreateWithoutCreatorInput = {
    id?: string
    content: string
    topicId: string
    likes?: number
    parentPostId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ForumPostReactionUncheckedCreateNestedManyWithoutForumPostInput
    replies?: ForumPostUncheckedCreateNestedManyWithoutParentPostInput
  }

  export type ForumPostCreateOrConnectWithoutCreatorInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutCreatorInput, ForumPostUncheckedCreateWithoutCreatorInput>
  }

  export type ForumPostCreateManyCreatorInputEnvelope = {
    data: ForumPostCreateManyCreatorInput | ForumPostCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ForumReplyReactionCreateWithoutUserInput = {
    id?: string
    type: $Enums.ReactionType
    forumReply: ForumReplyCreateNestedOneWithoutReactionsInput
  }

  export type ForumReplyReactionUncheckedCreateWithoutUserInput = {
    id?: string
    forumReplyId: string
    type: $Enums.ReactionType
  }

  export type ForumReplyReactionCreateOrConnectWithoutUserInput = {
    where: ForumReplyReactionWhereUniqueInput
    create: XOR<ForumReplyReactionCreateWithoutUserInput, ForumReplyReactionUncheckedCreateWithoutUserInput>
  }

  export type ForumReplyReactionCreateManyUserInputEnvelope = {
    data: ForumReplyReactionCreateManyUserInput | ForumReplyReactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ForumPostReactionCreateWithoutUserInput = {
    id?: string
    type: $Enums.ReactionType
    forumPost: ForumPostCreateNestedOneWithoutReactionsInput
  }

  export type ForumPostReactionUncheckedCreateWithoutUserInput = {
    id?: string
    forumPostId: string
    type: $Enums.ReactionType
  }

  export type ForumPostReactionCreateOrConnectWithoutUserInput = {
    where: ForumPostReactionWhereUniqueInput
    create: XOR<ForumPostReactionCreateWithoutUserInput, ForumPostReactionUncheckedCreateWithoutUserInput>
  }

  export type ForumPostReactionCreateManyUserInputEnvelope = {
    data: ForumPostReactionCreateManyUserInput | ForumPostReactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UniversityCreateWithoutUsersInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    careerOutcomes?: CareerOutcomeCreateNestedManyWithoutUniversityInput
    faqs?: FaqCreateNestedManyWithoutUniversityInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUniversityInput
    loans?: LoanCreateNestedManyWithoutUniversityInput
    courses?: CourseCreateNestedManyWithoutUniversityInput
  }

  export type UniversityUncheckedCreateWithoutUsersInput = {
    id?: string
    slug?: string | null
    name: string
    description: string
    location: string
    country: string
    website: string
    established: Date | string
    banner: string
    logoUrl?: string | null
    youtubeLink?: string | null
    imageUrls?: UniversityCreateimageUrlsInput | string[]
    facilities?: UniversityCreatefacilitiesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    careerOutcomes?: CareerOutcomeUncheckedCreateNestedManyWithoutUniversityInput
    faqs?: FaqUncheckedCreateNestedManyWithoutUniversityInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUniversityInput
    loans?: LoanUncheckedCreateNestedManyWithoutUniversityInput
    courses?: CourseUncheckedCreateNestedManyWithoutUniversityInput
  }

  export type UniversityCreateOrConnectWithoutUsersInput = {
    where: UniversityWhereUniqueInput
    create: XOR<UniversityCreateWithoutUsersInput, UniversityUncheckedCreateWithoutUsersInput>
  }

  export type LoanApplicationCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    documents?: LoanApplicationCreatedocumentsInput | string[]
    academicInfo: JsonNullValueInput | InputJsonValue
    financialInfo: JsonNullValueInput | InputJsonValue
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    loan: LoanCreateNestedOneWithoutApplicationsInput
  }

  export type LoanApplicationUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    documents?: LoanApplicationCreatedocumentsInput | string[]
    academicInfo: JsonNullValueInput | InputJsonValue
    financialInfo: JsonNullValueInput | InputJsonValue
    notes?: string | null
    loanId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationCreateOrConnectWithoutUserInput = {
    where: LoanApplicationWhereUniqueInput
    create: XOR<LoanApplicationCreateWithoutUserInput, LoanApplicationUncheckedCreateWithoutUserInput>
  }

  export type LoanApplicationCreateManyUserInputEnvelope = {
    data: LoanApplicationCreateManyUserInput | LoanApplicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccommodationRatingCreateWithoutUserInput = {
    id?: string
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accommodation: AccommodationCreateNestedOneWithoutRatingsInput
  }

  export type AccommodationRatingUncheckedCreateWithoutUserInput = {
    id?: string
    rating: number
    review?: string | null
    accommodationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccommodationRatingCreateOrConnectWithoutUserInput = {
    where: AccommodationRatingWhereUniqueInput
    create: XOR<AccommodationRatingCreateWithoutUserInput, AccommodationRatingUncheckedCreateWithoutUserInput>
  }

  export type AccommodationRatingCreateManyUserInputEnvelope = {
    data: AccommodationRatingCreateManyUserInput | AccommodationRatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UniversityApplicationsCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    appliedAt?: Date | string
    loanRequired?: boolean
    documents?: UniversityApplicationsCreatedocumentsInput | string[]
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    university: UniversityCreateNestedOneWithoutApplicationsInput
    course: CourseCreateNestedOneWithoutApplicationsInput
  }

  export type UniversityApplicationsUncheckedCreateWithoutUserInput = {
    id?: string
    universityId: string
    courseId: string
    status?: $Enums.ApplicationStatus
    appliedAt?: Date | string
    loanRequired?: boolean
    documents?: UniversityApplicationsCreatedocumentsInput | string[]
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityApplicationsCreateOrConnectWithoutUserInput = {
    where: UniversityApplicationsWhereUniqueInput
    create: XOR<UniversityApplicationsCreateWithoutUserInput, UniversityApplicationsUncheckedCreateWithoutUserInput>
  }

  export type UniversityApplicationsCreateManyUserInputEnvelope = {
    data: UniversityApplicationsCreateManyUserInput | UniversityApplicationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TokenCreateWithoutUserInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type TokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type TokenCreateOrConnectWithoutUserInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenCreateManyUserInputEnvelope = {
    data: TokenCreateManyUserInput | TokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccommodationCreateWithoutLandlordInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: AccommodationReviewCreateNestedManyWithoutAccommodationInput
    ratings?: AccommodationRatingCreateNestedManyWithoutAccommodationInput
    likedBy?: LikedAccommodationsCreateNestedManyWithoutAccommodationInput
    pricingPlans?: PricingPlanCreateNestedManyWithoutAccommodationInput
  }

  export type AccommodationUncheckedCreateWithoutLandlordInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: AccommodationReviewUncheckedCreateNestedManyWithoutAccommodationInput
    ratings?: AccommodationRatingUncheckedCreateNestedManyWithoutAccommodationInput
    likedBy?: LikedAccommodationsUncheckedCreateNestedManyWithoutAccommodationInput
    pricingPlans?: PricingPlanUncheckedCreateNestedManyWithoutAccommodationInput
  }

  export type AccommodationCreateOrConnectWithoutLandlordInput = {
    where: AccommodationWhereUniqueInput
    create: XOR<AccommodationCreateWithoutLandlordInput, AccommodationUncheckedCreateWithoutLandlordInput>
  }

  export type AccommodationCreateManyLandlordInputEnvelope = {
    data: AccommodationCreateManyLandlordInput | AccommodationCreateManyLandlordInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    refreshToken?: string | null
    expires: Date | string
    lastActivity?: Date | string | null
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    refreshToken?: string | null
    expires: Date | string
    lastActivity?: Date | string | null
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OTPCreateWithoutUserInput = {
    id?: string
    otpCode: string
    type: $Enums.OTPType
    purpose: $Enums.OTPPurpose
    verified?: boolean
    attempts?: number
    expiresAt: Date | string
    verifiedAt?: Date | string | null
    invalidated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTPUncheckedCreateWithoutUserInput = {
    id?: string
    otpCode: string
    type: $Enums.OTPType
    purpose: $Enums.OTPPurpose
    verified?: boolean
    attempts?: number
    expiresAt: Date | string
    verifiedAt?: Date | string | null
    invalidated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTPCreateOrConnectWithoutUserInput = {
    where: OTPWhereUniqueInput
    create: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput>
  }

  export type OTPCreateManyUserInputEnvelope = {
    data: OTPCreateManyUserInput | OTPCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    following: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowCreateManyFollowerInputEnvelope = {
    data: FollowCreateManyFollowerInput | FollowCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateWithoutFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowCreateManyFollowingInputEnvelope = {
    data: FollowCreateManyFollowingInput | FollowCreateManyFollowingInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    receiverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutReceiverInput = {
    id?: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateManyReceiverInputEnvelope = {
    data: MessageCreateManyReceiverInput | MessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutCreatedByInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutGroupInput
    articles?: ArticleCreateNestedManyWithoutGroupInput
    forums?: ForumCreateNestedManyWithoutGroupInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    moderators?: UserCreateNestedManyWithoutAdminOfInput
  }

  export type GroupUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutGroupInput
    articles?: ArticleUncheckedCreateNestedManyWithoutGroupInput
    forums?: ForumUncheckedCreateNestedManyWithoutGroupInput
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    moderators?: UserUncheckedCreateNestedManyWithoutAdminOfInput
  }

  export type GroupCreateOrConnectWithoutCreatedByInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutCreatedByInput, GroupUncheckedCreateWithoutCreatedByInput>
  }

  export type GroupCreateManyCreatedByInputEnvelope = {
    data: GroupCreateManyCreatedByInput | GroupCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutModeratorsInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedGroupsInput
    events?: EventCreateNestedManyWithoutGroupInput
    articles?: ArticleCreateNestedManyWithoutGroupInput
    forums?: ForumCreateNestedManyWithoutGroupInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutModeratorsInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    createdById: string
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutGroupInput
    articles?: ArticleUncheckedCreateNestedManyWithoutGroupInput
    forums?: ForumUncheckedCreateNestedManyWithoutGroupInput
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutModeratorsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutModeratorsInput, GroupUncheckedCreateWithoutModeratorsInput>
  }

  export type GroupMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
    group: GroupCreateNestedOneWithoutMembersInput
  }

  export type GroupMemberUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberCreateManyUserInputEnvelope = {
    data: GroupMemberCreateManyUserInput | GroupMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutContactByInput = {
    id?: string
    title: string
    slug: string
    description: string
    date: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    image?: string | null
    location: string
    eventType?: $Enums.EventType
    registrationType?: $Enums.RegistrationType
    totalSlots: number
    registeredSlots?: number
    waitlistSlots?: number | null
    ticketPrice?: number | null
    currency?: string | null
    address?: string | null
    virtualLink?: string | null
    status?: $Enums.EventStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutEventsInput
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutContactByInput = {
    id?: string
    title: string
    slug: string
    description: string
    date: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    image?: string | null
    location: string
    eventType?: $Enums.EventType
    registrationType?: $Enums.RegistrationType
    totalSlots: number
    registeredSlots?: number
    waitlistSlots?: number | null
    ticketPrice?: number | null
    currency?: string | null
    address?: string | null
    virtualLink?: string | null
    groupId: string
    status?: $Enums.EventStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutContactByInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutContactByInput, EventUncheckedCreateWithoutContactByInput>
  }

  export type EventCreateManyContactByInputEnvelope = {
    data: EventCreateManyContactByInput | EventCreateManyContactByInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    bannerImg?: string | null
    images?: ArticleCreateimagesInput | string[]
    tags?: ArticleCreatetagsInput | string[]
    type?: $Enums.ArticleType
    status?: $Enums.ArticleStatus
    upVotes?: number
    downVotes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    group?: GroupCreateNestedOneWithoutArticlesInput
    votes?: VoteCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    bannerImg?: string | null
    images?: ArticleCreateimagesInput | string[]
    tags?: ArticleCreatetagsInput | string[]
    type?: $Enums.ArticleType
    status?: $Enums.ArticleStatus
    groupId?: string | null
    upVotes?: number
    downVotes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutCreatorInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutCreatorInput, ArticleUncheckedCreateWithoutCreatorInput>
  }

  export type ArticleCreateManyCreatorInputEnvelope = {
    data: ArticleCreateManyCreatorInput | ArticleCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AccommodationReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accommodation: AccommodationCreateNestedOneWithoutReviewsInput
  }

  export type AccommodationReviewUncheckedCreateWithoutUserInput = {
    id?: string
    rating: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accommodationId: string
  }

  export type AccommodationReviewCreateOrConnectWithoutUserInput = {
    where: AccommodationReviewWhereUniqueInput
    create: XOR<AccommodationReviewCreateWithoutUserInput, AccommodationReviewUncheckedCreateWithoutUserInput>
  }

  export type AccommodationReviewCreateManyUserInputEnvelope = {
    data: AccommodationReviewCreateManyUserInput | AccommodationReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LikedAccommodationsCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accommodation: AccommodationCreateNestedOneWithoutLikedByInput
  }

  export type LikedAccommodationsUncheckedCreateWithoutUserInput = {
    id?: string
    accommodationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikedAccommodationsCreateOrConnectWithoutUserInput = {
    where: LikedAccommodationsWhereUniqueInput
    create: XOR<LikedAccommodationsCreateWithoutUserInput, LikedAccommodationsUncheckedCreateWithoutUserInput>
  }

  export type LikedAccommodationsCreateManyUserInputEnvelope = {
    data: LikedAccommodationsCreateManyUserInput | LikedAccommodationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FavCourseUpsertWithWhereUniqueWithoutUserInput = {
    where: FavCourseWhereUniqueInput
    update: XOR<FavCourseUpdateWithoutUserInput, FavCourseUncheckedUpdateWithoutUserInput>
    create: XOR<FavCourseCreateWithoutUserInput, FavCourseUncheckedCreateWithoutUserInput>
  }

  export type FavCourseUpdateWithWhereUniqueWithoutUserInput = {
    where: FavCourseWhereUniqueInput
    data: XOR<FavCourseUpdateWithoutUserInput, FavCourseUncheckedUpdateWithoutUserInput>
  }

  export type FavCourseUpdateManyWithWhereWithoutUserInput = {
    where: FavCourseScalarWhereInput
    data: XOR<FavCourseUpdateManyMutationInput, FavCourseUncheckedUpdateManyWithoutUserInput>
  }

  export type QuizAnswerUpsertWithWhereUniqueWithoutUserInput = {
    where: QuizAnswerWhereUniqueInput
    update: XOR<QuizAnswerUpdateWithoutUserInput, QuizAnswerUncheckedUpdateWithoutUserInput>
    create: XOR<QuizAnswerCreateWithoutUserInput, QuizAnswerUncheckedCreateWithoutUserInput>
  }

  export type QuizAnswerUpdateWithWhereUniqueWithoutUserInput = {
    where: QuizAnswerWhereUniqueInput
    data: XOR<QuizAnswerUpdateWithoutUserInput, QuizAnswerUncheckedUpdateWithoutUserInput>
  }

  export type QuizAnswerUpdateManyWithWhereWithoutUserInput = {
    where: QuizAnswerScalarWhereInput
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyWithoutUserInput>
  }

  export type QuizAnswerScalarWhereInput = {
    AND?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
    OR?: QuizAnswerScalarWhereInput[]
    NOT?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
    id?: IntFilter<"QuizAnswer"> | number
    userId?: StringFilter<"QuizAnswer"> | string
    questionId?: IntFilter<"QuizAnswer"> | number
    answer?: StringFilter<"QuizAnswer"> | string
  }

  export type ForumUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ForumWhereUniqueInput
    update: XOR<ForumUpdateWithoutCreatorInput, ForumUncheckedUpdateWithoutCreatorInput>
    create: XOR<ForumCreateWithoutCreatorInput, ForumUncheckedCreateWithoutCreatorInput>
  }

  export type ForumUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ForumWhereUniqueInput
    data: XOR<ForumUpdateWithoutCreatorInput, ForumUncheckedUpdateWithoutCreatorInput>
  }

  export type ForumUpdateManyWithWhereWithoutCreatorInput = {
    where: ForumScalarWhereInput
    data: XOR<ForumUpdateManyMutationInput, ForumUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ForumTopicUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ForumTopicWhereUniqueInput
    update: XOR<ForumTopicUpdateWithoutCreatorInput, ForumTopicUncheckedUpdateWithoutCreatorInput>
    create: XOR<ForumTopicCreateWithoutCreatorInput, ForumTopicUncheckedCreateWithoutCreatorInput>
  }

  export type ForumTopicUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ForumTopicWhereUniqueInput
    data: XOR<ForumTopicUpdateWithoutCreatorInput, ForumTopicUncheckedUpdateWithoutCreatorInput>
  }

  export type ForumTopicUpdateManyWithWhereWithoutCreatorInput = {
    where: ForumTopicScalarWhereInput
    data: XOR<ForumTopicUpdateManyMutationInput, ForumTopicUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ForumReplyUpsertWithWhereUniqueWithoutUserInput = {
    where: ForumReplyWhereUniqueInput
    update: XOR<ForumReplyUpdateWithoutUserInput, ForumReplyUncheckedUpdateWithoutUserInput>
    create: XOR<ForumReplyCreateWithoutUserInput, ForumReplyUncheckedCreateWithoutUserInput>
  }

  export type ForumReplyUpdateWithWhereUniqueWithoutUserInput = {
    where: ForumReplyWhereUniqueInput
    data: XOR<ForumReplyUpdateWithoutUserInput, ForumReplyUncheckedUpdateWithoutUserInput>
  }

  export type ForumReplyUpdateManyWithWhereWithoutUserInput = {
    where: ForumReplyScalarWhereInput
    data: XOR<ForumReplyUpdateManyMutationInput, ForumReplyUncheckedUpdateManyWithoutUserInput>
  }

  export type ForumPostUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ForumPostWhereUniqueInput
    update: XOR<ForumPostUpdateWithoutCreatorInput, ForumPostUncheckedUpdateWithoutCreatorInput>
    create: XOR<ForumPostCreateWithoutCreatorInput, ForumPostUncheckedCreateWithoutCreatorInput>
  }

  export type ForumPostUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ForumPostWhereUniqueInput
    data: XOR<ForumPostUpdateWithoutCreatorInput, ForumPostUncheckedUpdateWithoutCreatorInput>
  }

  export type ForumPostUpdateManyWithWhereWithoutCreatorInput = {
    where: ForumPostScalarWhereInput
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ForumReplyReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: ForumReplyReactionWhereUniqueInput
    update: XOR<ForumReplyReactionUpdateWithoutUserInput, ForumReplyReactionUncheckedUpdateWithoutUserInput>
    create: XOR<ForumReplyReactionCreateWithoutUserInput, ForumReplyReactionUncheckedCreateWithoutUserInput>
  }

  export type ForumReplyReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: ForumReplyReactionWhereUniqueInput
    data: XOR<ForumReplyReactionUpdateWithoutUserInput, ForumReplyReactionUncheckedUpdateWithoutUserInput>
  }

  export type ForumReplyReactionUpdateManyWithWhereWithoutUserInput = {
    where: ForumReplyReactionScalarWhereInput
    data: XOR<ForumReplyReactionUpdateManyMutationInput, ForumReplyReactionUncheckedUpdateManyWithoutUserInput>
  }

  export type ForumPostReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: ForumPostReactionWhereUniqueInput
    update: XOR<ForumPostReactionUpdateWithoutUserInput, ForumPostReactionUncheckedUpdateWithoutUserInput>
    create: XOR<ForumPostReactionCreateWithoutUserInput, ForumPostReactionUncheckedCreateWithoutUserInput>
  }

  export type ForumPostReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: ForumPostReactionWhereUniqueInput
    data: XOR<ForumPostReactionUpdateWithoutUserInput, ForumPostReactionUncheckedUpdateWithoutUserInput>
  }

  export type ForumPostReactionUpdateManyWithWhereWithoutUserInput = {
    where: ForumPostReactionScalarWhereInput
    data: XOR<ForumPostReactionUpdateManyMutationInput, ForumPostReactionUncheckedUpdateManyWithoutUserInput>
  }

  export type UniversityUpsertWithoutUsersInput = {
    update: XOR<UniversityUpdateWithoutUsersInput, UniversityUncheckedUpdateWithoutUsersInput>
    create: XOR<UniversityCreateWithoutUsersInput, UniversityUncheckedCreateWithoutUsersInput>
    where?: UniversityWhereInput
  }

  export type UniversityUpdateToOneWithWhereWithoutUsersInput = {
    where?: UniversityWhereInput
    data: XOR<UniversityUpdateWithoutUsersInput, UniversityUncheckedUpdateWithoutUsersInput>
  }

  export type UniversityUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerOutcomes?: CareerOutcomeUpdateManyWithoutUniversityNestedInput
    faqs?: FaqUpdateManyWithoutUniversityNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUniversityNestedInput
    loans?: LoanUpdateManyWithoutUniversityNestedInput
    courses?: CourseUpdateManyWithoutUniversityNestedInput
  }

  export type UniversityUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    established?: DateTimeFieldUpdateOperationsInput | Date | string
    banner?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrls?: UniversityUpdateimageUrlsInput | string[]
    facilities?: UniversityUpdatefacilitiesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerOutcomes?: CareerOutcomeUncheckedUpdateManyWithoutUniversityNestedInput
    faqs?: FaqUncheckedUpdateManyWithoutUniversityNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUniversityNestedInput
    loans?: LoanUncheckedUpdateManyWithoutUniversityNestedInput
    courses?: CourseUncheckedUpdateManyWithoutUniversityNestedInput
  }

  export type LoanApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: LoanApplicationWhereUniqueInput
    update: XOR<LoanApplicationUpdateWithoutUserInput, LoanApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<LoanApplicationCreateWithoutUserInput, LoanApplicationUncheckedCreateWithoutUserInput>
  }

  export type LoanApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: LoanApplicationWhereUniqueInput
    data: XOR<LoanApplicationUpdateWithoutUserInput, LoanApplicationUncheckedUpdateWithoutUserInput>
  }

  export type LoanApplicationUpdateManyWithWhereWithoutUserInput = {
    where: LoanApplicationScalarWhereInput
    data: XOR<LoanApplicationUpdateManyMutationInput, LoanApplicationUncheckedUpdateManyWithoutUserInput>
  }

  export type AccommodationRatingUpsertWithWhereUniqueWithoutUserInput = {
    where: AccommodationRatingWhereUniqueInput
    update: XOR<AccommodationRatingUpdateWithoutUserInput, AccommodationRatingUncheckedUpdateWithoutUserInput>
    create: XOR<AccommodationRatingCreateWithoutUserInput, AccommodationRatingUncheckedCreateWithoutUserInput>
  }

  export type AccommodationRatingUpdateWithWhereUniqueWithoutUserInput = {
    where: AccommodationRatingWhereUniqueInput
    data: XOR<AccommodationRatingUpdateWithoutUserInput, AccommodationRatingUncheckedUpdateWithoutUserInput>
  }

  export type AccommodationRatingUpdateManyWithWhereWithoutUserInput = {
    where: AccommodationRatingScalarWhereInput
    data: XOR<AccommodationRatingUpdateManyMutationInput, AccommodationRatingUncheckedUpdateManyWithoutUserInput>
  }

  export type UniversityApplicationsUpsertWithWhereUniqueWithoutUserInput = {
    where: UniversityApplicationsWhereUniqueInput
    update: XOR<UniversityApplicationsUpdateWithoutUserInput, UniversityApplicationsUncheckedUpdateWithoutUserInput>
    create: XOR<UniversityApplicationsCreateWithoutUserInput, UniversityApplicationsUncheckedCreateWithoutUserInput>
  }

  export type UniversityApplicationsUpdateWithWhereUniqueWithoutUserInput = {
    where: UniversityApplicationsWhereUniqueInput
    data: XOR<UniversityApplicationsUpdateWithoutUserInput, UniversityApplicationsUncheckedUpdateWithoutUserInput>
  }

  export type UniversityApplicationsUpdateManyWithWhereWithoutUserInput = {
    where: UniversityApplicationsScalarWhereInput
    data: XOR<UniversityApplicationsUpdateManyMutationInput, UniversityApplicationsUncheckedUpdateManyWithoutUserInput>
  }

  export type TokenUpsertWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
  }

  export type TokenUpdateManyWithWhereWithoutUserInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutUserInput>
  }

  export type TokenScalarWhereInput = {
    AND?: TokenScalarWhereInput | TokenScalarWhereInput[]
    OR?: TokenScalarWhereInput[]
    NOT?: TokenScalarWhereInput | TokenScalarWhereInput[]
    id?: StringFilter<"Token"> | string
    token?: StringFilter<"Token"> | string
    type?: EnumTokenTypeFilter<"Token"> | $Enums.TokenType
    userId?: StringFilter<"Token"> | string
    createdAt?: DateTimeFilter<"Token"> | Date | string
    expiresAt?: DateTimeFilter<"Token"> | Date | string
  }

  export type AccommodationUpsertWithWhereUniqueWithoutLandlordInput = {
    where: AccommodationWhereUniqueInput
    update: XOR<AccommodationUpdateWithoutLandlordInput, AccommodationUncheckedUpdateWithoutLandlordInput>
    create: XOR<AccommodationCreateWithoutLandlordInput, AccommodationUncheckedCreateWithoutLandlordInput>
  }

  export type AccommodationUpdateWithWhereUniqueWithoutLandlordInput = {
    where: AccommodationWhereUniqueInput
    data: XOR<AccommodationUpdateWithoutLandlordInput, AccommodationUncheckedUpdateWithoutLandlordInput>
  }

  export type AccommodationUpdateManyWithWhereWithoutLandlordInput = {
    where: AccommodationScalarWhereInput
    data: XOR<AccommodationUpdateManyMutationInput, AccommodationUncheckedUpdateManyWithoutLandlordInput>
  }

  export type AccommodationScalarWhereInput = {
    AND?: AccommodationScalarWhereInput | AccommodationScalarWhereInput[]
    OR?: AccommodationScalarWhereInput[]
    NOT?: AccommodationScalarWhereInput | AccommodationScalarWhereInput[]
    id?: StringFilter<"Accommodation"> | string
    title?: StringFilter<"Accommodation"> | string
    description?: StringFilter<"Accommodation"> | string
    type?: EnumAccommodationTypeFilter<"Accommodation"> | $Enums.AccommodationType
    address?: StringFilter<"Accommodation"> | string
    city?: StringFilter<"Accommodation"> | string
    country?: StringFilter<"Accommodation"> | string
    banner?: StringFilter<"Accommodation"> | string
    includeBills?: BoolNullableFilter<"Accommodation"> | boolean | null
    deposit?: FloatNullableFilter<"Accommodation"> | number | null
    furnishing?: EnumFurnishingTypeNullableFilter<"Accommodation"> | $Enums.FurnishingType | null
    bathrooms?: IntFilter<"Accommodation"> | number
    bedrooms?: IntFilter<"Accommodation"> | number
    size?: FloatNullableFilter<"Accommodation"> | number | null
    amenities?: StringNullableListFilter<"Accommodation">
    rules?: StringNullableListFilter<"Accommodation">
    images?: StringNullableListFilter<"Accommodation">
    availableFrom?: DateTimeFilter<"Accommodation"> | Date | string
    minTerm?: IntFilter<"Accommodation"> | number
    maxTerm?: IntNullableFilter<"Accommodation"> | number | null
    isAvailable?: BoolFilter<"Accommodation"> | boolean
    landlordId?: StringFilter<"Accommodation"> | string
    averageRating?: FloatNullableFilter<"Accommodation"> | number | null
    totalRatings?: IntFilter<"Accommodation"> | number
    createdAt?: DateTimeFilter<"Accommodation"> | Date | string
    updatedAt?: DateTimeFilter<"Accommodation"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    refreshToken?: StringNullableFilter<"Session"> | string | null
    expires?: DateTimeFilter<"Session"> | Date | string
    lastActivity?: DateTimeNullableFilter<"Session"> | Date | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type OTPUpsertWithWhereUniqueWithoutUserInput = {
    where: OTPWhereUniqueInput
    update: XOR<OTPUpdateWithoutUserInput, OTPUncheckedUpdateWithoutUserInput>
    create: XOR<OTPCreateWithoutUserInput, OTPUncheckedCreateWithoutUserInput>
  }

  export type OTPUpdateWithWhereUniqueWithoutUserInput = {
    where: OTPWhereUniqueInput
    data: XOR<OTPUpdateWithoutUserInput, OTPUncheckedUpdateWithoutUserInput>
  }

  export type OTPUpdateManyWithWhereWithoutUserInput = {
    where: OTPScalarWhereInput
    data: XOR<OTPUpdateManyMutationInput, OTPUncheckedUpdateManyWithoutUserInput>
  }

  export type OTPScalarWhereInput = {
    AND?: OTPScalarWhereInput | OTPScalarWhereInput[]
    OR?: OTPScalarWhereInput[]
    NOT?: OTPScalarWhereInput | OTPScalarWhereInput[]
    id?: StringFilter<"OTP"> | string
    userId?: StringFilter<"OTP"> | string
    otpCode?: StringFilter<"OTP"> | string
    type?: EnumOTPTypeFilter<"OTP"> | $Enums.OTPType
    purpose?: EnumOTPPurposeFilter<"OTP"> | $Enums.OTPPurpose
    verified?: BoolFilter<"OTP"> | boolean
    attempts?: IntFilter<"OTP"> | number
    expiresAt?: DateTimeFilter<"OTP"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"OTP"> | Date | string | null
    invalidated?: BoolFilter<"OTP"> | boolean
    createdAt?: DateTimeFilter<"OTP"> | Date | string
    updatedAt?: DateTimeFilter<"OTP"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    attachments?: StringNullableListFilter<"Message">
    isRead?: BoolFilter<"Message"> | boolean
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type GroupUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutCreatedByInput, GroupUncheckedUpdateWithoutCreatedByInput>
    create: XOR<GroupCreateWithoutCreatedByInput, GroupUncheckedCreateWithoutCreatedByInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutCreatedByInput, GroupUncheckedUpdateWithoutCreatedByInput>
  }

  export type GroupUpdateManyWithWhereWithoutCreatedByInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    slug?: StringFilter<"Group"> | string
    banner?: StringNullableFilter<"Group"> | string | null
    logo?: StringNullableFilter<"Group"> | string | null
    description?: StringFilter<"Group"> | string
    privacy?: EnumGroupPrivacyFilter<"Group"> | $Enums.GroupPrivacy
    followersCount?: IntFilter<"Group"> | number
    postsCount?: IntFilter<"Group"> | number
    createdById?: StringFilter<"Group"> | string
    isPinned?: BoolFilter<"Group"> | boolean
    isActive?: BoolFilter<"Group"> | boolean
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
  }

  export type GroupUpsertWithWhereUniqueWithoutModeratorsInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutModeratorsInput, GroupUncheckedUpdateWithoutModeratorsInput>
    create: XOR<GroupCreateWithoutModeratorsInput, GroupUncheckedCreateWithoutModeratorsInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutModeratorsInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutModeratorsInput, GroupUncheckedUpdateWithoutModeratorsInput>
  }

  export type GroupUpdateManyWithWhereWithoutModeratorsInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutModeratorsInput>
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type EventUpsertWithWhereUniqueWithoutContactByInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutContactByInput, EventUncheckedUpdateWithoutContactByInput>
    create: XOR<EventCreateWithoutContactByInput, EventUncheckedCreateWithoutContactByInput>
  }

  export type EventUpdateWithWhereUniqueWithoutContactByInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutContactByInput, EventUncheckedUpdateWithoutContactByInput>
  }

  export type EventUpdateManyWithWhereWithoutContactByInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutContactByInput>
  }

  export type ArticleUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutCreatorInput, ArticleUncheckedUpdateWithoutCreatorInput>
    create: XOR<ArticleCreateWithoutCreatorInput, ArticleUncheckedCreateWithoutCreatorInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutCreatorInput, ArticleUncheckedUpdateWithoutCreatorInput>
  }

  export type ArticleUpdateManyWithWhereWithoutCreatorInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AccommodationReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: AccommodationReviewWhereUniqueInput
    update: XOR<AccommodationReviewUpdateWithoutUserInput, AccommodationReviewUncheckedUpdateWithoutUserInput>
    create: XOR<AccommodationReviewCreateWithoutUserInput, AccommodationReviewUncheckedCreateWithoutUserInput>
  }

  export type AccommodationReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: AccommodationReviewWhereUniqueInput
    data: XOR<AccommodationReviewUpdateWithoutUserInput, AccommodationReviewUncheckedUpdateWithoutUserInput>
  }

  export type AccommodationReviewUpdateManyWithWhereWithoutUserInput = {
    where: AccommodationReviewScalarWhereInput
    data: XOR<AccommodationReviewUpdateManyMutationInput, AccommodationReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type LikedAccommodationsUpsertWithWhereUniqueWithoutUserInput = {
    where: LikedAccommodationsWhereUniqueInput
    update: XOR<LikedAccommodationsUpdateWithoutUserInput, LikedAccommodationsUncheckedUpdateWithoutUserInput>
    create: XOR<LikedAccommodationsCreateWithoutUserInput, LikedAccommodationsUncheckedCreateWithoutUserInput>
  }

  export type LikedAccommodationsUpdateWithWhereUniqueWithoutUserInput = {
    where: LikedAccommodationsWhereUniqueInput
    data: XOR<LikedAccommodationsUpdateWithoutUserInput, LikedAccommodationsUncheckedUpdateWithoutUserInput>
  }

  export type LikedAccommodationsUpdateManyWithWhereWithoutUserInput = {
    where: LikedAccommodationsScalarWhereInput
    data: XOR<LikedAccommodationsUpdateManyMutationInput, LikedAccommodationsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutQuizAnswersInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuizAnswersInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuizAnswersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuizAnswersInput, UserUncheckedCreateWithoutQuizAnswersInput>
  }

  export type UserUpsertWithoutQuizAnswersInput = {
    update: XOR<UserUpdateWithoutQuizAnswersInput, UserUncheckedUpdateWithoutQuizAnswersInput>
    create: XOR<UserCreateWithoutQuizAnswersInput, UserUncheckedCreateWithoutQuizAnswersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuizAnswersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuizAnswersInput, UserUncheckedUpdateWithoutQuizAnswersInput>
  }

  export type UserUpdateWithoutQuizAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuizAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLikedAccommodationsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikedAccommodationsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikedAccommodationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedAccommodationsInput, UserUncheckedCreateWithoutLikedAccommodationsInput>
  }

  export type AccommodationCreateWithoutLikedByInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    landlord: UserCreateNestedOneWithoutAccommodationsInput
    reviews?: AccommodationReviewCreateNestedManyWithoutAccommodationInput
    ratings?: AccommodationRatingCreateNestedManyWithoutAccommodationInput
    pricingPlans?: PricingPlanCreateNestedManyWithoutAccommodationInput
  }

  export type AccommodationUncheckedCreateWithoutLikedByInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    landlordId: string
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: AccommodationReviewUncheckedCreateNestedManyWithoutAccommodationInput
    ratings?: AccommodationRatingUncheckedCreateNestedManyWithoutAccommodationInput
    pricingPlans?: PricingPlanUncheckedCreateNestedManyWithoutAccommodationInput
  }

  export type AccommodationCreateOrConnectWithoutLikedByInput = {
    where: AccommodationWhereUniqueInput
    create: XOR<AccommodationCreateWithoutLikedByInput, AccommodationUncheckedCreateWithoutLikedByInput>
  }

  export type UserUpsertWithoutLikedAccommodationsInput = {
    update: XOR<UserUpdateWithoutLikedAccommodationsInput, UserUncheckedUpdateWithoutLikedAccommodationsInput>
    create: XOR<UserCreateWithoutLikedAccommodationsInput, UserUncheckedCreateWithoutLikedAccommodationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikedAccommodationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikedAccommodationsInput, UserUncheckedUpdateWithoutLikedAccommodationsInput>
  }

  export type UserUpdateWithoutLikedAccommodationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedAccommodationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccommodationUpsertWithoutLikedByInput = {
    update: XOR<AccommodationUpdateWithoutLikedByInput, AccommodationUncheckedUpdateWithoutLikedByInput>
    create: XOR<AccommodationCreateWithoutLikedByInput, AccommodationUncheckedCreateWithoutLikedByInput>
    where?: AccommodationWhereInput
  }

  export type AccommodationUpdateToOneWithWhereWithoutLikedByInput = {
    where?: AccommodationWhereInput
    data: XOR<AccommodationUpdateWithoutLikedByInput, AccommodationUncheckedUpdateWithoutLikedByInput>
  }

  export type AccommodationUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    landlord?: UserUpdateOneRequiredWithoutAccommodationsNestedInput
    reviews?: AccommodationReviewUpdateManyWithoutAccommodationNestedInput
    ratings?: AccommodationRatingUpdateManyWithoutAccommodationNestedInput
    pricingPlans?: PricingPlanUpdateManyWithoutAccommodationNestedInput
  }

  export type AccommodationUncheckedUpdateWithoutLikedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    landlordId?: StringFieldUpdateOperationsInput | string
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: AccommodationReviewUncheckedUpdateManyWithoutAccommodationNestedInput
    ratings?: AccommodationRatingUncheckedUpdateManyWithoutAccommodationNestedInput
    pricingPlans?: PricingPlanUncheckedUpdateManyWithoutAccommodationNestedInput
  }

  export type UserCreateWithoutTokensInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    otps?: OTPCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTokensInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    otps?: OTPUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
  }

  export type UserUpsertWithoutTokensInput = {
    update: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
  }

  export type UserUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOtpsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerCreateNestedManyWithoutUserInput
    createdForums?: ForumCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionCreateNestedManyWithoutUserInput
    university?: UniversityCreateNestedOneWithoutUsersInput
    loanApplications?: LoanApplicationCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    accommodations?: AccommodationCreateNestedManyWithoutLandlordInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    following?: FollowCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    hostedEvents?: EventCreateNestedManyWithoutContactByInput
    articles?: ArticleCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOtpsInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    universityId?: string | null
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favCourses?: FavCourseUncheckedCreateNestedManyWithoutUserInput
    quizAnswers?: QuizAnswerUncheckedCreateNestedManyWithoutUserInput
    createdForums?: ForumUncheckedCreateNestedManyWithoutCreatorInput
    createdForumTopics?: ForumTopicUncheckedCreateNestedManyWithoutCreatorInput
    forumReplies?: ForumReplyUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutCreatorInput
    forumReplyReactions?: ForumReplyReactionUncheckedCreateNestedManyWithoutUserInput
    forumPostReactions?: ForumPostReactionUncheckedCreateNestedManyWithoutUserInput
    loanApplications?: LoanApplicationUncheckedCreateNestedManyWithoutUserInput
    accommodationRatings?: AccommodationRatingUncheckedCreateNestedManyWithoutUserInput
    applications?: UniversityApplicationsUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    accommodations?: AccommodationUncheckedCreateNestedManyWithoutLandlordInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    createdGroups?: GroupUncheckedCreateNestedManyWithoutCreatedByInput
    adminOf?: GroupUncheckedCreateNestedManyWithoutModeratorsInput
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    hostedEvents?: EventUncheckedCreateNestedManyWithoutContactByInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCreatorInput
    accommodationReviews?: AccommodationReviewUncheckedCreateNestedManyWithoutUserInput
    likedAccommodations?: LikedAccommodationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOtpsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
  }

  export type UserUpsertWithoutOtpsInput = {
    update: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtpsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type UserUpdateWithoutOtpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContentBlockCreateWithoutBlogInput = {
    id?: string
    type: string
    content: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentBlockUncheckedCreateWithoutBlogInput = {
    id?: string
    type: string
    content: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentBlockCreateOrConnectWithoutBlogInput = {
    where: ContentBlockWhereUniqueInput
    create: XOR<ContentBlockCreateWithoutBlogInput, ContentBlockUncheckedCreateWithoutBlogInput>
  }

  export type ContentBlockCreateManyBlogInputEnvelope = {
    data: ContentBlockCreateManyBlogInput | ContentBlockCreateManyBlogInput[]
    skipDuplicates?: boolean
  }

  export type ContentBlockUpsertWithWhereUniqueWithoutBlogInput = {
    where: ContentBlockWhereUniqueInput
    update: XOR<ContentBlockUpdateWithoutBlogInput, ContentBlockUncheckedUpdateWithoutBlogInput>
    create: XOR<ContentBlockCreateWithoutBlogInput, ContentBlockUncheckedCreateWithoutBlogInput>
  }

  export type ContentBlockUpdateWithWhereUniqueWithoutBlogInput = {
    where: ContentBlockWhereUniqueInput
    data: XOR<ContentBlockUpdateWithoutBlogInput, ContentBlockUncheckedUpdateWithoutBlogInput>
  }

  export type ContentBlockUpdateManyWithWhereWithoutBlogInput = {
    where: ContentBlockScalarWhereInput
    data: XOR<ContentBlockUpdateManyMutationInput, ContentBlockUncheckedUpdateManyWithoutBlogInput>
  }

  export type ContentBlockScalarWhereInput = {
    AND?: ContentBlockScalarWhereInput | ContentBlockScalarWhereInput[]
    OR?: ContentBlockScalarWhereInput[]
    NOT?: ContentBlockScalarWhereInput | ContentBlockScalarWhereInput[]
    id?: UuidFilter<"ContentBlock"> | string
    type?: StringFilter<"ContentBlock"> | string
    content?: StringFilter<"ContentBlock"> | string
    order?: IntFilter<"ContentBlock"> | number
    blogId?: UuidFilter<"ContentBlock"> | string
    createdAt?: DateTimeFilter<"ContentBlock"> | Date | string
    updatedAt?: DateTimeFilter<"ContentBlock"> | Date | string
  }

  export type BlogCreateWithoutContentBlocksInput = {
    id?: string
    title: string
    slug: string
    summary: string
    coverImage?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogUncheckedCreateWithoutContentBlocksInput = {
    id?: string
    title: string
    slug: string
    summary: string
    coverImage?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogCreateOrConnectWithoutContentBlocksInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutContentBlocksInput, BlogUncheckedCreateWithoutContentBlocksInput>
  }

  export type BlogUpsertWithoutContentBlocksInput = {
    update: XOR<BlogUpdateWithoutContentBlocksInput, BlogUncheckedUpdateWithoutContentBlocksInput>
    create: XOR<BlogCreateWithoutContentBlocksInput, BlogUncheckedCreateWithoutContentBlocksInput>
    where?: BlogWhereInput
  }

  export type BlogUpdateToOneWithWhereWithoutContentBlocksInput = {
    where?: BlogWhereInput
    data: XOR<BlogUpdateWithoutContentBlocksInput, BlogUncheckedUpdateWithoutContentBlocksInput>
  }

  export type BlogUpdateWithoutContentBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUncheckedUpdateWithoutContentBlocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerOutcomeCreateManyUniversityInput = {
    id?: string
    iconName: string
    iconImage: string
    title: string
    value: string
    description: string
    details: string
    color: string
    bgColor: string
  }

  export type FaqCreateManyUniversityInput = {
    id?: string
    question: string
    answer: string
  }

  export type UniversityApplicationsCreateManyUniversityInput = {
    id?: string
    userId: string
    courseId: string
    status?: $Enums.ApplicationStatus
    appliedAt?: Date | string
    loanRequired?: boolean
    documents?: UniversityApplicationsCreatedocumentsInput | string[]
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanCreateManyUniversityInput = {
    id?: string
    title: string
    description: string
    amount: number
    interestRate: number
    duration: number
    eligibilityCriteria?: LoanCreateeligibilityCriteriaInput | string[]
    documents?: LoanCreatedocumentsInput | string[]
    deadline?: Date | string | null
    maxApplications?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyUniversityInput = {
    id?: string
    username: string
    email: string
    password?: string | null
    countryCode?: string | null
    phoneNumber?: string | null
    name: string
    header?: string | null
    bio?: string | null
    avatarUrl?: string | null
    banner?: string | null
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    image?: string | null
    googleId?: string | null
    googleAccessToken?: string | null
    googleRefreshToken?: string | null
    googleTokenExpiry?: Date | string | null
    resetPasswordToken?: string | null
    resetPasswordExpiry?: Date | string | null
    lastPasswordChangeAt?: Date | string | null
    isVerified?: boolean
    isPhoneVerified?: boolean
    isEmailVerified?: boolean
    otpRetryCount?: number
    otpLastSentAt?: Date | string | null
    otpBlockedUntil?: Date | string | null
    followersCount?: number
    followingCount?: number
    department?: string | null
    program?: string | null
    graduationYear?: number | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    isLocked?: boolean
    lockUntil?: Date | string | null
    isLandlordVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreateManyUniversityInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    fees?: string | null
    duration?: string | null
    degreeType?: string | null
    ieltsScore?: string | null
    ranking?: string | null
    intake?: CourseCreateintakeInput | string[]
    websiteLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareerOutcomeUpdateWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    iconImage?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
  }

  export type CareerOutcomeUncheckedUpdateWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    iconImage?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
  }

  export type CareerOutcomeUncheckedUpdateManyWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    iconImage?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    bgColor?: StringFieldUpdateOperationsInput | string
  }

  export type FaqUpdateWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type FaqUncheckedUpdateWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type FaqUncheckedUpdateManyWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type UniversityApplicationsUpdateWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApplicationsNestedInput
    course?: CourseUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type UniversityApplicationsUncheckedUpdateWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityApplicationsUncheckedUpdateManyWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanUpdateWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    eligibilityCriteria?: LoanUpdateeligibilityCriteriaInput | string[]
    documents?: LoanUpdatedocumentsInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxApplications?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: LoanApplicationUpdateManyWithoutLoanNestedInput
  }

  export type LoanUncheckedUpdateWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    eligibilityCriteria?: LoanUpdateeligibilityCriteriaInput | string[]
    documents?: LoanUpdatedocumentsInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxApplications?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: LoanApplicationUncheckedUpdateManyWithoutLoanNestedInput
  }

  export type LoanUncheckedUpdateManyWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    interestRate?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    eligibilityCriteria?: LoanUpdateeligibilityCriteriaInput | string[]
    documents?: LoanUpdatedocumentsInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxApplications?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    adminOf?: GroupUncheckedUpdateManyWithoutModeratorsNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: NullableStringFieldUpdateOperationsInput | string | null
    ieltsScore?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableStringFieldUpdateOperationsInput | string | null
    intake?: CourseUpdateintakeInput | string[]
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: UniversityApplicationsUpdateManyWithoutCourseNestedInput
    favByUsers?: FavCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: NullableStringFieldUpdateOperationsInput | string | null
    ieltsScore?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableStringFieldUpdateOperationsInput | string | null
    intake?: CourseUpdateintakeInput | string[]
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutCourseNestedInput
    favByUsers?: FavCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutUniversityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    degreeType?: NullableStringFieldUpdateOperationsInput | string | null
    ieltsScore?: NullableStringFieldUpdateOperationsInput | string | null
    ranking?: NullableStringFieldUpdateOperationsInput | string | null
    intake?: CourseUpdateintakeInput | string[]
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityApplicationsCreateManyCourseInput = {
    id?: string
    userId: string
    universityId: string
    status?: $Enums.ApplicationStatus
    appliedAt?: Date | string
    loanRequired?: boolean
    documents?: UniversityApplicationsCreatedocumentsInput | string[]
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavCourseCreateManyCourseInput = {
    id?: string
    userId: string
    universityId?: string | null
    universityName?: string | null
    courseName?: string | null
    createdAt?: Date | string
  }

  export type UniversityApplicationsUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApplicationsNestedInput
    university?: UniversityUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type UniversityApplicationsUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    universityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityApplicationsUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    universityId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavCourseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    universityName?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavCoursesNestedInput
  }

  export type FavCourseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    universityName?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    universityName?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationReviewCreateManyAccommodationInput = {
    id?: string
    rating: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type AccommodationRatingCreateManyAccommodationInput = {
    id?: string
    rating: number
    review?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikedAccommodationsCreateManyAccommodationInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingPlanCreateManyAccommodationInput = {
    id?: string
    type: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccommodationReviewUpdateWithoutAccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccommodationReviewsNestedInput
  }

  export type AccommodationReviewUncheckedUpdateWithoutAccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccommodationReviewUncheckedUpdateManyWithoutAccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccommodationRatingUpdateWithoutAccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccommodationRatingsNestedInput
  }

  export type AccommodationRatingUncheckedUpdateWithoutAccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationRatingUncheckedUpdateManyWithoutAccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedAccommodationsUpdateWithoutAccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikedAccommodationsNestedInput
  }

  export type LikedAccommodationsUncheckedUpdateWithoutAccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedAccommodationsUncheckedUpdateManyWithoutAccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingPlanUpdateWithoutAccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingPlanUncheckedUpdateWithoutAccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingPlanUncheckedUpdateManyWithoutAccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationCreateManyLoanInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    documents?: LoanApplicationCreatedocumentsInput | string[]
    academicInfo: JsonNullValueInput | InputJsonValue
    financialInfo: JsonNullValueInput | InputJsonValue
    notes?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoanApplicationUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    documents?: LoanApplicationUpdatedocumentsInput | string[]
    academicInfo?: JsonNullValueInput | InputJsonValue
    financialInfo?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLoanApplicationsNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    documents?: LoanApplicationUpdatedocumentsInput | string[]
    academicInfo?: JsonNullValueInput | InputJsonValue
    financialInfo?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationUncheckedUpdateManyWithoutLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    documents?: LoanApplicationUpdatedocumentsInput | string[]
    academicInfo?: JsonNullValueInput | InputJsonValue
    financialInfo?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyGroupInput = {
    id?: string
    title: string
    slug: string
    description: string
    date: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    image?: string | null
    location: string
    eventType?: $Enums.EventType
    registrationType?: $Enums.RegistrationType
    totalSlots: number
    registeredSlots?: number
    waitlistSlots?: number | null
    ticketPrice?: number | null
    currency?: string | null
    address?: string | null
    virtualLink?: string | null
    contactById: string
    status?: $Enums.EventStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleCreateManyGroupInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    bannerImg?: string | null
    images?: ArticleCreateimagesInput | string[]
    tags?: ArticleCreatetagsInput | string[]
    type?: $Enums.ArticleType
    status?: $Enums.ArticleStatus
    creatorId: string
    upVotes?: number
    downVotes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCreateManyGroupInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    creatorId: string
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupMemberCreateManyGroupInput = {
    id?: string
    userId: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
  }

  export type EventUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    registrationType?: EnumRegistrationTypeFieldUpdateOperationsInput | $Enums.RegistrationType
    totalSlots?: IntFieldUpdateOperationsInput | number
    registeredSlots?: IntFieldUpdateOperationsInput | number
    waitlistSlots?: NullableIntFieldUpdateOperationsInput | number | null
    ticketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactBy?: UserUpdateOneRequiredWithoutHostedEventsNestedInput
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    registrationType?: EnumRegistrationTypeFieldUpdateOperationsInput | $Enums.RegistrationType
    totalSlots?: IntFieldUpdateOperationsInput | number
    registeredSlots?: IntFieldUpdateOperationsInput | number
    waitlistSlots?: NullableIntFieldUpdateOperationsInput | number | null
    ticketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    contactById?: StringFieldUpdateOperationsInput | string
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    registrationType?: EnumRegistrationTypeFieldUpdateOperationsInput | $Enums.RegistrationType
    totalSlots?: IntFieldUpdateOperationsInput | number
    registeredSlots?: IntFieldUpdateOperationsInput | number
    waitlistSlots?: NullableIntFieldUpdateOperationsInput | number | null
    ticketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    contactById?: StringFieldUpdateOperationsInput | string
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    bannerImg?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleUpdateimagesInput | string[]
    tags?: ArticleUpdatetagsInput | string[]
    type?: EnumArticleTypeFieldUpdateOperationsInput | $Enums.ArticleType
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    upVotes?: IntFieldUpdateOperationsInput | number
    downVotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutArticlesNestedInput
    votes?: VoteUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    bannerImg?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleUpdateimagesInput | string[]
    tags?: ArticleUpdatetagsInput | string[]
    type?: EnumArticleTypeFieldUpdateOperationsInput | $Enums.ArticleType
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    upVotes?: IntFieldUpdateOperationsInput | number
    downVotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    bannerImg?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleUpdateimagesInput | string[]
    tags?: ArticleUpdatetagsInput | string[]
    type?: EnumArticleTypeFieldUpdateOperationsInput | $Enums.ArticleType
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    upVotes?: IntFieldUpdateOperationsInput | number
    downVotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedForumsNestedInput
    topics?: ForumTopicUpdateManyWithoutForumNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutForumNestedInput
  }

  export type ForumUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    creatorId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: ForumTopicUncheckedUpdateManyWithoutForumNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutForumNestedInput
  }

  export type ForumUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    creatorId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutAdminOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUpdateManyWithoutUserNestedInput
    createdForums?: ForumUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUpdateManyWithoutUserNestedInput
    university?: UniversityUpdateOneWithoutUsersNestedInput
    loanApplications?: LoanApplicationUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    otps?: OTPUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    following?: FollowUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUpdateManyWithoutCreatedByNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUpdateManyWithoutContactByNestedInput
    articles?: ArticleUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favCourses?: FavCourseUncheckedUpdateManyWithoutUserNestedInput
    quizAnswers?: QuizAnswerUncheckedUpdateManyWithoutUserNestedInput
    createdForums?: ForumUncheckedUpdateManyWithoutCreatorNestedInput
    createdForumTopics?: ForumTopicUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutCreatorNestedInput
    forumReplyReactions?: ForumReplyReactionUncheckedUpdateManyWithoutUserNestedInput
    forumPostReactions?: ForumPostReactionUncheckedUpdateManyWithoutUserNestedInput
    loanApplications?: LoanApplicationUncheckedUpdateManyWithoutUserNestedInput
    accommodationRatings?: AccommodationRatingUncheckedUpdateManyWithoutUserNestedInput
    applications?: UniversityApplicationsUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    accommodations?: AccommodationUncheckedUpdateManyWithoutLandlordNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    otps?: OTPUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    createdGroups?: GroupUncheckedUpdateManyWithoutCreatedByNestedInput
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    hostedEvents?: EventUncheckedUpdateManyWithoutContactByNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCreatorNestedInput
    accommodationReviews?: AccommodationReviewUncheckedUpdateManyWithoutUserNestedInput
    likedAccommodations?: LikedAccommodationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAdminOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    header?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    googleAccessToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleRefreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    googleTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastPasswordChangeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    otpRetryCount?: IntFieldUpdateOperationsInput | number
    otpLastSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpBlockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    program?: NullableStringFieldUpdateOperationsInput | string | null
    graduationYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    lockUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLandlordVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationCreateManyEventInput = {
    id?: string
    userId: string
    status?: $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventRegistrationUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumEventRegistrationStatusFieldUpdateOperationsInput | $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumEventRegistrationStatusFieldUpdateOperationsInput | $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumEventRegistrationStatusFieldUpdateOperationsInput | $Enums.EventRegistrationStatus
    additionalInfo?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicCreateManyForumInput = {
    id?: string
    title: string
    content: string
    creatorId: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumReplyCreateManyForumInput = {
    id?: string
    topicId: string
    userId: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    parentReplyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumTopicUpdateWithoutForumInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedForumTopicsNestedInput
    posts?: ForumPostUpdateManyWithoutTopicNestedInput
    replies?: ForumReplyUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicUncheckedUpdateWithoutForumInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostUncheckedUpdateManyWithoutTopicNestedInput
    replies?: ForumReplyUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicUncheckedUpdateManyWithoutForumInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyUpdateWithoutForumInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: ForumTopicUpdateOneRequiredWithoutRepliesNestedInput
    user?: UserUpdateOneRequiredWithoutForumRepliesNestedInput
    reactions?: ForumReplyReactionUpdateManyWithoutForumReplyNestedInput
    parentReply?: ForumReplyUpdateOneWithoutChildRepliesNestedInput
    childReplies?: ForumReplyUpdateManyWithoutParentReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateWithoutForumInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ForumReplyReactionUncheckedUpdateManyWithoutForumReplyNestedInput
    childReplies?: ForumReplyUncheckedUpdateManyWithoutParentReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateManyWithoutForumInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostCreateManyTopicInput = {
    id?: string
    content: string
    creatorId: string
    likes?: number
    parentPostId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumReplyCreateManyTopicInput = {
    id?: string
    forumId: string
    userId: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    parentReplyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutForumPostsNestedInput
    reactions?: ForumPostReactionUpdateManyWithoutForumPostNestedInput
    parentPost?: ForumPostUpdateOneWithoutRepliesNestedInput
    replies?: ForumPostUpdateManyWithoutParentPostNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    parentPostId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ForumPostReactionUncheckedUpdateManyWithoutForumPostNestedInput
    replies?: ForumPostUncheckedUpdateManyWithoutParentPostNestedInput
  }

  export type ForumPostUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    parentPostId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forum?: ForumUpdateOneRequiredWithoutForumRepliesNestedInput
    user?: UserUpdateOneRequiredWithoutForumRepliesNestedInput
    reactions?: ForumReplyReactionUpdateManyWithoutForumReplyNestedInput
    parentReply?: ForumReplyUpdateOneWithoutChildRepliesNestedInput
    childReplies?: ForumReplyUpdateManyWithoutParentReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ForumReplyReactionUncheckedUpdateManyWithoutForumReplyNestedInput
    childReplies?: ForumReplyUncheckedUpdateManyWithoutParentReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyReactionCreateManyForumReplyInput = {
    id?: string
    userId: string
    type: $Enums.ReactionType
  }

  export type ForumReplyCreateManyParentReplyInput = {
    id?: string
    forumId: string
    topicId: string
    userId: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumReplyReactionUpdateWithoutForumReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    user?: UserUpdateOneRequiredWithoutForumReplyReactionsNestedInput
  }

  export type ForumReplyReactionUncheckedUpdateWithoutForumReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ForumReplyReactionUncheckedUpdateManyWithoutForumReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ForumReplyUpdateWithoutParentReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forum?: ForumUpdateOneRequiredWithoutForumRepliesNestedInput
    topic?: ForumTopicUpdateOneRequiredWithoutRepliesNestedInput
    user?: UserUpdateOneRequiredWithoutForumRepliesNestedInput
    reactions?: ForumReplyReactionUpdateManyWithoutForumReplyNestedInput
    childReplies?: ForumReplyUpdateManyWithoutParentReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateWithoutParentReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ForumReplyReactionUncheckedUpdateManyWithoutForumReplyNestedInput
    childReplies?: ForumReplyUncheckedUpdateManyWithoutParentReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateManyWithoutParentReplyInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostReactionCreateManyForumPostInput = {
    id?: string
    userId: string
    type: $Enums.ReactionType
  }

  export type ForumPostCreateManyParentPostInput = {
    id?: string
    content: string
    topicId: string
    creatorId: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostReactionUpdateWithoutForumPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    user?: UserUpdateOneRequiredWithoutForumPostReactionsNestedInput
  }

  export type ForumPostReactionUncheckedUpdateWithoutForumPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ForumPostReactionUncheckedUpdateManyWithoutForumPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ForumPostUpdateWithoutParentPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: ForumTopicUpdateOneRequiredWithoutPostsNestedInput
    creator?: UserUpdateOneRequiredWithoutForumPostsNestedInput
    reactions?: ForumPostReactionUpdateManyWithoutForumPostNestedInput
    replies?: ForumPostUpdateManyWithoutParentPostNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutParentPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ForumPostReactionUncheckedUpdateManyWithoutForumPostNestedInput
    replies?: ForumPostUncheckedUpdateManyWithoutParentPostNestedInput
  }

  export type ForumPostUncheckedUpdateManyWithoutParentPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateManyArticleInput = {
    id?: string
    userId: string
    status: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavCourseCreateManyUserInput = {
    id?: string
    universityId?: string | null
    universityName?: string | null
    courseName?: string | null
    courseId: string
    createdAt?: Date | string
  }

  export type QuizAnswerCreateManyUserInput = {
    id?: number
    questionId: number
    answer: string
  }

  export type ForumCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    groupId: string
    type?: $Enums.ForumType
    privacy?: $Enums.ForumPrivacy
    attachments?: ForumCreateattachmentsInput | string[]
    viewCount?: number
    topicCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    isLocked?: boolean
    tags?: ForumCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumTopicCreateManyCreatorInput = {
    id?: string
    title: string
    content: string
    forumId: string
    type?: $Enums.TopicType
    isPinned?: boolean
    isClosed?: boolean
    viewCount?: number
    replyCount?: number
    lastReplyAt?: Date | string | null
    status?: $Enums.TopicStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumReplyCreateManyUserInput = {
    id?: string
    forumId: string
    topicId: string
    content: string
    attachments?: ForumReplyCreateattachmentsInput | string[]
    likes?: number
    parentReplyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostCreateManyCreatorInput = {
    id?: string
    content: string
    topicId: string
    likes?: number
    parentPostId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumReplyReactionCreateManyUserInput = {
    id?: string
    forumReplyId: string
    type: $Enums.ReactionType
  }

  export type ForumPostReactionCreateManyUserInput = {
    id?: string
    forumPostId: string
    type: $Enums.ReactionType
  }

  export type LoanApplicationCreateManyUserInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    documents?: LoanApplicationCreatedocumentsInput | string[]
    academicInfo: JsonNullValueInput | InputJsonValue
    financialInfo: JsonNullValueInput | InputJsonValue
    notes?: string | null
    loanId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccommodationRatingCreateManyUserInput = {
    id?: string
    rating: number
    review?: string | null
    accommodationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UniversityApplicationsCreateManyUserInput = {
    id?: string
    universityId: string
    courseId: string
    status?: $Enums.ApplicationStatus
    appliedAt?: Date | string
    loanRequired?: boolean
    documents?: UniversityApplicationsCreatedocumentsInput | string[]
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenCreateManyUserInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type AccommodationCreateManyLandlordInput = {
    id?: string
    title: string
    description: string
    type: $Enums.AccommodationType
    address: string
    city: string
    country: string
    banner: string
    includeBills?: boolean | null
    deposit?: number | null
    furnishing?: $Enums.FurnishingType | null
    bathrooms: number
    bedrooms: number
    size?: number | null
    amenities?: AccommodationCreateamenitiesInput | string[]
    rules?: AccommodationCreaterulesInput | string[]
    images?: AccommodationCreateimagesInput | string[]
    availableFrom: Date | string
    minTerm: number
    maxTerm?: number | null
    isAvailable?: boolean
    averageRating?: number | null
    totalRatings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    refreshToken?: string | null
    expires: Date | string
    lastActivity?: Date | string | null
    userAgent?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type OTPCreateManyUserInput = {
    id?: string
    otpCode: string
    type: $Enums.OTPType
    purpose: $Enums.OTPPurpose
    verified?: boolean
    attempts?: number
    expiresAt: Date | string
    verifiedAt?: Date | string | null
    invalidated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateManyFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowCreateManyFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    receiverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyReceiverInput = {
    id?: string
    content: string
    attachments?: MessageCreateattachmentsInput | string[]
    isRead?: boolean
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupCreateManyCreatedByInput = {
    id?: string
    name: string
    slug: string
    banner?: string | null
    logo?: string | null
    description: string
    privacy?: $Enums.GroupPrivacy
    followersCount?: number
    postsCount?: number
    isPinned?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupMemberCreateManyUserInput = {
    id?: string
    groupId: string
    role?: $Enums.GroupMemberRole
    joinedAt?: Date | string
  }

  export type EventCreateManyContactByInput = {
    id?: string
    title: string
    slug: string
    description: string
    date: Date | string
    startTime: Date | string
    endTime?: Date | string | null
    image?: string | null
    location: string
    eventType?: $Enums.EventType
    registrationType?: $Enums.RegistrationType
    totalSlots: number
    registeredSlots?: number
    waitlistSlots?: number | null
    ticketPrice?: number | null
    currency?: string | null
    address?: string | null
    virtualLink?: string | null
    groupId: string
    status?: $Enums.EventStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    bannerImg?: string | null
    images?: ArticleCreateimagesInput | string[]
    tags?: ArticleCreatetagsInput | string[]
    type?: $Enums.ArticleType
    status?: $Enums.ArticleStatus
    groupId?: string | null
    upVotes?: number
    downVotes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccommodationReviewCreateManyUserInput = {
    id?: string
    rating: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accommodationId: string
  }

  export type LikedAccommodationsCreateManyUserInput = {
    id?: string
    accommodationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavCourseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    universityName?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutFavByUsersNestedInput
  }

  export type FavCourseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    universityName?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavCourseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    universityId?: NullableStringFieldUpdateOperationsInput | string | null
    universityName?: NullableStringFieldUpdateOperationsInput | string | null
    courseName?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAnswerUpdateWithoutUserInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type QuizAnswerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type QuizAnswerUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type ForumUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutForumsNestedInput
    topics?: ForumTopicUpdateManyWithoutForumNestedInput
    forumReplies?: ForumReplyUpdateManyWithoutForumNestedInput
  }

  export type ForumUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: StringFieldUpdateOperationsInput | string
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: ForumTopicUncheckedUpdateManyWithoutForumNestedInput
    forumReplies?: ForumReplyUncheckedUpdateManyWithoutForumNestedInput
  }

  export type ForumUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: StringFieldUpdateOperationsInput | string
    type?: EnumForumTypeFieldUpdateOperationsInput | $Enums.ForumType
    privacy?: EnumForumPrivacyFieldUpdateOperationsInput | $Enums.ForumPrivacy
    attachments?: ForumUpdateattachmentsInput | string[]
    viewCount?: IntFieldUpdateOperationsInput | number
    topicCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: ForumUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forum?: ForumUpdateOneRequiredWithoutTopicsNestedInput
    posts?: ForumPostUpdateManyWithoutTopicNestedInput
    replies?: ForumReplyUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostUncheckedUpdateManyWithoutTopicNestedInput
    replies?: ForumReplyUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    type?: EnumTopicTypeFieldUpdateOperationsInput | $Enums.TopicType
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    viewCount?: IntFieldUpdateOperationsInput | number
    replyCount?: IntFieldUpdateOperationsInput | number
    lastReplyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forum?: ForumUpdateOneRequiredWithoutForumRepliesNestedInput
    topic?: ForumTopicUpdateOneRequiredWithoutRepliesNestedInput
    reactions?: ForumReplyReactionUpdateManyWithoutForumReplyNestedInput
    parentReply?: ForumReplyUpdateOneWithoutChildRepliesNestedInput
    childReplies?: ForumReplyUpdateManyWithoutParentReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ForumReplyReactionUncheckedUpdateManyWithoutForumReplyNestedInput
    childReplies?: ForumReplyUncheckedUpdateManyWithoutParentReplyNestedInput
  }

  export type ForumReplyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumId?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: ForumReplyUpdateattachmentsInput | string[]
    likes?: IntFieldUpdateOperationsInput | number
    parentReplyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: ForumTopicUpdateOneRequiredWithoutPostsNestedInput
    reactions?: ForumPostReactionUpdateManyWithoutForumPostNestedInput
    parentPost?: ForumPostUpdateOneWithoutRepliesNestedInput
    replies?: ForumPostUpdateManyWithoutParentPostNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    parentPostId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ForumPostReactionUncheckedUpdateManyWithoutForumPostNestedInput
    replies?: ForumPostUncheckedUpdateManyWithoutParentPostNestedInput
  }

  export type ForumPostUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    parentPostId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumReplyReactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    forumReply?: ForumReplyUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ForumReplyReactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumReplyId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ForumReplyReactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumReplyId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ForumPostReactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    forumPost?: ForumPostUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ForumPostReactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumPostId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type ForumPostReactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    forumPostId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
  }

  export type LoanApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    documents?: LoanApplicationUpdatedocumentsInput | string[]
    academicInfo?: JsonNullValueInput | InputJsonValue
    financialInfo?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loan?: LoanUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type LoanApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    documents?: LoanApplicationUpdatedocumentsInput | string[]
    academicInfo?: JsonNullValueInput | InputJsonValue
    financialInfo?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoanApplicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    documents?: LoanApplicationUpdatedocumentsInput | string[]
    academicInfo?: JsonNullValueInput | InputJsonValue
    financialInfo?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    loanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationRatingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodation?: AccommodationUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type AccommodationRatingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationRatingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityApplicationsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    university?: UniversityUpdateOneRequiredWithoutApplicationsNestedInput
    course?: CourseUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type UniversityApplicationsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    universityId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UniversityApplicationsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    universityId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loanRequired?: BoolFieldUpdateOperationsInput | boolean
    documents?: UniversityApplicationsUpdatedocumentsInput | string[]
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationUpdateWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: AccommodationReviewUpdateManyWithoutAccommodationNestedInput
    ratings?: AccommodationRatingUpdateManyWithoutAccommodationNestedInput
    likedBy?: LikedAccommodationsUpdateManyWithoutAccommodationNestedInput
    pricingPlans?: PricingPlanUpdateManyWithoutAccommodationNestedInput
  }

  export type AccommodationUncheckedUpdateWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: AccommodationReviewUncheckedUpdateManyWithoutAccommodationNestedInput
    ratings?: AccommodationRatingUncheckedUpdateManyWithoutAccommodationNestedInput
    likedBy?: LikedAccommodationsUncheckedUpdateManyWithoutAccommodationNestedInput
    pricingPlans?: PricingPlanUncheckedUpdateManyWithoutAccommodationNestedInput
  }

  export type AccommodationUncheckedUpdateManyWithoutLandlordInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAccommodationTypeFieldUpdateOperationsInput | $Enums.AccommodationType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    banner?: StringFieldUpdateOperationsInput | string
    includeBills?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    furnishing?: NullableEnumFurnishingTypeFieldUpdateOperationsInput | $Enums.FurnishingType | null
    bathrooms?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    amenities?: AccommodationUpdateamenitiesInput | string[]
    rules?: AccommodationUpdaterulesInput | string[]
    images?: AccommodationUpdateimagesInput | string[]
    availableFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    minTerm?: IntFieldUpdateOperationsInput | number
    maxTerm?: NullableIntFieldUpdateOperationsInput | number | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalRatings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    type?: EnumOTPTypeFieldUpdateOperationsInput | $Enums.OTPType
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    verified?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invalidated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    type?: EnumOTPTypeFieldUpdateOperationsInput | $Enums.OTPType
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    verified?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invalidated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTPUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    otpCode?: StringFieldUpdateOperationsInput | string
    type?: EnumOTPTypeFieldUpdateOperationsInput | $Enums.OTPType
    purpose?: EnumOTPPurposeFieldUpdateOperationsInput | $Enums.OTPPurpose
    verified?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invalidated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: MessageUpdateattachmentsInput | string[]
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutGroupNestedInput
    articles?: ArticleUpdateManyWithoutGroupNestedInput
    forums?: ForumUpdateManyWithoutGroupNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    moderators?: UserUpdateManyWithoutAdminOfNestedInput
  }

  export type GroupUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutGroupNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutGroupNestedInput
    forums?: ForumUncheckedUpdateManyWithoutGroupNestedInput
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    moderators?: UserUncheckedUpdateManyWithoutAdminOfNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUpdateWithoutModeratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedGroupsNestedInput
    events?: EventUpdateManyWithoutGroupNestedInput
    articles?: ArticleUpdateManyWithoutGroupNestedInput
    forums?: ForumUpdateManyWithoutGroupNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutModeratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutGroupNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutGroupNestedInput
    forums?: ForumUncheckedUpdateManyWithoutGroupNestedInput
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutModeratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    privacy?: EnumGroupPrivacyFieldUpdateOperationsInput | $Enums.GroupPrivacy
    followersCount?: IntFieldUpdateOperationsInput | number
    postsCount?: IntFieldUpdateOperationsInput | number
    createdById?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupMemberRoleFieldUpdateOperationsInput | $Enums.GroupMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutContactByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    registrationType?: EnumRegistrationTypeFieldUpdateOperationsInput | $Enums.RegistrationType
    totalSlots?: IntFieldUpdateOperationsInput | number
    registeredSlots?: IntFieldUpdateOperationsInput | number
    waitlistSlots?: NullableIntFieldUpdateOperationsInput | number | null
    ticketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutEventsNestedInput
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutContactByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    registrationType?: EnumRegistrationTypeFieldUpdateOperationsInput | $Enums.RegistrationType
    totalSlots?: IntFieldUpdateOperationsInput | number
    registeredSlots?: IntFieldUpdateOperationsInput | number
    waitlistSlots?: NullableIntFieldUpdateOperationsInput | number | null
    ticketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: StringFieldUpdateOperationsInput | string
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutContactByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    registrationType?: EnumRegistrationTypeFieldUpdateOperationsInput | $Enums.RegistrationType
    totalSlots?: IntFieldUpdateOperationsInput | number
    registeredSlots?: IntFieldUpdateOperationsInput | number
    waitlistSlots?: NullableIntFieldUpdateOperationsInput | number | null
    ticketPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    virtualLink?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: StringFieldUpdateOperationsInput | string
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    bannerImg?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleUpdateimagesInput | string[]
    tags?: ArticleUpdatetagsInput | string[]
    type?: EnumArticleTypeFieldUpdateOperationsInput | $Enums.ArticleType
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    upVotes?: IntFieldUpdateOperationsInput | number
    downVotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneWithoutArticlesNestedInput
    votes?: VoteUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    bannerImg?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleUpdateimagesInput | string[]
    tags?: ArticleUpdatetagsInput | string[]
    type?: EnumArticleTypeFieldUpdateOperationsInput | $Enums.ArticleType
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    upVotes?: IntFieldUpdateOperationsInput | number
    downVotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    bannerImg?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ArticleUpdateimagesInput | string[]
    tags?: ArticleUpdatetagsInput | string[]
    type?: EnumArticleTypeFieldUpdateOperationsInput | $Enums.ArticleType
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    upVotes?: IntFieldUpdateOperationsInput | number
    downVotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccommodationReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodation?: AccommodationUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type AccommodationReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationId?: StringFieldUpdateOperationsInput | string
  }

  export type AccommodationReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodationId?: StringFieldUpdateOperationsInput | string
  }

  export type LikedAccommodationsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accommodation?: AccommodationUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type LikedAccommodationsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikedAccommodationsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accommodationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentBlockCreateManyBlogInput = {
    id?: string
    type: string
    content: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentBlockUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentBlockUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentBlockUncheckedUpdateManyWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}